<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Etnly&#39;s Blog</title>
  
  <subtitle>Hello,World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gyunch.org/"/>
  <updated>2018-05-17T10:14:36.159Z</updated>
  <id>http://gyunch.org/</id>
  
  <author>
    <name>宇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python装饰器</title>
    <link href="http://gyunch.org/2016/10/30/python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://gyunch.org/2016/10/30/python装饰器/</id>
    <published>2016-10-29T16:00:00.000Z</published>
    <updated>2018-05-17T10:14:36.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python装饰器"><a href="#python装饰器" class="headerlink" title="python装饰器"></a><strong>python装饰器</strong></h1><p>🤔</p><hr><a id="more"></a><h2 id="装饰器介绍"><a href="#装饰器介绍" class="headerlink" title="装饰器介绍"></a><strong>装饰器介绍</strong></h2><blockquote><p>Python装饰器是程序开发中经常使用到的功能，熟练掌握装饰器会让你的编程思路更加广阔  </p></blockquote><p>要理解装饰器，首先要先理解：</p><ol><li>在 Python 中“函数是一等对象” 。即函数是一种特殊类型的变量，可以和其余变量一样，可以作为参数传递给函数，也可以作为返回值返回。Python 中的整数、字符串和字典等都是一等对象。</li><li>函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。</li></ol><hr><h2 id="装饰器实现"><a href="#装饰器实现" class="headerlink" title="装饰器实现"></a><strong>装饰器实现</strong></h2><p>装饰器本质上是python函数，它可以使其他函数在不需要做代码变动的情况下增加新的功能，装饰器返回值也是一个函数对象。</p><blockquote><p>以下是一个简单的例子：<br>假设现在有一个函数sayHi，用来输出一句话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def sayHi():</span><br><span class="line">    print(&apos;Hello, World&apos;)</span><br><span class="line">s = sayHi</span><br><span class="line">s()</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<code>Hello, World</code>  </p></blockquote><p>我想希望在不修改sayHi函数的情况下在其之前再输出一句话,这种在代码运行期间动态增加功能的方式，称之为“装饰器”。<br>本质上，装饰器就是一个返回函数的<a href="http://gyunch.org/2016/10/27/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">高阶函数</a></p><blockquote><p>我们可以这么写：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def sayName(func):</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;I&apos;m Yu&quot;)</span><br><span class="line">        return func</span><br><span class="line">    return inner()</span><br><span class="line"></span><br><span class="line">def sayHi():</span><br><span class="line">    print(&apos;Hello, World&apos;)</span><br><span class="line">s = sayName(sayHi)</span><br><span class="line">s()</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Yu</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure></p></blockquote><p>但代码美中不足的是，我们每次给sayHi增加功能都需要用到类似<code>s = sayName(sayHi)</code>这句话。<br>python为了简化这种情况，提供了一个语法糖“@”。</p><blockquote><p>简化上边的代码:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def sayName(func):</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;I&apos;m Yu&quot;)</span><br><span class="line">        return func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@sayName</span><br><span class="line">def sayHi():</span><br><span class="line">    print(&apos;Hello, World&apos;)</span><br><span class="line"></span><br><span class="line">sayHi()</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Yu</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="装饰器原理"><a href="#装饰器原理" class="headerlink" title="装饰器原理"></a><strong>装饰器原理</strong></h2><p>以上代码中，首先，在装饰器函数sayName中，sayName需要接受一个参数func，在其内部又定义了一个inner函数，在inner函数中增加一句输出，并返回func对象，然后sayName函数返回内部函数inner，其实就是一个闭包函数。<br>接下来在sayHi上边增加一个@sayName，其意义就是在python解释器之行到此处时，会调用装饰器函数（sayName），并把被装饰得函数（sayHi）作为参数传入。此时的sayHi已经不是未加装饰时的函数了，而是指向sayName.inner函数地址。在接下来调用sayHi()时，其实就是调用sayName.inner。</p><hr><h2 id="有参函数装饰"><a href="#有参函数装饰" class="headerlink" title="有参函数装饰"></a><strong>有参函数装饰</strong></h2><p>之前的例子是对无参函数的装饰，如果装饰带参数的函数该如何处理？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def sayName(func):</span><br><span class="line">    def inner(name):</span><br><span class="line">        print(&quot;I&apos;m Yu&quot;)</span><br><span class="line">        return func(name)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@sayName</span><br><span class="line">def sayHi(name):</span><br><span class="line">    print(&apos;Hi,&apos; + name)</span><br><span class="line"></span><br><span class="line">sayHi(&apos;siri&apos;)</span><br></pre></td></tr></table></figure></p><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Yu</span><br><span class="line">Hi,siri</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="两个装饰器装饰函数"><a href="#两个装饰器装饰函数" class="headerlink" title="两个装饰器装饰函数"></a><strong>两个装饰器装饰函数</strong></h2><p>这里测试两个装饰器装饰一个函数的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def sayName(func):</span><br><span class="line">    print(&apos;name&apos;)</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;I&apos;m Yu&quot;)</span><br><span class="line">        return func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">def sayAge(func):</span><br><span class="line">    print(&apos;age&apos;)</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;i&apos;m 30&quot;)</span><br><span class="line">        return  func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@sayName</span><br><span class="line">@sayAge</span><br><span class="line">def sayHi():</span><br><span class="line">    print(&apos;Hello, World&apos;)</span><br><span class="line"></span><br><span class="line">sayHi()</span><br></pre></td></tr></table></figure></p><blockquote><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age</span><br><span class="line">name</span><br><span class="line">I&apos;m Yu</span><br><span class="line">i&apos;m 30</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure></p></blockquote><p>接下来分析输出这个结果的原因：<br>首先，python解释器执行到第一个装饰器@sayName，在接下来发现装饰器下边不是一个函数而是另一个装饰器，解释器会执行第二个的装饰器@sayAge，然后把sayHi函数传入装饰器，所以首先输出了“age”，当@sayAge装饰完成，此时的sayHi函数地址指向了sayAge.inner的地址，解释器会返回去执行@sayName装饰器来装饰新的sayHi，从而输出了“name”，接着函数当前指向sayName.inner会先输出“I’m Yu”，在这里返回的func()其实就是返回的sayAge.inner，所以在下面输出i’m 30，最后输出原本sayHi的“Hello, World”</p><hr><h2 id="有参装饰器"><a href="#有参装饰器" class="headerlink" title="有参装饰器"></a><strong>有参装饰器</strong></h2><p>下边是装饰器带参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def now(time):</span><br><span class="line">    def sayName(func):</span><br><span class="line">        def inner(name):</span><br><span class="line">            print(&apos;现在是: %s&apos; % time)</span><br><span class="line">            print(&quot;I&apos;m Yu&quot;)</span><br><span class="line">            return func(name)</span><br><span class="line">        return inner</span><br><span class="line">    return sayName</span><br><span class="line"></span><br><span class="line">@now(&apos;2016/10/30&apos;)</span><br><span class="line">def sayHi(name):</span><br><span class="line">    print(&apos;Hello,&apos; + name)</span><br><span class="line"></span><br><span class="line">sayHi(&apos;siri&apos;)</span><br></pre></td></tr></table></figure></p><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在是: 2016/10/30</span><br><span class="line">I&apos;m Yu</span><br><span class="line">Hello,siri</span><br></pre></td></tr></table></figure></p></blockquote><hr><h3 id="以上就是python装饰器的相关介绍"><a href="#以上就是python装饰器的相关介绍" class="headerlink" title="以上就是python装饰器的相关介绍"></a><strong>以上就是python装饰器的相关介绍</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python装饰器&quot;&gt;&lt;a href=&quot;#python装饰器&quot; class=&quot;headerlink&quot; title=&quot;python装饰器&quot;&gt;&lt;/a&gt;&lt;strong&gt;python装饰器&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="设计模式" scheme="http://gyunch.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python函数式编程</title>
    <link href="http://gyunch.org/2016/10/27/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://gyunch.org/2016/10/27/python函数式编程/</id>
    <published>2016-10-26T16:00:00.000Z</published>
    <updated>2018-05-17T10:14:24.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python函数式编程"><a href="#python函数式编程" class="headerlink" title="python函数式编程"></a><strong>python函数式编程</strong></h1><p>🤔</p><hr><a id="more"></a><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a><strong>函数式编程</strong></h2><p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p><p>函数式编程Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。函数式编程就是一种抽象程度很高的编程范式。<br>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。<br>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。<br>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1freb7yyae5j30jm07pwf0.jpg" alt=" "><br>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。<br>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！<br>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言</p><hr><h2 id="函数式编程的优点"><a href="#函数式编程的优点" class="headerlink" title="函数式编程的优点"></a><strong>函数式编程的优点</strong></h2><ol><li><strong>逻辑可证</strong> <blockquote><p>这是一个学术上的优点：没有”边界效应”使得更容易从逻辑上证明程序是正确的。  </p></blockquote></li></ol><ul><li>边界效应是指在进行程序设计时，我们的编程思想、算法以及分析测试的数据有可能会接近我们所没有注意的边界。所有的操作设计都会有一个边界，例如整形数据的内存，很多情况下在进行程序设计时，往往会被我们所忽略</li></ul><ol start="2"><li><p><strong>模块化</strong> </p><blockquote><p>函数式编程推崇简单原则，一个函数只做一件事情，将大的功能拆分成尽可能小的模块。小的函数更易于阅读和检查错误。  </p></blockquote></li><li><p><strong>组件化</strong> </p><blockquote><p>小的函数更容易加以组合形成新的功能。  </p></blockquote></li><li><p><strong>易于调试</strong> </p><blockquote><p>细化的、定义清晰的函数使得调试更加简单。当程序不正常运行时，每一个函数都是检查数据是否正确的接口，能更快速地排除没有问题的代码，定位到出现问题的地方。  </p></blockquote></li><li><p><strong>易于测试</strong> </p><blockquote><p>不依赖于系统状态的函数无须在测试前构造测试桩，使得编写单元测试更加容易。  </p></blockquote></li><li><p><strong>更高的生产率</strong> </p><blockquote><p>函数式编程产生的代码比其他技术更少（往往是其他技术的一半左右），并且更容易阅读和维护。  </p></blockquote></li></ol><hr><h2 id="函数式编程的特征"><a href="#函数式编程的特征" class="headerlink" title="函数式编程的特征"></a><strong>函数式编程的特征</strong></h2><p>在支持函数式编程的语言中，大量使用如下特征的代码即可被认为是函数式：</p><ol><li><p><strong>函数是一等公民</strong></p><blockquote><p>函数能作为参数传递，或者是作为返回值返回。  </p></blockquote></li><li><p><strong>匿名函数(lambda)</strong></p><blockquote><p>lambda提供了快速编写简单函数的能力  </p></blockquote></li><li><p><strong>闭包</strong></p><blockquote><p>闭包引用了外层函数的变量，然后返回内层函数  </p></blockquote></li><li><p><strong>内置的不可变数据结构</strong></p><blockquote><p>如python中的元组  </p></blockquote></li><li><p><strong>内置模板函数</strong><br>::见下文中的高阶函数::</p></li><li><p>递归</p></li></ol><hr><h2 id="匿名函数-lambda"><a href="#匿名函数-lambda" class="headerlink" title="匿名函数(lambda)"></a><strong>匿名函数(lambda)</strong></h2><p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = lambda x: x+x</span><br><span class="line">print(p(10)</span><br></pre></td></tr></table></figure></p><p>其等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test(x):</span><br><span class="line">    return x+x</span><br><span class="line">p = test(10)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure></p><ul><li>这里我建议尽量避免使用lambda。lambda功能十分有限，只能有一个表达式，返回值就是该表达式的结果。最主要是语句过于复杂，lambda表达式会很难阅读</li></ul><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a><strong>高阶函数</strong></h2><ul><li>能接收函数做参数的函数:</li><li>变量可以指向函数</li><li>函数的参数可以接收变量</li><li><p>一个函数可以接收另一个函数作为参数<br>如：python内置函数，map()函数、reduce()函数、filter()函数等</p><blockquote><p>Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数  </p></blockquote></li><li><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test(x, y, z):</span><br><span class="line">    return z(x, y)</span><br><span class="line">print(test(2, 3, pow)) </span><br><span class="line">这里x，y是两个数值，z是一个函数</span><br></pre></td></tr></table></figure></li></ul><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a><strong>偏函数</strong></h2><p>Python的functools模块提供了很多有用的功能，偏函数是其中之一，偏函数把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br>如int()函数，其提供了base参数，默认值为10。如果传入base参数，就可以做进制的转换<br><code>int(&#39;101010&#39;, base=2)</code><br>如果经常需要做二进制转换我们就可以自己定义一个int2()函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def int2(x, base=2):</span><br><span class="line">    return int(x, base)</span><br></pre></td></tr></table></figure></p><p>这里如果我们使用functools.partial，就可以非常方便的直接创建一个int2()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line">int2 = partial(int, base=2)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python函数式编程&quot;&gt;&lt;a href=&quot;#python函数式编程&quot; class=&quot;headerlink&quot; title=&quot;python函数式编程&quot;&gt;&lt;/a&gt;&lt;strong&gt;python函数式编程&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="Functional" scheme="http://gyunch.org/tags/Functional/"/>
    
  </entry>
  
  <entry>
    <title>Lua简介</title>
    <link href="http://gyunch.org/2016/07/03/Lua%E7%AE%80%E4%BB%8B/"/>
    <id>http://gyunch.org/2016/07/03/Lua简介/</id>
    <published>2016-07-02T16:00:00.000Z</published>
    <updated>2018-05-16T14:04:32.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lua简介"><a href="#Lua简介" class="headerlink" title="Lua简介"></a><strong>Lua简介</strong></h1><p>🤔</p><hr><a id="more"></a><p>Lua是可扩展的轻量级编程语言，它是用C语言编写的，并于1993年开始作为一个内部项目开始诞生。Lua代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。一个完整的Lua解释器不过200k，在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。<br>它从一开始就设计为可以与用C语言编写等常规语言的代码集成软件。这种整合带来了很多好处。它不会尝试做C已经可以做东西，但旨在提供那些C是不好的：从测试和调试的硬件，动态结构，没有冗余，松藕合。对于这一点，lua有一个安全的环境，自动内存管理，以及处理字符串和其他类型的动态尺寸数据良好的设计。</p><hr><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h2><p>Lua提供了一组独特的功能，使得它与其他语言不同。这些包括：</p><ul><li>扩展</li><li>简单</li><li>高效</li><li>便携</li><li>免费和开源</li></ul><blockquote><p>示例代码:<br><code>print(&quot;Hello World!&quot;)</code></p></blockquote><hr><h2 id="Lua如何实现"><a href="#Lua如何实现" class="headerlink" title="Lua如何实现"></a><strong>Lua如何实现</strong></h2><p>Lua中包括的部件为Lua解释部分和运行软件系统。该软件系统功能是一个实际的计算机应用程序，它可以解释写在Lua的编程语言程序。 Lua解释是用ANSI C编写，因此它是非常便携，可以从高端网络服务器，以及小型设备设备上运行。<br>Lua语言解释器非常成熟，体积小，速度快。它已经从其他编程语言和上层软件的标准演变而来的。作为小型程序可以在低内存小的设备上运行。</p><hr><h2 id="Lua相关用途"><a href="#Lua相关用途" class="headerlink" title="Lua相关用途"></a><strong>Lua相关用途</strong></h2><ul><li>游戏编程</li><li>脚本中的独立应用程序</li><li>网页脚本</li><li>扩展和插件像MySQL代理和MySQL数据库的工作台</li><li>安全系统，如入侵检测系统</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lua简介&quot;&gt;&lt;a href=&quot;#Lua简介&quot; class=&quot;headerlink&quot; title=&quot;Lua简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;Lua简介&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Lua" scheme="http://gyunch.org/categories/Lua/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C#</title>
    <link href="http://gyunch.org/2016/05/01/C#%E7%AE%80%E4%BB%8B/"/>
    <id>http://gyunch.org/2016/05/01/C#简介/</id>
    <published>2016-04-30T16:00:00.000Z</published>
    <updated>2018-05-16T13:53:42.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C#"></a><strong>C#</strong></h1><hr><a id="more"></a><ul><li>C# 是一种面向对象的语言。不仅如此，C# 还进一步支持面向组件的编程。 当代软件设计越来越依赖采用自描述的独立功能包形式的软件组件。 此类组件的关键特征包括：为编程模型提供属性、方法和事件；包含提供组件声明性信息的特性；包含自己的文档。 C# 提供了语言构造来直接支持这些概念，让 C# 成为一种非常自然的语言，可用于创建和使用软件组件。</li><li>多项 C# 功能有助于构造可靠耐用的应用程序：垃圾回收可自动回收无法访问的未使用对象占用的内存；异常处理提供了一种结构化的可扩展方法来执行错误检测和恢复；C# 语言的类型安全设计禁止读取未初始化的变量、为范围之外的数组编制索引或执行未检查的类型转换。</li><li>C# 采用统一的类型系统。 所有 C# 类型（包括 int 和 double 等基元类型）均继承自一个根 object 类型。 因此，所有类型共用一组通用运算，任何类型的值都可以一致地进行存储、传输和处理。 此外，C# 还支持用户定义的引用类型和值类型，从而支持对象动态分配以及轻量级结构的内嵌式存储。<br>为了确保 C# 程序和库能够随着时间的推移以兼容的方式发展，C# 设计更强调版本控制。 许多编程语言很少关注这个问题，因此，当引入新版依赖库时，用这些语言编写的程序会出现更多不必要的中断现象。 由于更强调版本控制，直接受影响的 C# 设计方面包括单独的 virtual 和 override 修饰符、关于方法重载决策的规则，以及对显式接口成员声明的支持。</li><li>C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。<br>下面列出了 C# 成为一种广泛应用的专业语言的原因：<br>现代的、通用的编程语言。<br>面向对象。<br>面向组件。<br>容易学习。<br>结构化语言。<br>它产生高效率的程序。<br>它可以在多种计算机平台上编译。<br>.Net 框架的一部分。<br>C# 强大的编程功能<br>虽然 C# 的构想十分接近于传统高级语言 C 和 C++，是一门面向对象的编程语言，但是它与 Java 非常相似，有许多强大的编程功能，因此得到广大程序员的青睐。<br>下面列出 C# 一些重要的功能：<br>布尔条件（Boolean Conditions）<br>自动垃圾回收（Automatic Garbage Collection）<br>标准库（Standard Library）<br>组件版本（Assembly Versioning）<br>属性（Properties）和事件（Events）<br>委托（Delegates）和事件管理（Events Management）<br>易于使用的泛型（Generics）<br>索引器（Indexers）<br>条件编译（Conditional Compilation）<br>简单的多线程（Multithreading）<br>LINQ 和 Lambda 表达式<br>集成 Windows<br>详细指南可参考msdn，.net官方指南</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C#&quot;&gt;&lt;/a&gt;&lt;strong&gt;C#&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="C#" scheme="http://gyunch.org/categories/C/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构</title>
    <link href="http://gyunch.org/2016/04/01/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://gyunch.org/2016/04/01/Python数据结构/</id>
    <published>2016-03-31T16:00:00.000Z</published>
    <updated>2018-05-16T12:49:58.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python数据结构"><a href="#Python数据结构" class="headerlink" title="Python数据结构"></a><strong>Python数据结构</strong></h1><p>🤔</p><hr><a id="more"></a><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h2><p><strong>字符串</strong>是字符的序列，可以使用单引号、双引号及三引号来指定字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;etnly&apos;   </span><br><span class="line">name = &quot;etnly&quot;   </span><br><span class="line"># 两者工作机制完全相同   </span><br><span class="line">&apos;&apos;&apos;这是一个多行字符串   </span><br><span class="line">这是第二行   </span><br><span class="line">这位是第三行&apos;&apos;&apos;</span><br></pre></td></tr></table></figure></p><blockquote><p>在程序中使用的所有字符串都是str类下的对象，并且它也具有自己的方法，具体的方法清单可以查阅   help(str)   。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> # 返回字符串长度</span><br><span class="line">name = &apos;etnly&apos;</span><br><span class="line">len(name)</span><br><span class="line"> # 遍历字符串</span><br><span class="line">name = &apos;etnly&apos;</span><br><span class="line">for i in name:</span><br><span class="line">    print(i)</span><br><span class="line"> # 字符串切片</span><br><span class="line">print(name[1:3])</span><br><span class="line"> # 输出 tn</span><br></pre></td></tr></table></figure><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h2><p><strong>列表</strong>是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序列。和字符串类似，在字符串中这些项目是字符，而列表中它可以是任何类型，列表中的值称为<em>元素</em>。</p><ul><li>创建列表最简单的方式是使用 [] 方括号：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = [1, 2, 3]   </span><br><span class="line">name = [&apos;张三&apos;, &apos;李四&apos;]   </span><br><span class="line">other = [[1, 2, 3], &apos;a&apos;, &apos;b&apos; 3.0]</span><br></pre></td></tr></table></figure><blockquote><p>字符串的值是不可变的，而列表的值是可变的。如：   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num[1] = 3   </span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure><ul><li>输出：<br><code>[1, 3, 3]</code>  </li></ul><blockquote><p>列表对象也有自己的方法，具体可以查阅   help(list)   。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> # 列表遍历</span><br><span class="line">num = [1, 2, 3]</span><br><span class="line">for i in num:</span><br><span class="line">    print(i)</span><br><span class="line"> # 列表拼接</span><br><span class="line">num2 = [2, 3, 4]</span><br><span class="line">num3 = num + num2</span><br><span class="line"> # 列表切片</span><br><span class="line">print(num3[1:3])</span><br><span class="line"> # 这里输出 [2, 3]</span><br><span class="line"> # 添加元素</span><br><span class="line">num.append(4)</span><br></pre></td></tr></table></figure><hr><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a><strong>字典</strong></h2><p>字典类似于列表，但更加通用，在列表中下表必须是整数，而字典中，下标基本可以是任意类型。</p><p>字典包含键（下标）和值。每一个键都关联一个值，这种方式称为键值对，字典体现了键到值的映射，所以可以说每一个键映射到一个值。</p><ul><li><p>新建一个字典可以：</p><p> <code>d = {&#39;a&#39; : 1, &#39;b&#39; : 2, &#39;c&#39; : 3}</code><br> <code>d = dict() # 新建一个空字典</code></p></li></ul><blockquote><p>字典是通过散列表的方式实现的，意味着键必须是可散列的。<br>散列是一个函数，接收值并返回一个整数，字典使用这些被称为散列值的整数来保存和查找键值对。  </p></blockquote><hr><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a><strong>元组</strong></h2><p>元组用于将多个对象保存到一起，其值可以是任何类型，并按照下标索引，元组和列表非常相似，其二者主要区别在于，元组是不可变的。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值。</p><ul><li><p>元组语法上用逗号分隔一列值，可以用括号括起来：</p><p> <code>t = &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2</code><br> <code>t = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2)</code></p></li></ul><blockquote><p>用括号括起来单独的值如   t = (‘a’)   并不是元组，如要新建元组可以使用内置函数tuple  </p></blockquote><p><code>t = tuple()</code></p><blockquote><p>严格的来说函数只能返回一个值，但如果返回的是元组，就可以达到类似返回多个值的效果。  </p></blockquote><h3 id="元组、列表和字典"><a href="#元组、列表和字典" class="headerlink" title="元组、列表和字典"></a><strong>元组、列表和字典</strong></h3><h4 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h4><p>zip函数，接收两个或多个序列，并返回一个元组列表，每个元组包含来自每个序列的一个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;abc&apos;   </span><br><span class="line">b = [0, 1, 2]   </span><br><span class="line">print(zip(a, b))</span><br></pre></td></tr></table></figure><ul><li>结果返回   <code>&lt;zip object at 0x10d5e1b08&gt;</code>  </li></ul><blockquote><p>这是一个zip对象，它知道如何遍历每个元素对，zip对象是一种迭代器，即用来迭代访问一个序列的对象  </p></blockquote><p>使用zip最常见的方法是在for循环中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in zip(a, b):   </span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p><ul><li>输出：<code>(&#39;a&#39;, 0) (&#39;b&#39;, 1) (&#39;c&#39;, 2)</code></li></ul><p>如果需要使用列表的操作，可以利用zip对象制作一个列表：<br> <code>list(zip(a, b))</code></p><h4 id="字典和元组"><a href="#字典和元组" class="headerlink" title="字典和元组"></a>字典和元组</h4><p>字典方法items可以返回一个元组序列，其中每个元组是一个键值对：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;0 : &apos;a&apos;, 1 : &apos;b&apos;, 2 : &apos;c&apos;&#125;   </span><br><span class="line">t = d.items()   </span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure></p><ul><li>输出：  <code>dict_items([(0, &#39;a&#39;), (1, &#39;b&#39;), (2, ‘c’)])</code></li></ul><p>反过来可以使用元组列表来初始化一个字典：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = [(0, &apos;a&apos;), (1, &apos;b&apos;), (2, ‘c’)]   </span><br><span class="line">d = dict(t)</span><br></pre></td></tr></table></figure></p><ul><li><p>我们可以通过dict和items得到一个简洁的创建新字典的方法：</p><p><code>d = dict(zip(&#39;abc&#39;, range(3)))</code> </p></li></ul><hr><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a><strong>序列</strong></h2><p>列表、元组和字符串可以看作序列(Sequence)的某种表现形式，序列的主要功能是资格测试(也就是 in 与 not in 表达式)和索引操作，它们能够允许我们直接获取序列中的特定项目。</p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h2><p>当你创建了一个对象并将其分配给某个变量时，变量只会查阅某个对象，并且它也 不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部分。这叫作将名称绑定给那一个对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python数据结构&quot;&gt;&lt;a href=&quot;#Python数据结构&quot; class=&quot;headerlink&quot; title=&quot;Python数据结构&quot;&gt;&lt;/a&gt;&lt;strong&gt;Python数据结构&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python面向对象</title>
    <link href="http://gyunch.org/2016/04/01/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://gyunch.org/2016/04/01/Python面向对象/</id>
    <published>2016-03-31T16:00:00.000Z</published>
    <updated>2018-05-16T12:50:03.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python面向对象"><a href="#Python面向对象" class="headerlink" title="Python面向对象"></a><strong>Python面向对象</strong></h1><p>🤔</p><hr><a id="more"></a><h2 id="面向对象的编程"><a href="#面向对象的编程" class="headerlink" title="面向对象的编程"></a><strong>面向对象的编程</strong></h2><p>类与对象是面向对象编程的两个主要方面。一个类能够创建一种新的类型 ，其中对象就是类的实例。可以这样来类比:你可以拥有类型 int 的变量，也就是说存储整数的变量是 int 类的实例。 </p><blockquote><p>即使是整数也会被视为对象。这不同于 C++ 与c#，在它们那儿整数是原始内置类型  </p></blockquote><ul><li><strong>在Python中，一切皆为对象</strong>。 </li></ul><p>对象可以使用属于它的普通变量来存储数据。这种从属于对象或类的变量叫作字段 。对象还可以使用属于类的函数来实现某些功能，这种函数叫作类的方法 。这两个术语很重要，它有助于我们区分函数与变量，哪些是独立的，哪些又是属于类或对象的。总之，字段与方法通称类的属性。<br>字段有两种类型——它们属于某一类的各个实例或对象，或是从属于某一类本身。它们被分别称作实例变量与类变量。 </p><hr><h2 id="self"><a href="#self" class="headerlink" title="self"></a><strong>self</strong></h2><p>类方法与普通函数只有一种特定的区别——前者必须有一个额外的名字，这个名字必须添加到参数列表的开头，但是你不用在你调用这个功能时为这个参数赋值，Python 会为它提供。 这种特定的变量引用的是对象本身，按照惯例，它被赋􏰀 self 这一名称。 </p><blockquote><p>Python 中的 self 相当于 C++ 中的指针以及 Java 与 C# 中的 this 指针。  </p></blockquote><hr><h2 id="类"><a href="#类" class="headerlink" title="类"></a><strong>类</strong></h2><p>这是一个最简单的类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person:  </span><br><span class="line">    pass   # 空的代码块  </span><br><span class="line">p = Person()  # 创建Person的对象p</span><br></pre></td></tr></table></figure></p><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h2><p>一个简单的方法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person:  </span><br><span class="line">     def sayHi(self):  </span><br><span class="line">     print(‘Hello, World’)  </span><br><span class="line">p = Person()  </span><br><span class="line">p.sayHi()</span><br></pre></td></tr></table></figure><ul><li>输出:  <code>Hello, World</code> </li></ul><blockquote><p>唯一与函数不同的地方在于这里多了一个self  </p></blockquote><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><p>面向对象编程的一大优点是对代码的重用，重用的一种实现方法就是通过继承机制。继承指的是根据一个现有的类型，定义一个修改版本的新类的能力。继承最好是想象成在类之间实现类型与子类型关系的工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class SchoolMember: &apos;&apos;&apos;代表任何学校里的成员。&apos;&apos;&apos;</span><br><span class="line">def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        print(&apos;(Initialized SchoolMember: &#123;&#125;)&apos;.format(self.name))</span><br><span class="line">def tell(self):</span><br><span class="line">&apos;&apos;&apos;告诉我有关我的细节。&apos;&apos;&apos;</span><br><span class="line">print(&apos;Name:&quot;&#123;&#125;&quot; Age:&quot;&#123;&#125;&quot;&apos;.format(self.name, self.age), end=&quot; &quot;)</span><br><span class="line">class Teacher(SchoolMember): &apos;&apos;&apos;代表一位老师。&apos;&apos;&apos;</span><br><span class="line">def __init__(self, name, age, salary):</span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.salary = salary</span><br><span class="line">        print(&apos;(Initialized Teacher: &#123;&#125;)&apos;.format(self.name))</span><br><span class="line">    def tell(self):</span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        print(&apos;Salary: &quot;&#123;:d&#125;&quot;&apos;.format(self.salary))</span><br><span class="line">class Student(SchoolMember): &apos;&apos;&apos;代表一位学生。&apos;&apos;&apos;</span><br><span class="line">def __init__(self, name, age, marks):</span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.marks = marks</span><br><span class="line">        print(&apos;(Initialized Student: &#123;&#125;)&apos;.format(self.name))</span><br><span class="line">    def tell(self):</span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        print(&apos;Marks: &quot;&#123;:d&#125;&quot;&apos;.format(self.marks))</span><br><span class="line">t = Teacher(&apos;Mrs. Shrividya&apos;, 40, 30000)</span><br><span class="line">s = Student(&apos;Swaroop&apos;, 25, 75)</span><br><span class="line"># 打印一行空白行 print()</span><br><span class="line">members = [t, s]</span><br><span class="line">for member in members:</span><br><span class="line"># 对全体师生工作 member.tell()</span><br></pre></td></tr></table></figure></p><blockquote><p>有一些特征是他们都具有的，例如姓名、年龄和地址。另外一些特征是他们独有的，一如教师的薪水、课程与假期，学生的成绩和学费。你可以为每一种类型创建两个独立的类，并对它们进行处理。但增添一条共有特征就意味着将其添加进两个独立的类。这很快就会使程序变得笨重。<br>一个更好的方法是创建一个公共类叫作 SchoolMember ，然后让教师和学生从这个类中继承 ，也就是说他们将成为这一类型(类)的子类型，而我们就可以向这些子类型中添加某些该类独有的特征。<br>这种方法有诸多优点。如果我们增加或修改了 SchoolMember 的任何功能，它将自动反映在子类型中。举个例子，你可以通过简单地向 SchoolMember 类进行操作，来为所有老师与学生添加一条新的 ID 卡字段。不过，对某一子类型作出的改动并不会影响到其它子类型。另一大优点是你可以将某一老师或学生对象看作 SchoolMember 的对象并加以引用，这在某些情况下会大为有用，例如清点学校中的成员数量。这被称作多态性(Polymorphism)，在任何情 况下，如果父类型希望，子类型都可以被替换，也就是说，该对象可以被看作父类的实例。<br>同时还需要注意的是我们重用父类的代码，但我们不需要再其它类中重复它们，当我们使用独立类型时才会必要地重复这些代码。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python面向对象&quot;&gt;&lt;a href=&quot;#Python面向对象&quot; class=&quot;headerlink&quot; title=&quot;Python面向对象&quot;&gt;&lt;/a&gt;&lt;strong&gt;Python面向对象&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="OOP" scheme="http://gyunch.org/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Python基础(2)</title>
    <link href="http://gyunch.org/2016/03/30/Python%E5%9F%BA%E7%A1%80(2)/"/>
    <id>http://gyunch.org/2016/03/30/Python基础(2)/</id>
    <published>2016-03-29T16:00:00.000Z</published>
    <updated>2018-05-16T12:49:47.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python基础-2"><a href="#Python基础-2" class="headerlink" title="Python基础(2)"></a><strong>Python基础(2)</strong></h1><p>🤔</p><hr><a id="more"></a><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><p><strong>函数</strong>是指可重复使用的程序片段。它们允许你为某个代码块赋􏰀名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用函数。</p><ul><li>函数可以通过关键字 def 来定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def say():   </span><br><span class="line">    print(&apos;Hello, World&apos;)   </span><br><span class="line">say()</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h3><p>函数可以获取参数，这个参数的值由你所提供，借此，函数便可以利用这些值来做一些事情。这些参数与变量类似，这些变量的值在我们调用函数时已被定义，且在函数运行时均已赋值完成。在定义函数 时给定的名称称作“形参”，在调用函数时你所提供给函数的值称作“实参”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def reaArea(a, b):   </span><br><span class="line">    s = a * b   </span><br><span class="line">    return s   </span><br><span class="line">x = 10   </span><br><span class="line">y = 5   </span><br><span class="line">print(reaArea(x, y))</span><br></pre></td></tr></table></figure></p><blockquote><p>以上为计算机型面积的函数，调用reaArea函数时，我们以变量作为实参来调用函数，使得x的值赋给行参a、y的值赋给行参b，并返回两者的乘积。  </p></blockquote><ul><li>函数参数可以设置默认参数值，如：<br><code>def reaArea(a , b = 5):</code></li></ul><p>有时可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通 过使用星号来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func(a = 7, *b, **c):   </span><br><span class="line">    print(&apos;a&apos;, a)   </span><br><span class="line">    for i in b:   </span><br><span class="line">        print(&apos;b&apos;, i)   </span><br><span class="line">    for key, value in c.items():   </span><br><span class="line">        print(key, value)   </span><br><span class="line">func(10, 9, 8, 7, 6, 5, x = 1, y = 2, z = 3)</span><br></pre></td></tr></table></figure><ul><li>输出：<br><code>a 10   b 9   b 8   b 7   b 6   b 5   x 1   y 2   z 3</code></li></ul><blockquote><p>当声明一个如*a 星号参数时，从此处开始直到结束的所有位置参数都将被收集并汇集成一个元组。<br>类似地，当声明一个诸如 **b 的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个字典。  </p></blockquote><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a><strong>局部变量</strong></h3><p>在一个函数的定义中声明变量时，它们不会以任何方式与处于函数之外但具有相同名称的变量产生关系，也就是说，这些变量名只存在于函数这一局部。这被称为变量的作用域。所有变量的作用域是它们被定义的块，从定义它们的名字的定义点开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = 7   </span><br><span class="line">def func(n):   </span><br><span class="line">    print(&quot;1:&quot;, n)   </span><br><span class="line">    n = 10   </span><br><span class="line">    print(&quot;2:&quot;, n)   </span><br><span class="line">func(n)   </span><br><span class="line">print(&quot;3:&quot;, n)</span><br></pre></td></tr></table></figure></p><ul><li>输出：<br><code>1: 7     2: 10     3: 7</code></li></ul><blockquote><p>第一次打印出存在于函数块第一行名为 n 的值时，使用的是在函数声明之上的主代码块中声明的这一参数的值。<br>接着，将10赋值给n。n是我们这一函数的局部变量。因此，当改变函数中n的值的时候，主代码块中的n则不会受到影响。<br>最后一句 print 语句，打印出主代码块中定义的n的值，由此确认它不受先前调用的函数中的局部变量的影响。  </p></blockquote><h3 id="global语句"><a href="#global语句" class="headerlink" title="global语句"></a><strong>global语句</strong></h3><p>如果想给一个在程序顶层的变量赋值(也就是说它不存在于任何作用域中，无论是函数还是类)，那么你必须告诉程序这一变量并非局部的，而是全局的。我们需要通过global语句来完成这件事。因为在不使用global语句的情况下，不可能为一个定义于函数之外的变量赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = 7   </span><br><span class="line">def func():   </span><br><span class="line">    global n   </span><br><span class="line">    print(&quot;1:&quot;, n)   </span><br><span class="line">    n = 10   </span><br><span class="line">    print(&quot;2:&quot;, n)   </span><br><span class="line">func()   </span><br><span class="line">print(&quot;3:&quot;, n)</span><br></pre></td></tr></table></figure><ul><li>输出：<br> <code>1: 7     2: 10     3: 10</code></li></ul><blockquote><p>global语句用以声明n是一个全局变量，因此，当我们在函数中为n进行赋值时，这一改动将影响到我们在主代码块中使用的n的值  </p></blockquote><h3 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a><strong>return 语句</strong></h3><p> return 语句用于从函数中返回，也就是中断函数。我们也可以选择在中断函数时从函数中返回一个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def reaArea(a, b):   </span><br><span class="line">    s = a * b   </span><br><span class="line">    return s   </span><br><span class="line">x = 10   </span><br><span class="line">y = 5   </span><br><span class="line">print(reaArea(x, y))</span><br></pre></td></tr></table></figure></p><blockquote><p>如果 return 语句没有搭配任何一个值则代表着返回 None 。 None 在 Python 中一个特殊的类型，代表空。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python基础-2&quot;&gt;&lt;a href=&quot;#Python基础-2&quot; class=&quot;headerlink&quot; title=&quot;Python基础(2)&quot;&gt;&lt;/a&gt;&lt;strong&gt;Python基础(2)&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python基础(1)</title>
    <link href="http://gyunch.org/2016/03/27/Python%E5%9F%BA%E7%A1%80(1)/"/>
    <id>http://gyunch.org/2016/03/27/Python基础(1)/</id>
    <published>2016-03-26T16:00:00.000Z</published>
    <updated>2018-05-16T12:49:40.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python基础-1"><a href="#Python基础-1" class="headerlink" title="Python基础(1)"></a><strong>Python基础(1)</strong></h1><p>🤔</p><hr><a id="more"></a><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a><strong>赋值</strong></h2><p><strong>赋值语句</strong>可以创建新的变量，并为其赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">say = &apos;Hello, World&apos;</span><br><span class="line">num = 7</span><br></pre></td></tr></table></figure></p><blockquote><p>第一个语句将<strong>字符串</strong>赋给“say”变量；第二个语句将17赋给num。  </p></blockquote><hr><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a><strong>表达式</strong></h2><p><strong>表达式</strong>是变量、值、操作符的组合，单独的值与变量也被看作一个表达式</p><hr><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a><strong>语句</strong></h2><p><strong>语句</strong>是一段可以产生效果的代码单元，如创建一个变量或显示一个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">say = &apos;Hello, World&apos;</span><br><span class="line">print(say)</span><br></pre></td></tr></table></figure><blockquote><p>print语句显示say的值  </p></blockquote><hr><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><p>Python中注释以“#”开头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这里是注释 </span><br><span class="line">say = &apos;Hello, World&apos; </span><br><span class="line">print(say) # 输出say的值</span><br></pre></td></tr></table></figure></p><blockquote><p>如上所示，注释可以单独占一行，也可以加入到代码结尾。  </p></blockquote><hr><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a><strong>控制流</strong></h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><strong>if语句</strong></h3><p><strong>if语句</strong>用以检查条件:如果 条件为真(True)，我们将运行一块语句(if 块)，否则 我们将运行另一块语句(else 块)。else 从句是可选 的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = 7 </span><br><span class="line">if num &gt; 0: </span><br><span class="line">   print(&apos;num为正数&apos;) </span><br><span class="line">elif num == 0: </span><br><span class="line">   print(&apos;num等于0&apos;) </span><br><span class="line">else: </span><br><span class="line">   print(&apos;num为负数&apos;)</span><br></pre></td></tr></table></figure></p><ul><li>此处输出：<br><code>num为正数</code></li></ul><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a><strong>for语句</strong></h3><p>for…in 语句是循环语句的一种，其特点是会在一系列对象上进行迭代，意即它会遍历序列中的每一个项目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, 10): </span><br><span class="line"> print(i) </span><br><span class="line">else: </span><br><span class="line">   print(&apos;循环结束&apos;)</span><br></pre></td></tr></table></figure></p><ul><li>此处输出：<br><code>1 2 3 4 5 6 7 8 9 循环结束</code></li></ul><blockquote><p>for 循环就会在(1-9)这一范围内展开递归—— for i in range(1,10) 等价于 for i in [1，2，3， 4，5，6，7，8，9] ，这个操作将依次将队列里的每个数字(或是对象)分配给 i ，一次一个，然后以 每个 i 的值执行语句块<br>else 部分是可选的。当循环中包含他时，它总会在 for 循环结束后开始执 行，除非程序遇到了 break 语句。  </p></blockquote><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a><strong>while语句</strong></h3><p>while 语句能够让你在条件为真的前提下重复执行某块语句。 while 语句也是 一种循环语句。 while 语句同样可以拥有 else 子句作为可选选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num = 7 </span><br><span class="line">isRun = True </span><br><span class="line">whileisRun: </span><br><span class="line">  if num == 0: </span><br><span class="line">   isRun = False </span><br><span class="line">   else: </span><br><span class="line">   num = num - 1 </span><br><span class="line">else: </span><br><span class="line">   print(num)</span><br></pre></td></tr></table></figure></p><ul><li>此处输出：<br><code>0</code></li></ul><blockquote><p>While会在循环开始前检查变量是否为true，之后再执行相应的 while 块，直到变量为false，循环结束。  </p></blockquote><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a><strong>break语句</strong></h3><p>break 语句用以中断循环语句，也就是中止循环语句的执行，即使循环条件没有变更为 False ，或队列中的项目尚未完全迭代依旧如此。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, 10): </span><br><span class="line">   print(i)  </span><br><span class="line">   if i == 3: </span><br><span class="line">   break </span><br><span class="line">else: </span><br><span class="line">   print(&apos;循环结束&apos;)</span><br></pre></td></tr></table></figure></p><ul><li>此处输出：<br><code>1 2 3</code></li></ul><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a><strong>continue语句</strong></h3><p>continue 语句用以告诉 Python 跳过当前循环块中的剩余语句，并继续该循环的下一次迭代。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while True: </span><br><span class="line">    s = input(&apos;请输入名字&apos;) </span><br><span class="line">    if s == &apos;yu&apos;: </span><br><span class="line">        break </span><br><span class="line">    if len(s) &lt; 2: </span><br><span class="line">        print(&apos;请输入至少两个字符&apos;) </span><br><span class="line">        continue </span><br><span class="line">    print(&apos;名字为&apos;, s)</span><br></pre></td></tr></table></figure></p><blockquote><p>此处接收用户输入的内容，只有字符串长度大于等于2程序才会对其进行处理。如果其长度小 于 2，便通过使用 continue 语句跳过代码块中的其余语句。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python基础-1&quot;&gt;&lt;a href=&quot;#Python基础-1&quot; class=&quot;headerlink&quot; title=&quot;Python基础(1)&quot;&gt;&lt;/a&gt;&lt;strong&gt;Python基础(1)&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello,world</title>
    <link href="http://gyunch.org/2015/07/23/Hello,World/"/>
    <id>http://gyunch.org/2015/07/23/Hello,World/</id>
    <published>2015-07-22T16:00:00.000Z</published>
    <updated>2018-05-15T16:01:16.466Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="One"><a href="#One" class="headerlink" title="One"></a><strong>One</strong></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;One&quot;&gt;&lt;a href=&quot;#One&quot; class=&quot;headerlink&quot; title=&quot;One&quot;&gt;&lt;/a&gt;&lt;strong&gt;One&lt;/strong&gt;&lt;/h1&gt;
      
    
    </summary>
    
      <category term="介绍" scheme="http://gyunch.org/categories/%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="Hello" scheme="http://gyunch.org/tags/Hello/"/>
    
  </entry>
  
</feed>
