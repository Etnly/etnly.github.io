<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Etnly&#39;s Blog</title>
  
  <subtitle>Hello,World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gyunch.org/"/>
  <updated>2018-05-24T07:25:49.720Z</updated>
  <id>http://gyunch.org/</id>
  
  <author>
    <name>宇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shader入门</title>
    <link href="http://gyunch.org/2016/09/07/Shader%E5%85%A5%E9%97%A8/"/>
    <id>http://gyunch.org/2016/09/07/Shader入门/</id>
    <published>2016-09-06T16:00:00.000Z</published>
    <updated>2018-05-24T07:25:49.720Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a><strong>渲染流水线</strong></h2><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><ul><li>在了解什么是渲染流水线前先看一下现实生活中的<strong>流水线</strong>。<blockquote><p>流水线是一种工业上的生产方式，每一个生产单位只专注处理一个片段的工作。<br>比如一个制造手机的工厂，一台手机的制造流程可以分为四个步骤，第一步，制作外壳；第二步，制作屏幕模组；第三步，制作主板；第四步组装手机并进行产品包装。<br>在没有流水线时，只有在每台手机四个工序完成后才能开始制作下一台，这是非常耗时的。<br>如果我们加入流水线，虽然制作一台手机任需要四个步骤，但不需要从头到尾完成全部步骤，而是每个步骤由专人来完成，所有步骤并行进行。<br>使用流水线的好处在于可以提高单位时间的生产量。  </p></blockquote></li></ul><h3 id="渲染流水线-1"><a href="#渲染流水线-1" class="headerlink" title="渲染流水线"></a>渲染流水线</h3><ul><li>流水线的概念同样可以用于计算机的图像渲染中。计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以观察到的图像。这个工作通常有CPU和GPU共同完成</li><li>渲染流水线通常分为三个阶段：应用阶段 ———&gt; 几何阶段 ————&gt; 光栅化阶段<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1frmelhilk7j30f006emx8.jpg" alt=" "></li></ul><ol><li>应用阶段： 这个阶段有应用主导，通常由CPU负责实现。这一阶段开发者有三个主要任务，首先，需要准备好场景数据（摄相机位置、视锥体、模型和光源等）。其次，为了提高渲染性能，需要做粗粒度的剔除工作。最后，需要设置好每个模型的渲染状态（使用的材质、使用的纹理、使用的Shader等）这一阶段最重要的输出是渲染所需的几何信息，即渲染图元。</li><li>几何阶段：几何阶段主要用于处理所有和我们绘制的几何相关的事情。几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作。这个阶段可以进一步分成更小的流水线阶段。几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。</li><li>光栅化阶段： 这一阶段会使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。</li></ol><hr><h2 id="CPU和GPU之间的通信"><a href="#CPU和GPU之间的通信" class="headerlink" title="CPU和GPU之间的通信"></a><strong>CPU和GPU之间的通信</strong></h2><p>渲染流水线的起点是CPU，即应用阶段。大致可分为三个阶段：</p><ol><li>把数据加载到显存中：所有渲染所需的数据都需要从硬盘中加载到系统内存，然后，网格和纹理等数据又被加载到显存。</li><li>设置渲染状态：这些状态定义了场景中的网格如何被渲染。</li><li>调用Draw Call：Draw Call实际上就是一个命令，它的发起方是CPU,接收方是GPU，这个命令仅仅会指向一个需要被渲染的图元列表，而不会再包含任何材质信息。 当给定一个Draw Call时，GPU就会根据渲染状态和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的像素。</li></ol><hr><h2 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a><strong>GPU流水线</strong></h2><ul><li>当GPU从CPU得到渲染命令后，就会进行一系列的流水线操作，最终把图元渲染到屏幕上（就是上边的调用Draw Call）</li><li>对于渲染流水线中的后两个阶段（几何阶段和光栅化阶段）开发者无法拥有绝对的控制权，其实现的载体是GPU。GPU通过实现流水线化，大大加快了渲染速度，虽然我们无法完全控制这两个阶段的实现细节，但其向开发者开放了很多控制权。<br>下图展示了不同流水线阶段以及它们的可配执性和可编程性：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1frmf8dwj2jj30u50eft8r.jpg" alt=" "></li></ul><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><ul><li>顶点着色器是流水线的第一个阶段，它的输入来自于CPU。顶点着色器的处理单位是顶点,输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或销毁任何顶点，并无法得到顶点与顶点之间的关系</li><li>顶点着色器是完全可编程的，它通常用于实现顶点的坐标变换和逐顶点光照。<blockquote><p>坐标变换：就是对顶点的坐标进行某种变换—把顶点坐标从模型空间转换到齐次裁剪空间。我们可以通过坐标变换来模拟水面、面料等。  </p></blockquote></li></ul><h3 id="曲面细分着色器"><a href="#曲面细分着色器" class="headerlink" title="曲面细分着色器"></a>曲面细分着色器</h3><ul><li>是一个可选的着色器，主要用于细分图元。</li></ul><h3 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h3><ul><li>是一个可选的着色器，可用于执行逐图元的着色操作，或者被用于产生更多的图元。</li></ul><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><ul><li>这一阶段是可配置的。目的是把那些不在视野内的顶点裁剪掉，并剔除某些三角形图元的面片。</li><li>一个图元与摄像机视野的关系有3种：完全在视野内、部分在视野内、完全在视野外。</li></ul><ol><li>完全在视野内的图元会继续传递给下一个流水线阶段</li><li>完全在视野外的图元不会继续向下传递</li><li>部分在视野内的图元需要做裁剪处理<blockquote><p>和顶点着色器不同的是，这一步是不可编程的。我们无法通过编程来控制裁剪的过程，而是硬件上的固定操作。  </p></blockquote></li></ol><h3 id="屏幕映射"><a href="#屏幕映射" class="headerlink" title="屏幕映射"></a>屏幕映射</h3><ul><li>这一阶段是不可配置和编程的，负责把每个图元的坐标转换成屏幕坐标。</li><li>这一步输入的坐标仍然是三维坐标系下的坐标。屏幕映射的任务是把每个图元的x和y坐标转换到屏幕坐标系下。</li><li>屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素的距离。<blockquote><p>一个需要注意的地方，屏幕坐标系在OpenGL和DirectX中，OpenGL把屏幕左下角当作最小的窗口坐标值，DirectX则在屏幕左上角为最小窗口坐标值。  </p></blockquote></li></ul><h3 id="三角形设置"><a href="#三角形设置" class="headerlink" title="三角形设置"></a>三角形设置</h3><ul><li>由这一步开始进入光栅化阶段。</li><li>上一阶段输出的信息是屏幕坐标系下的顶点位置以及和它们相关的其他信息，如深度值、法线方向、视角方向等。</li><li>光栅化阶段的目标：1.计算每个图元覆盖了哪些像素 2.为这些像素计算它们的颜色</li><li>三角形设置作为光栅化的第一个阶段，会计算出光栅化一个三角网格所需要的信息。上一阶段的输出是三角网格的顶点，如果想得到整个三角网格的覆盖情况，就必须计算每条边上的像素坐标，为了计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个得到三角形边界表示方式的过程就是三角形设置。</li><li>它的输出是为下一个阶段做准备</li></ul><h3 id="三角形遍历"><a href="#三角形遍历" class="headerlink" title="三角形遍历"></a>三角形遍历</h3><ul><li>三角形遍历阶段将会检查每个像素是否被一个三角网格所覆盖。如果被覆盖，就会生成一个片元。而这样一个找到哪些像素被三角网格覆盖的过程，就是三角形遍历，这个阶段也被称为扫描变换。</li><li>三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角网格覆盖了哪些像素，并使用三角网格三个顶点的顶点信息对整个覆盖区域的像素进行插值。</li><li>这一步的输出就是得到一个片元序列。<blockquote><p>一个片元并不是真正意义上的像素，而是包含了很多状态的几何，这些状态用于计算每个像素的最终颜色  </p></blockquote></li></ul><h3 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h3><ul><li>片元着色器是另一个非常重要的可编程着色器阶段，在DirectX中，片元着色器被称为像素着色器。</li><li>片元着色器的输入就是上一阶段对顶点信息插值得到的结果，更具体点说，是根据从顶点着色器中输出的数据插值得到的。而其的输出是一个或者多个颜色值。</li><li>这一阶段可以完成很多重要的渲染技术，如纹理采样，但是它的局限在于，它仅可以影响单个片元。</li></ul><h3 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h3><ul><li>这是渲染流水线的最后一步，这一步骤的目的是：合并</li><li>这一阶段有几个主要任务：</li></ul><ol><li>决定每个片元的可见性。这涉及了深度测试、模板测试等</li><li>如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说是混合。<blockquote><p>这一阶段是高度可配置性的  </p></blockquote></li></ol><ul><li>这个阶段首先需要解决每个片元的可见性问题。这需要进行一系列的测试。<blockquote><p>片元 ——&gt; 模版测试 ——&gt; 深度测试 ——&gt; 混合 ——&gt; 颜色缓冲区  </p></blockquote></li></ul><blockquote><p>深度测试和模版测试的简化流程图：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1frmg6jpapzj31gm1feqv5.jpg" alt=" "></p></blockquote><h4 id="模板测试："><a href="#模板测试：" class="headerlink" title="模板测试："></a>模板测试：</h4><p>如果开启了模板测试，GPU会首先读取模板缓冲区中该片元位置的模板值，然后将该值和读取到的参考值（可以开发者自己指定）进行比较，开发者可以设定成小于时舍弃或者大于等于时舍弃该片元。模板测试通常用于限制渲染的区域，另外模板测试还有别的高级用法，如渲染阴影，轮廓渲染。</p><h4 id="深度测试："><a href="#深度测试：" class="headerlink" title="深度测试："></a>深度测试：</h4><p>如果一个片元幸运的通过了模板测试，那么就会进行深度测试，如果开启了深度深度，GPU就会把该片的深度值和已经存在于深度缓冲区中的深度值进行比较，这个比较函数也是由开发者设定的，可以选择大于此值时舍弃也可以选择小于等于此值时舍弃。但通常这个比较函数是小于等于的关系，这是因为我们我们总想只显示出离摄像机最近的物体，而那些被其他物体遮挡的片元就不需要出现在屏幕上。和模板测试不同的是，如果一个片元没有通过深度测试，他就没有权利修改深度缓冲区中的值。而如果通过了测试，开发者可以通开启/关闭深度写入来决定是否要利用这个片元的深度值覆盖缓冲区中的值。</p><h4 id="合并："><a href="#合并：" class="headerlink" title="合并："></a>合并：</h4><p>我们所讨论的渲染过程是一个物体接着一个物体渲染到屏幕上，而每个像素的颜色信息被存储在一个名为颜色缓冲的地方，因此当我们执行这次渲染时，颜色缓冲中往往已经有了上次渲染的颜色结果，那么我们是使用这次渲染得到的颜色完全覆盖掉之前的结果，还是进行其他处理，这就是合并需要解决的问题。<br>对于不透明物体，开发者可以关闭混合操作，这样片元着色器计算得到的颜色值就会直接覆盖掉颜色缓冲区中的像素值。但对于半透明的物体，我们就需要开启混合操作来让这个物体看起来是半透明的。混合操作是高度可配置的，开发者可以选择开启/关闭混合功能。如果开启了，GPU会取出源颜色和目标颜色，将两种颜色进行混合。源颜色是指片元着色器得到的颜色值，而目标颜色则是已经存在于颜色缓冲区中的颜色值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>真正实现渲染流水线的过程远比描述的要复杂，但Unity为我们封装了很多功能，我们只需要在一个Unity Shader设置一些输入、编写顶点着色器和片元着色器、设置一些状态，就可以实现大部分屏幕效果。在最新的unity中还集成了Shader蓝图工具供开发者使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Shader" scheme="http://gyunch.org/categories/Shader/"/>
    
    
      <category term="图形学" scheme="http://gyunch.org/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>K-近邻算法</title>
    <link href="http://gyunch.org/2016/09/02/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://gyunch.org/2016/09/02/K-近邻算法/</id>
    <published>2016-09-01T16:00:00.000Z</published>
    <updated>2018-05-24T05:42:10.508Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="K-近邻算法概述"><a href="#K-近邻算法概述" class="headerlink" title="K-近邻算法概述"></a><strong>K-近邻算法概述</strong></h2><ul><li>简单的说，K-近邻算法采用测量不同特征值之间的距离方法进行分类。</li><li>优点：精度高，对异常值不敏感，无数据输入假定。</li><li>缺点：计算复杂度高，空间复杂度高。</li><li>适用范围：数值型和标称型。</li></ul><hr><h2 id="K-近邻算法工作原理"><a href="#K-近邻算法工作原理" class="headerlink" title="K-近邻算法工作原理"></a><strong>K-近邻算法工作原理</strong></h2><p>存在一个样本数据集合，可以称之为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最邻近数据的分类标签。一般来说我们只选择样本数据集中前k个最相似的数据，这就是K-近邻算法中k的由来，通常k是不大于20的整数。最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p><hr><ul><li>下边是K-近邻算法的一个示例：</li></ul><ol><li>收集数据：提供文本文件。</li><li>准备数据：使用python解析文件。</li><li>分析数据：使用Matplotlib画而为扩散图</li><li>训练算法：</li><li>测试算法：以文件部分数据作为测试样本</li><li>使用算法：可以输入特征数据以判断是否正确</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">在文件datingTest中存放着某约会网站的样本数据，每个样本占据一行，共1000行。</span><br><span class="line">其中主要包括： 每年飞行里程数， 玩游戏所耗时间比， 每周消费的冰淇淋数。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">from numpy import *</span><br><span class="line">import os</span><br><span class="line">import operator</span><br><span class="line">import matplotlib</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from os import listdir</span><br><span class="line"></span><br><span class="line">def file2matrix(filename):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    处理输入格式</span><br><span class="line">    :param filename:</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    fr = open(filename)</span><br><span class="line">    numberOfLines = len(fr.readlines())       #得到文件行数</span><br><span class="line">    returnMat = zeros((numberOfLines,3))      #创建返回的NumPy矩阵</span><br><span class="line">    classLabelVector = []</span><br><span class="line">    fr = open(filename)</span><br><span class="line">    index = 0</span><br><span class="line">    for line in fr.readlines():                #解析文件数据到列表</span><br><span class="line">        line = line.strip()</span><br><span class="line">        listFromLine = line.split(&apos;\t&apos;)</span><br><span class="line">        returnMat[index,:] = listFromLine[0:3]</span><br><span class="line">        classLabelVector.append(int(listFromLine[-1]))</span><br><span class="line">        index += 1</span><br><span class="line">    return returnMat,classLabelVector</span><br><span class="line"></span><br><span class="line">def autoNorm(dataSet):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    将每列的最小值放在变量minVals中，最大值放在maxVals中，</span><br><span class="line">    其中dataSet.min（0）中的参数0使得函数可以从列中取最小值，而不是选取当前行最小值。</span><br><span class="line">    然后函数计算可能的取之范围，并创建新的矩阵返回</span><br><span class="line">    :param dataSet:</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    minVals = dataSet.min(0)</span><br><span class="line">    maxVals = dataSet.max(0)</span><br><span class="line">    ranges = maxVals - minVals</span><br><span class="line">    normDataSet = zeros(shape(dataSet))</span><br><span class="line">    m = dataSet.shape[0]</span><br><span class="line">    normDataSet = dataSet - tile(minVals, (m, 1))</span><br><span class="line">    normDataSet = normDataSet / tile(ranges, (m, 1))  #特征值相除</span><br><span class="line">    return normDataSet, ranges, minVals</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def classify0(inX, dataSet, labels, k):</span><br><span class="line">    dataSetSize = dataSet.shape[0]</span><br><span class="line"> #距离计算</span><br><span class="line">    diffMat = tile(inX, (dataSetSize,1)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**2</span><br><span class="line">    sqDistances = sqDiffMat.sum(axis=1)</span><br><span class="line">    distances = sqDistances**0.5</span><br><span class="line">    sortedDistIndicies = distances.argsort()</span><br><span class="line">    classCount=&#123;&#125;</span><br><span class="line">    for i in range(k):</span><br><span class="line">   #选择距离最小的k个点</span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1</span><br><span class="line">    #排序</span><br><span class="line">    sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True)</span><br><span class="line">    return sortedClassCount[0][0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def datingClassTest():</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    使用file2matrix和autoNorm函数从文件中读取数据并转换为归一化特征值</span><br><span class="line">    接着计算测试向量的数量，决定normMat向量中哪些数据用于测试，哪些用于训练样本</span><br><span class="line">    然后将两部分数据输入到原始分类起函数classify0，</span><br><span class="line">    最后计算错误率并返回</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    hoRatio = 0.10</span><br><span class="line">    datingDataMat, datingLabels = file2matrix(&apos;datingTestSet.txt&apos;)</span><br><span class="line">    normMat, range, minvals = autoNorm(datingDataMat)</span><br><span class="line">    m = normMat.shape[0]</span><br><span class="line">    numTestVecs = int(m*hoRatio)</span><br><span class="line">    errorCount = 0.0</span><br><span class="line">    for i in range(numTestVecs):</span><br><span class="line">        classifierResult = classify0(normMat[i,:], normMat[numTestVecs:m, :], datingLabels[numTestVecs:m], 3)</span><br><span class="line">        print(&quot;the classifier came back with : %d, the real answer is : %d&quot; %(classifierResult, datingLabels[i]))</span><br><span class="line">        if(classifierResult != datingLabels[i]):</span><br><span class="line">            errorCount += 1.0</span><br><span class="line">    print(&quot;the total error rate is : %f&quot; %(errorCount/float(numTestVecs)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">datingClassTest()</span><br><span class="line">datingDataMat, datingLabels = file2matrix(&apos;datingTestSet2.txt&apos;)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(111)</span><br><span class="line">ax.scatter(datingDataMat[:,1], datingDataMat[:,2])</span><br><span class="line">ax.scatter(datingDataMat[:, 1], datingDataMat[:, 2], 15.0*array(datingLabels), 15.0*array(datingLabels))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="AI" scheme="http://gyunch.org/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>FSM状态机</title>
    <link href="http://gyunch.org/2016/08/13/FSM%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://gyunch.org/2016/08/13/FSM状态机/</id>
    <published>2016-08-12T16:00:00.000Z</published>
    <updated>2018-05-23T10:46:36.300Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><ul><li>有限状态机，FSM，简称状态机，是表示有限个 以及在这些状态之间的转移和动作等行为的</li><li>在unitu中我们经常会判断一个人物（或怪物）的运动状态，如巡逻、追逐、攻击、死亡等，然后作出相应的操作，这些时候我们可以使用有限状态机来集中管理这些状态。</li><li>FSM在unity中算是一个比较重要的技巧</li></ul><blockquote><p>以下是我写的一个简单的FSM状态机的例子：<br>FSMState.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine.SceneManagement;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public abstract class FSMState &#123;</span><br><span class="line">//字典，字典中每一项都记录了一个“转换-状态”对 的信息</span><br><span class="line">protected Dictionary&lt;Transition, FSMStateID&gt; map = new Dictionary&lt;Transition, FSMStateID&gt;();</span><br><span class="line">//状态编号ID</span><br><span class="line">protected FSMStateID stateID;</span><br><span class="line">public FSMStateID ID &#123; get &#123; return stateID; &#125; &#125;</span><br><span class="line">//目标点位置</span><br><span class="line">protected Vector3 destPos;</span><br><span class="line">//巡逻点数组</span><br><span class="line">protected Transform[] waypoints;</span><br><span class="line">//旋转速度</span><br><span class="line">protected float curRotSpeed;</span><br><span class="line">//移动速度</span><br><span class="line">protected float curSpeed;</span><br><span class="line">//发现对面的距离</span><br><span class="line">public float chaseDistance&#123;</span><br><span class="line">get &#123;</span><br><span class="line">if (SceneManager.GetActiveScene ().name == &quot;PTMainScenes&quot;)</span><br><span class="line">return 10f;</span><br><span class="line">else</span><br><span class="line">return 1f;&#125;&#125;</span><br><span class="line">//攻击距离</span><br><span class="line">public float SRAttackDistance&#123;</span><br><span class="line">get &#123;</span><br><span class="line">if (SceneManager.GetActiveScene ().name == &quot;PTMainScenes&quot;)</span><br><span class="line">return 1f;</span><br><span class="line">else</span><br><span class="line">return 0.1f;&#125;&#125;</span><br><span class="line">//目标点距离</span><br><span class="line">protected float arriveDistance&#123;</span><br><span class="line">get &#123;</span><br><span class="line">if (SceneManager.GetActiveScene ().name == &quot;PTMainScenes&quot;)</span><br><span class="line">return 2f;</span><br><span class="line">else</span><br><span class="line">return 0.2f;&#125;&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 向字典添加项，每项是一个&quot;转换--状态&quot;对</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;transition&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void AddTransition(Transition transition, FSMStateID id)</span><br><span class="line">&#123;</span><br><span class="line">if (map.ContainsKey(transition))</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">map.Add(transition, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 从字典中删除项</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;trans&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void DeleteTransition(Transition trans)</span><br><span class="line">&#123;</span><br><span class="line">if (map.ContainsKey(trans))</span><br><span class="line">&#123;</span><br><span class="line">map.Remove(trans);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 通过查询字典，确定在当前状态下，发生trans转换时，应该转换到新的状态编号并返回</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;trans&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public FSMStateID GetOutputState(Transition trans)</span><br><span class="line">&#123;</span><br><span class="line">return map[trans];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 用来确定是否需要转换到其他状态，应该发生哪个转换</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;player&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;npc&quot;&gt;&lt;/param&gt;</span><br><span class="line">public abstract void Reason(Transform hero, Transform monster);</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 定义了在本状态的角色行为，移动，动画等</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;player&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;npc&quot;&gt;&lt;/param&gt;</span><br><span class="line">public abstract void Act(Transform hero, Transform monster);</span><br><span class="line"></span><br><span class="line">public virtual void Enter (Transform hero, Transform monster)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 选择随机逻辑点</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public void FindNextPoint()&#123;</span><br><span class="line">int rndIndex = Random.Range (0, waypoints.Length);</span><br><span class="line">Vector3 rndPosition = Vector3.zero;</span><br><span class="line">destPos = waypoints [rndIndex].position + rndPosition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>FSM.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class FSM : MonoBehaviour&#123;</span><br><span class="line">// 玩家位置</span><br><span class="line">protected Transform playerTranform;</span><br><span class="line">// 下一个巡逻点</span><br><span class="line">protected Vector3 destPos;</span><br><span class="line">// 巡逻点表单</span><br><span class="line">protected GameObject[] pointList;</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">protected float elapsedTime;</span><br><span class="line"></span><br><span class="line">protected virtual void Initialize()&#123;&#125;</span><br><span class="line">protected virtual void FSMUpdate()&#123;&#125;</span><br><span class="line">protected virtual void FSMFixedUpdate()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">void Start()&#123;</span><br><span class="line">Initialize ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//循环执行 </span><br><span class="line">void Update()&#123;</span><br><span class="line">FSMUpdate ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FixedUpdate()&#123;</span><br><span class="line">FSMFixedUpdate ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>AdvancedFSM.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public enum Transition&#123;</span><br><span class="line">SawPlayer = 0, //是否看到玩家</span><br><span class="line">ReachPlayer, //接近玩家</span><br><span class="line">LostPlayer, //玩家离开视线</span><br><span class="line">NoHealth, //死亡</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum FSMStateID&#123;</span><br><span class="line">Patrolling = 0, // 巡逻编号</span><br><span class="line">Chasing, // 追踪编号</span><br><span class="line">Attacking,</span><br><span class="line">Dead, // 死亡编号</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AdvancedFSM : FSM</span><br><span class="line">&#123;</span><br><span class="line">//FSM中的所有状态组成的列表</span><br><span class="line">private List&lt;FSMState&gt; fsmStates;</span><br><span class="line">//当前状态的编号</span><br><span class="line">private FSMStateID currentStateID;</span><br><span class="line">public FSMStateID CurrentStateID &#123; get &#123; return currentStateID; &#125; &#125;</span><br><span class="line">//当前状态</span><br><span class="line">private FSMState currentState;</span><br><span class="line">public FSMState CurrentState &#123; get &#123; return currentState; &#125; &#125;</span><br><span class="line"></span><br><span class="line">public AdvancedFSM()</span><br><span class="line">&#123;</span><br><span class="line">//新建一个空的状态列表</span><br><span class="line">fsmStates = new List&lt;FSMState&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">///向状态列表中加入一个新的状态</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public void AddFSMState(FSMState fsmState)</span><br><span class="line">&#123;</span><br><span class="line">if (fsmState == null)</span><br><span class="line">&#123;</span><br><span class="line">Debug.LogError(&quot;状态为空&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (fsmStates.Count == 0)</span><br><span class="line">&#123;</span><br><span class="line">fsmStates.Add(fsmState);</span><br><span class="line">currentState = fsmState;</span><br><span class="line">currentStateID = fsmState.ID;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach (FSMState state in fsmStates)</span><br><span class="line">&#123;</span><br><span class="line">if (state.ID == fsmState.ID)</span><br><span class="line">&#123;</span><br><span class="line">Debug.LogError(&quot;状态已存在&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//如果要加入的状态不在列表中，将它加入列表</span><br><span class="line">fsmStates.Add(fsmState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//从状态中删除一个状态   </span><br><span class="line">public void DeleteState(FSMStateID fsmState)</span><br><span class="line">&#123;</span><br><span class="line">// 搜索整个状态列表，如果要删除的状态在列表中，那么将它移除，否则报错</span><br><span class="line">foreach (FSMState state in fsmStates)</span><br><span class="line">&#123;</span><br><span class="line">if (state.ID == fsmState)</span><br><span class="line">&#123;</span><br><span class="line">fsmStates.Remove(state);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Debug.LogError(&quot;要删除的状态不在列表中&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 根据当前状态，和参数中传递的转换，转换到新状态</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public void PerformTransition(Transition trans)</span><br><span class="line">&#123;  </span><br><span class="line">FSMStateID id = currentState.GetOutputState(trans);        </span><br><span class="line">      </span><br><span class="line">currentStateID = id;</span><br><span class="line"></span><br><span class="line">foreach (FSMState state in fsmStates)</span><br><span class="line">&#123;</span><br><span class="line">if (state.ID == currentStateID)</span><br><span class="line">&#123;</span><br><span class="line">currentState = state;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>AttackState.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class AttackState : FSMState &#123;</span><br><span class="line"></span><br><span class="line">Animator monsterAnimator;</span><br><span class="line">AnimatorStateInfo stateInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public AttackState(Transform[] wp)&#123;</span><br><span class="line">waypoints = wp;</span><br><span class="line">stateID = FSMStateID.Attacking;</span><br><span class="line"></span><br><span class="line">curRotSpeed = 12;</span><br><span class="line">curSpeed = 100;</span><br><span class="line"></span><br><span class="line">FindNextPoint ();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override void Enter (Transform hero, Transform monster)</span><br><span class="line">&#123;</span><br><span class="line">monsterAnimator = monster.GetComponent&lt;Animator&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override void Reason(Transform hero, Transform monster)&#123;</span><br><span class="line">if (hero != null) &#123;</span><br><span class="line">stateInfo = monsterAnimator.GetCurrentAnimatorStateInfo (0);</span><br><span class="line">float dist = Vector3.Distance (monster.position, hero.position);</span><br><span class="line">if (dist &gt;= SRAttackDistance &amp;&amp; dist &lt; chaseDistance) &#123;</span><br><span class="line">if (stateInfo.IsName (&quot;skill&quot;) &amp;&amp; stateInfo.normalizedTime % 1 &gt; 0.9f)</span><br><span class="line">monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.SawPlayer);</span><br><span class="line">&#125; else if (dist &gt;= chaseDistance) &#123;</span><br><span class="line">if (stateInfo.IsName (&quot;skill&quot;) &amp;&amp; stateInfo.normalizedTime % 1 &gt; 0.9f)</span><br><span class="line">monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public override void Act(Transform hero, Transform monster)&#123;</span><br><span class="line">destPos = hero.position;</span><br><span class="line">Quaternion targetRotation = Quaternion.LookRotation (destPos - monster.position);</span><br><span class="line">monster.rotation = Quaternion.Slerp (monster.rotation, targetRotation, Time.deltaTime * curRotSpeed);</span><br><span class="line"></span><br><span class="line">//CharacterController controller = monster.GetComponent&lt;CharacterController&gt; ();</span><br><span class="line">//controller.SimpleMove (monster.transform.forward * Time.deltaTime * curSpeed);</span><br><span class="line"></span><br><span class="line">//播放攻击动画</span><br><span class="line"></span><br><span class="line">//Animator monsterAnimator = monster.GetComponent&lt;Animator&gt;();</span><br><span class="line">monsterAnimator.SetBool (&quot;isRun&quot;,false);</span><br><span class="line">monsterAnimator.SetBool (&quot;isAttack&quot;, true);</span><br><span class="line">monsterAnimator.SetBool (&quot;isWalk&quot;, false);</span><br><span class="line">monsterAnimator.SetBool (&quot;isDead&quot;, false);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>ChaseState.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine.AI;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line">public class ChaseState : FSMState &#123;</span><br><span class="line"></span><br><span class="line">NavMeshAgent monsterAgent;</span><br><span class="line">Animator monsterAnimator;</span><br><span class="line"></span><br><span class="line">public ChaseState(Transform[] wp)&#123;</span><br><span class="line">waypoints = wp;</span><br><span class="line">stateID = FSMStateID.Chasing;</span><br><span class="line"></span><br><span class="line">curRotSpeed = 7;</span><br><span class="line">curSpeed = 300;</span><br><span class="line"></span><br><span class="line">FindNextPoint ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public override void Enter (Transform hero, Transform monster)</span><br><span class="line">&#123;</span><br><span class="line">monsterAnimator = monster.GetComponent&lt;Animator&gt;();</span><br><span class="line">monsterAgent = monster.GetComponent&lt;NavMeshAgent&gt; ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override void Reason(Transform hero, Transform monster)&#123;</span><br><span class="line"></span><br><span class="line">if (hero != null) &#123;</span><br><span class="line">destPos = hero.position;</span><br><span class="line">float dist = Vector3.Distance (monster.position, destPos);</span><br><span class="line">if (dist &lt;= SRAttackDistance) &#123;</span><br><span class="line">AudioManager.Instance.PlayFXAudio (&quot;Sound_MonsterPatrolPlayer&quot;, monster.transform.position);</span><br><span class="line">monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.ReachPlayer);</span><br><span class="line"></span><br><span class="line">&#125; else if (dist &gt;= chaseDistance) &#123;</span><br><span class="line">monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public override void Act(Transform hero, Transform monster)&#123;</span><br><span class="line">destPos = hero.position;</span><br><span class="line">Quaternion targetRotation = Quaternion.LookRotation (destPos - monster.position);</span><br><span class="line">monster.rotation = Quaternion.Slerp (monster.rotation, targetRotation, Time.deltaTime * curRotSpeed);</span><br><span class="line">monsterAgent.SetDestination (destPos);</span><br><span class="line">if(SceneManager.GetActiveScene().name == &quot;PTMainScenes&quot;)</span><br><span class="line">monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 2;</span><br><span class="line">if (SceneManager.GetActiveScene ().name == &quot;ARMainScenes&quot;)</span><br><span class="line">monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 0.2f;</span><br><span class="line"></span><br><span class="line">//播放奔跑动画</span><br><span class="line"></span><br><span class="line">monsterAnimator.SetBool (&quot;isRun&quot;,true);</span><br><span class="line">monsterAnimator.SetBool (&quot;isAttack&quot;, false);</span><br><span class="line">monsterAnimator.SetBool (&quot;isWalk&quot;, false);</span><br><span class="line">monsterAnimator.SetBool (&quot;isDead&quot;, false);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>PatrolState.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine.AI;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line">public class PatrolState : FSMState&#123;</span><br><span class="line"></span><br><span class="line">Animator monsterAnimator;</span><br><span class="line">NavMeshAgent monsterAgent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public PatrolState(Transform[] wp)&#123;</span><br><span class="line">waypoints = wp;</span><br><span class="line">stateID = FSMStateID.Patrolling;</span><br><span class="line">curRotSpeed = 6;</span><br><span class="line">curSpeed = 200;</span><br><span class="line"></span><br><span class="line">FindNextPoint ();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override void Enter (Transform hero, Transform monster)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override void Reason(Transform hero, Transform monster)&#123;</span><br><span class="line">if (hero != null) &#123;</span><br><span class="line">if (Vector3.Distance (monster.position, hero.position) &lt;= chaseDistance) &#123;</span><br><span class="line">AudioManager.Instance.PlayFXAudio (&quot;Sound_MonsterSawPlayer&quot;, monster.transform.position);</span><br><span class="line">monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.SawPlayer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public override void Act(Transform hero, Transform monster)&#123;</span><br><span class="line">monsterAgent = monster.GetComponent&lt;NavMeshAgent&gt; ();</span><br><span class="line">if (!(monsterAgent.pathPending || monsterAgent.remainingDistance &gt; (monsterAgent.stoppingDistance + 0.5f) || monsterAgent.velocity != Vector3.zero)) &#123;</span><br><span class="line">FindNextPoint ();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//Physics.SphereCastAll ();</span><br><span class="line">//Quaternion targetRotation = Quaternion.LookRotation (destPos - monster.position);</span><br><span class="line">//monster.rotation = Quaternion.Slerp (monster.rotation, targetRotation, Time.deltaTime * curRotSpeed);</span><br><span class="line">monsterAgent.SetDestination (destPos);</span><br><span class="line">if(SceneManager.GetActiveScene().name == &quot;PTMainScenes&quot;)</span><br><span class="line">monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 1;</span><br><span class="line">if (SceneManager.GetActiveScene ().name == &quot;ARMainScenes&quot;)</span><br><span class="line">monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 0.1f;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//播放行走动画</span><br><span class="line"></span><br><span class="line">monsterAnimator = monster.GetComponent&lt;Animator&gt; ();</span><br><span class="line">monsterAnimator.SetBool (&quot;isRun&quot;,false);</span><br><span class="line">monsterAnimator.SetBool (&quot;isAttack&quot;, false);</span><br><span class="line">monsterAnimator.SetBool (&quot;isWalk&quot;, true);</span><br><span class="line">monsterAnimator.SetBool (&quot;isDead&quot;, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>DeadState.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.AI;</span><br><span class="line"></span><br><span class="line">public class DeadState : FSMState &#123;</span><br><span class="line">public DeadState()&#123;</span><br><span class="line">stateID = FSMStateID.Dead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override void Enter (Transform hero, Transform monster)</span><br><span class="line">&#123;</span><br><span class="line">monster.GetComponent&lt;NavMeshAgent&gt; ().enabled = false;</span><br><span class="line">monster.GetComponent&lt;Collider&gt; ().enabled = false;</span><br><span class="line">GameManager.Instance.AddScore ();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public override void Reason(Transform hero, Transform monster)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public override void Act (Transform hero, Transform monster)&#123;</span><br><span class="line"></span><br><span class="line">//播放死亡动画</span><br><span class="line">Animator monsterAnimator = monster.GetComponent&lt;Animator&gt;();</span><br><span class="line">monsterAnimator.SetBool (&quot;isRun&quot;,false);</span><br><span class="line">monsterAnimator.SetBool (&quot;isAttack&quot;, false);</span><br><span class="line">monsterAnimator.SetBool (&quot;isWalk&quot;, false);</span><br><span class="line">monsterAnimator.SetBool (&quot;isDead&quot;, true);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://gyunch.org/categories/Unity/"/>
    
    
      <category term="设计模式" scheme="http://gyunch.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Unity对象池</title>
    <link href="http://gyunch.org/2016/08/10/unity%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
    <id>http://gyunch.org/2016/08/10/unity对象池/</id>
    <published>2016-08-09T16:00:00.000Z</published>
    <updated>2018-05-23T10:00:31.547Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><ul><li>对象池的含义很简单，我们将对象储存在一个“池”中，当需要它时可以重复使用，而不是创建一个新的对象，尽可能的复用内存中已经驻留的资源来减少频繁的IO耗时操作。有经验的开发者在程序设计时就会做一个规范，其中包含了角色池，怪物池，特效池，经验池等。</li><li>以下代码中是一个简单的对象池示例，具体的说明在代码注释中呈现：</li></ul><blockquote><p>Singleton.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 单例模版类</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class Singleton&lt;T&gt; where T : new() &#123;</span><br><span class="line">    private static readonly T instance = new T();</span><br><span class="line"></span><br><span class="line">    public static T Instance&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>MonoSingleton.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 组建单例模版</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class MonoSingleten&lt;T&gt; : MonoBehaviour where T : MonoBehaviour&#123;</span><br><span class="line">    private static T instance;</span><br><span class="line">    public static T Instance&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            if (instance == null)&#123;</span><br><span class="line">                GameObject go = new GameObject(typeof(T).Name);</span><br><span class="line">                instance = go.AddComponent&lt;T&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            instance = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected virtual void Awake()&#123;</span><br><span class="line">        Instance = this as T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>IReusable.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 对象池接口</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public interface IReusable&#123;</span><br><span class="line">    //对象从对象池实例化的回调</span><br><span class="line">    void OnSpawned();</span><br><span class="line">    //对象返回对象池后的回调</span><br><span class="line">    void OnUnSpawned();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>PrefabType.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum PrefabType&#123;</span><br><span class="line">    None = 0,</span><br><span class="line">    Effects = 1,</span><br><span class="line">    Roles = 2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>ResourcesPath.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 资源路径</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class ResourcesPath &#123;</span><br><span class="line">    public const string prefabRoles = &quot;Prefabs/Roles/&quot;;</span><br><span class="line">    public const string prefabEffects = &quot;Prefabs/Effects/&quot;;</span><br><span class="line"></span><br><span class="line">    public static string GetPath(PrefabType type, string name)&#123;</span><br><span class="line">        string path = string.Empty;</span><br><span class="line">        switch(type)&#123;</span><br><span class="line">            case PrefabType.Effects:</span><br><span class="line">                path = ResourcesPath.prefabEffects + name;</span><br><span class="line">                break;</span><br><span class="line">            case PrefabType.Roles:</span><br><span class="line">                path = ResourcesPath.prefabRoles + name;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>ResourceFactory.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 资源工厂</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class ResourceFactory : Singleton&lt;ResourceFactory&gt; &#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 加载资源</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;The load.&lt;/returns&gt;</span><br><span class="line">    /// &lt;param name=&quot;path&quot;&gt;Path.&lt;/param&gt;</span><br><span class="line">    /// &lt;typeparam name=&quot;T&quot;&gt;The 1st type parameter.&lt;/typeparam&gt;</span><br><span class="line">    public T Load&lt;T&gt;(string path) where T : Object&#123;</span><br><span class="line">        T res = Resources.Load&lt;T&gt;(path);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>ObjectPoolMananger.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 对象池管理器</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class ObjectPoolMananger : MonoSingleten&lt;ObjectPoolMananger&gt; &#123;</span><br><span class="line">    private Dictionary&lt;string, ObjectPool&gt; mPools = new Dictionary&lt;string, ObjectPool&gt;();</span><br><span class="line"></span><br><span class="line">    //从对象池取出对象</span><br><span class="line">    public GameObject Spawn(PrefabType type, string name, Vector3 pos = default(Vector3), Quaternion rotation = default(Quaternion), Transform parent = null)&#123;</span><br><span class="line">        ObjectPool pool = null;</span><br><span class="line">        if (!mPools.ContainsKey(name))&#123;</span><br><span class="line">            //创建对象池</span><br><span class="line">            RegisterPoll(type, name);</span><br><span class="line">        &#125;</span><br><span class="line">        pool = mPools[name];</span><br><span class="line">        //从对象池中取出一个物体</span><br><span class="line">        GameObject obj = pool.Spawn();</span><br><span class="line"></span><br><span class="line">        obj.transform.SetParent(parent);</span><br><span class="line">        obj.transform.localPosition = pos;</span><br><span class="line">        obj.transform.localRotation = rotation;</span><br><span class="line">        return obj;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 对象池回收物体</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;obj&quot;&gt;Object.&lt;/param&gt;</span><br><span class="line">    public void UnSpawn(GameObject obj)&#123;</span><br><span class="line">        foreach(ObjectPool pool in mPools.Values)&#123;</span><br><span class="line">            if (pool.Contains(obj))&#123;</span><br><span class="line">                pool.UnSpawn(obj);</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Destroy(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 回收所有物体</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public void UnSpwanAll()&#123;</span><br><span class="line">        foreach(ObjectPool pool in mPools.Values)&#123;</span><br><span class="line">            pool.UnSpawnAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void RegisterPoll(PrefabType type, string name)&#123;</span><br><span class="line">        string path = ResourcesPath.GetPath(type, name);</span><br><span class="line">        GameObject prefab = ResourceFactory.Instance.Load&lt;GameObject&gt;(path);</span><br><span class="line">        ObjectPool pool = new ObjectPool(prefab);</span><br><span class="line">        mPools.Add(name, pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>ObjectPool.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 对象池类</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class ObjectPool&#123;</span><br><span class="line">    //预制体</span><br><span class="line">    private GameObject mPrefab;</span><br><span class="line">    //对象池</span><br><span class="line">    private List&lt;GameObject&gt; objectlist = new List&lt;GameObject&gt;();</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public ObjectPool(GameObject prefab)&#123;</span><br><span class="line">        this.mPrefab = prefab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 取出物体</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;The spawn.&lt;/returns&gt;</span><br><span class="line">    public GameObject Spawn()&#123;</span><br><span class="line">        GameObject obj = null;</span><br><span class="line">        for (int i = 0; i &lt; objectlist.Count; i++)&#123;</span><br><span class="line">            if (!objectlist[i].activeSelf)&#123;//如果有物体隐藏</span><br><span class="line">                obj = objectlist[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (obj == null)&#123;</span><br><span class="line">            obj = GameObject.Instantiate(mPrefab);</span><br><span class="line">            objectlist.Add(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.SetActive(true);</span><br><span class="line"></span><br><span class="line">        //获取对象池接口</span><br><span class="line">        IReusable reusable = obj.GetComponent&lt;IReusable&gt;();</span><br><span class="line">        if (reusable != null)&#123;</span><br><span class="line">            reusable.OnSpawned();</span><br><span class="line">        &#125;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 回收物体</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;obj&quot;&gt;Object.&lt;/param&gt;</span><br><span class="line">    public void UnSpawn(GameObject obj)&#123;</span><br><span class="line">        obj.SetActive(false);</span><br><span class="line">        IReusable reusable = obj.GetComponent&lt;IReusable&gt;();</span><br><span class="line">        if (reusable != null)&#123;</span><br><span class="line">            reusable.OnUnSpawned();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void UnSpawnAll() &#123;</span><br><span class="line">        foreach (GameObject obj in objectlist)&#123;</span><br><span class="line">            obj.SetActive(false);</span><br><span class="line">            IReusable reusable = obj.GetComponent&lt;IReusable&gt;();</span><br><span class="line">            if (reusable != null)&#123;</span><br><span class="line">                reusable.OnUnSpawned();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 判断物体是否存在</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;The contains.&lt;/returns&gt;</span><br><span class="line">    /// &lt;param name=&quot;obj&quot;&gt;Object.&lt;/param&gt;</span><br><span class="line">    public bool Contains(GameObject obj)&#123;</span><br><span class="line">        return objectlist.Contains(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>DestoryObjectPool.cs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 对象池销毁</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class DestoryObjectPool : MonoBehaviour, IReusable &#123;</span><br><span class="line">    public float mDestoryTime = 0.1f;</span><br><span class="line"></span><br><span class="line">    public void OnSpawned()</span><br><span class="line">    &#123;</span><br><span class="line">        Invoke(&quot;UnSpawn&quot;, mDestoryTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnUnSpawned()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void UnSpawn()&#123;</span><br><span class="line">        ObjectPoolMananger.Instance.UnSpawn(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://gyunch.org/categories/Unity/"/>
    
    
      <category term="设计模式" scheme="http://gyunch.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Unity单例</title>
    <link href="http://gyunch.org/2016/08/07/Unity%E5%8D%95%E4%BE%8B/"/>
    <id>http://gyunch.org/2016/08/07/Unity单例/</id>
    <published>2016-08-06T16:00:00.000Z</published>
    <updated>2018-05-23T09:54:37.712Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="什么是单例"><a href="#什么是单例" class="headerlink" title="什么是单例"></a>什么是单例</h2><ul><li>单例模式是开发中运用最广泛的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</li><li>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</li><li>其中要注意：</li></ul><ol><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ol><hr><h2 id="为什么要使用单例"><a href="#为什么要使用单例" class="headerlink" title="为什么要使用单例"></a>为什么要使用单例</h2><ul><li>在我们的整个游戏生命周期当中，有很多对象从始至终有且只有一个。这个唯一的实例只需要生成一次，并且直到游戏结束才需要销毁。</li><li>单例模式一般应用于管理器类，或者是一些需要持久化存在的对象。</li></ul><hr><h2 id="单例的实现"><a href="#单例的实现" class="headerlink" title="单例的实现"></a>单例的实现</h2><blockquote><p>c#单例的实现(如果在unity中不需要使用monobeheviour，也可以这样来创建单例)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Singleton </span><br><span class="line">&#123; </span><br><span class="line">   private static volatile Singleton instance; </span><br><span class="line">   private static object syncRoot = new Object(); </span><br><span class="line">   public static Singleton Instance </span><br><span class="line">   &#123; </span><br><span class="line">      get  </span><br><span class="line">      &#123; </span><br><span class="line">         if (instance == null)  </span><br><span class="line">         &#123; </span><br><span class="line">            lock (syncRoot)  </span><br><span class="line">            &#123; </span><br><span class="line">               if (instance == null)  </span><br><span class="line">                  instance = new Singleton(); </span><br><span class="line">            &#125; </span><br><span class="line">         &#125; </span><br><span class="line">         return instance; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>unity需要使用monobeheviour的单例实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public sealed class SingletonMoBehaviour: MonoBehaviour</span><br><span class="line">&#123; </span><br><span class="line">    private static volatile SingletonBehaviour instance; </span><br><span class="line">    private static object syncRoot = new Object(); </span><br><span class="line">    public static SingletonBehaviour Instance </span><br><span class="line">    &#123; </span><br><span class="line">        get  </span><br><span class="line">        &#123; </span><br><span class="line">            if (instance == null)  </span><br><span class="line">            &#123; </span><br><span class="line">                lock (syncRoot)  </span><br><span class="line">                &#123; </span><br><span class="line">                    if (instance == null)  &#123;</span><br><span class="line">                        SingletonBehaviour[] instances = FindObjectsOfType&lt;SingletonBehaviour&gt;();</span><br><span class="line">                        if (instances != null)&#123;</span><br><span class="line">                            for (var i = 0; i &lt; instances.Length; i++) &#123;</span><br><span class="line">                                Destroy(instances[i].gameObject);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        GameObject go = new GameObject(&quot;_SingletonBehaviour&quot;);</span><br><span class="line">                        instance = go.AddComponent&lt;SingletonBehaviour&gt;();</span><br><span class="line">                        DontDestroyOnLoad(go); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            return instance; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>其中主要区别在于monobeheviour不能使用构造函数进行实例化，只能挂载到GameObject上，而切换场景时当前场景的GameObject都会被销毁，所以单例也会被销毁，这里我们就需要DontDestroyOnLoad处理，同时为了保持场景当中只有一个实例，我们要对当前场景中的单例进行判断，如果存在其他的实例，则应该将其全部删除。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://gyunch.org/categories/Unity/"/>
    
    
      <category term="设计模式" scheme="http://gyunch.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫基础</title>
    <link href="http://gyunch.org/2016/07/20/python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
    <id>http://gyunch.org/2016/07/20/python爬虫基础/</id>
    <published>2016-07-19T16:00:00.000Z</published>
    <updated>2018-05-24T04:13:49.981Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="爬虫介绍"><a href="#爬虫介绍" class="headerlink" title="爬虫介绍"></a><strong>爬虫介绍</strong></h2><ul><li>爬虫是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本（来自于百度百科）。</li></ul><hr><h2 id="爬虫的目的"><a href="#爬虫的目的" class="headerlink" title="爬虫的目的"></a><strong>爬虫的目的</strong></h2><ol><li>爬取数据，进行市场调研和商业分析。</li><li>作为机器学习、数据挖掘的原始数据</li><li>爬取优质的资源</li></ol><hr><h2 id="爬虫实现过程"><a href="#爬虫实现过程" class="headerlink" title="爬虫实现过程"></a><strong>爬虫实现过程</strong></h2><ul><li>大部分爬虫都是按“发送请求——获得页面——解析页面——抽取并储存内容”这样的流程来进行，这其实也是模拟了我们使用浏览器获取网页信息的过程。</li></ul><hr><h2 id="python中的相关包"><a href="#python中的相关包" class="headerlink" title="python中的相关包"></a><strong>python中的相关包</strong></h2><ul><li>在python中有很多爬虫可用的包，如：urllib、requests、bs4、scrapy、pyspider 等</li></ul><hr><h2 id="简单的爬虫实例"><a href="#简单的爬虫实例" class="headerlink" title="简单的爬虫实例"></a><strong>简单的爬虫实例</strong></h2><ul><li>以下是一个简单的python爬虫，爬取前程无忧上成都unity3d的人才需求：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from pprint import pprint</span><br><span class="line">import csv</span><br><span class="line">from collections import Counter</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import jieba</span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line"></span><br><span class="line">class JobSpider:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.company = []</span><br><span class="line">        self.text = &quot;&quot;</span><br><span class="line">        self.headers = &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;,&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    def job_spider(self):</span><br><span class="line">        &quot;&quot;&quot; 爬虫入口</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        #要抓取的页面</span><br><span class="line">        url = &quot;https://search.51job.com/list/090200,000000,0000,00,9,99,Unity3d,2,1.html?lang=c&amp;stype=&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;providesalary=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=&quot;</span><br><span class="line">        urls = [url.format(p) for p in range(1, 100)]</span><br><span class="line">        for url in urls:</span><br><span class="line">            #请求网页</span><br><span class="line">            r = requests.get(url, headers=self.headers).content</span><br><span class="line">            #解析</span><br><span class="line">            bs = BeautifulSoup(r, &apos;lxml&apos;).find(&quot;div&quot;, class_=&quot;dw_table&quot;).find_all(&quot;div&quot;, class_=&quot;el&quot;)</span><br><span class="line">            for b in bs:</span><br><span class="line">                try:</span><br><span class="line">                    href, post = b.find(&apos;a&apos;)[&apos;href&apos;], b.find(&apos;a&apos;)[&apos;title&apos;]</span><br><span class="line">                    locate = b.find(&apos;span&apos;, class_=&apos;t3&apos;).text</span><br><span class="line">                    salary = b.find(&apos;span&apos;, class_=&apos;t4&apos;).text</span><br><span class="line">                    d = &#123;</span><br><span class="line">                        &apos;href&apos;: href,</span><br><span class="line">                        &apos;post&apos;: post,</span><br><span class="line">                        &apos;locate&apos;: locate,</span><br><span class="line">                        &apos;salary&apos;: salary</span><br><span class="line">                    &#125;</span><br><span class="line">                    self.company.append(d)</span><br><span class="line">                except Exception:</span><br><span class="line">                    pass</span><br><span class="line"></span><br><span class="line">    def post_require(self):</span><br><span class="line">        &quot;&quot;&quot; 爬取职位描述</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for c in self.company:</span><br><span class="line">            r = requests.get(</span><br><span class="line">                c.get(&apos;href&apos;), headers=self.headers).content.decode(&apos;gbk&apos;)</span><br><span class="line">            bs = BeautifulSoup(r, &apos;lxml&apos;).find(</span><br><span class="line">                &apos;div&apos;, class_=&quot;bmsg job_msg inbox&quot;).text</span><br><span class="line">            s = bs.replace(&quot;举报&quot;, &quot;&quot;).replace(&quot;分享&quot;, &quot;&quot;).replace(&quot;\t&quot;, &quot;&quot;).strip()</span><br><span class="line">            self.text += s</span><br><span class="line">        print(self.text)</span><br><span class="line">        with open(os.path.join(&quot;data&quot;, &quot;post_require.txt&quot;), &quot;w+&quot;) as f:</span><br><span class="line">            f.write(self.text)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def post_desc_counter():</span><br><span class="line">        &quot;&quot;&quot; 职位描述统计</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        post = open(os.path.join(&quot;data&quot;, &quot;post_require.txt&quot;),</span><br><span class="line">                    &quot;r&quot;).read()</span><br><span class="line"></span><br><span class="line">        # 使用 jieba 分词</span><br><span class="line">        file_path = os.path.join(&quot;data&quot;, &quot;user_dict.txt&quot;)</span><br><span class="line">        jieba.load_userdict(file_path)</span><br><span class="line">        seg_list = jieba.cut(post, cut_all=False)</span><br><span class="line">        counter = dict()</span><br><span class="line">        for seg in seg_list:</span><br><span class="line">            counter[seg] = counter.get(seg, 1) + 1</span><br><span class="line">        counter_sort = sorted(</span><br><span class="line">            counter.items(), key=lambda value: value[1], reverse=True)</span><br><span class="line">        pprint(counter_sort)</span><br><span class="line">        with open(os.path.join(&quot;data&quot;, &quot;post_pre_desc_counter.csv&quot;), &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">            f_csv = csv.writer(f)</span><br><span class="line">            f_csv.writerows(counter_sort)</span><br><span class="line"></span><br><span class="line">    def post_counter(self):</span><br><span class="line">        &quot;&quot;&quot; 职位统计</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        lst = [c.get(&apos;post&apos;) for c in self.company]</span><br><span class="line">        counter = Counter(lst)</span><br><span class="line">        counter_most = counter.most_common()</span><br><span class="line">        pprint(counter_most)</span><br><span class="line">        with open(os.path.join(&quot;data&quot;, &quot;post_pre_counter.csv&quot;),</span><br><span class="line">                  &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">            f_csv = csv.writer(f)</span><br><span class="line">            f_csv.writerows(counter_most)</span><br><span class="line"></span><br><span class="line">    def post_salary_locate(self):</span><br><span class="line">        &quot;&quot;&quot; 招聘大概信息，职位，薪酬以及工作地点</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        lst = []</span><br><span class="line">        for c in self.company:</span><br><span class="line">            lst.append((c.get(&apos;salary&apos;), c.get(&apos;post&apos;),c.get(&apos;title&apos;), c.get(&apos;href&apos;), c.get(&apos;locate&apos;)))</span><br><span class="line">        pprint(lst)</span><br><span class="line">        file_path = os.path.join(&quot;data&quot;, &quot;post_salary_locate.csv&quot;)</span><br><span class="line">        with open(file_path, &quot;w+&quot;) as f:</span><br><span class="line">            f_csv = csv.writer(f)</span><br><span class="line">            f_csv.writerows(lst)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def post_salary():</span><br><span class="line">        &quot;&quot;&quot; 薪酬统一处理</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        mouth = []</span><br><span class="line">        year = []</span><br><span class="line">        thousand = []</span><br><span class="line">        with open(os.path.join(&quot;data&quot;, &quot;post_salary_locate.csv&quot;),</span><br><span class="line">                  &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">            f_csv = csv.reader(f)</span><br><span class="line">            for row in f_csv:</span><br><span class="line">                if &quot;万/月&quot; in row[0]:</span><br><span class="line">                    mouth.append((row[0][:-3], row[2], row[1]))</span><br><span class="line">                elif &quot;万/年&quot; in row[0]:</span><br><span class="line">                    year.append((row[0][:-3], row[2], row[1]))</span><br><span class="line">                elif &quot;千/月&quot; in row[0]:</span><br><span class="line">                    thousand.append((row[0][:-3], row[2], row[1]))</span><br><span class="line">        # pprint(mouth)</span><br><span class="line"></span><br><span class="line">        calc = []</span><br><span class="line">        for m in mouth:</span><br><span class="line">            s = m[0].split(&quot;-&quot;)</span><br><span class="line">            calc.append(</span><br><span class="line">                (round(</span><br><span class="line">                    (float(s[1]) - float(s[0])) * 0.4 + float(s[0]), 1),</span><br><span class="line">                 m[1], m[2]))</span><br><span class="line">        for y in year:</span><br><span class="line">            s = y[0].split(&quot;-&quot;)</span><br><span class="line">            calc.append(</span><br><span class="line">                (round(</span><br><span class="line">                    ((float(s[1]) - float(s[0])) * 0.4 + float(s[0])) / 12, 1),</span><br><span class="line">                 y[1], y[2]))</span><br><span class="line">        for t in thousand:</span><br><span class="line">            s = t[0].split(&quot;-&quot;)</span><br><span class="line">            calc.append(</span><br><span class="line">                (round(</span><br><span class="line">                    ((float(s[1]) - float(s[0])) * 0.4 + float(s[0])) / 10, 1),</span><br><span class="line">                 t[1], t[2]))</span><br><span class="line">        pprint(calc)</span><br><span class="line">        with open(os.path.join(&quot;data&quot;, &quot;post_salary.csv&quot;),</span><br><span class="line">                  &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">            f_csv = csv.writer(f)</span><br><span class="line">            f_csv.writerows(calc)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def post_salary_counter():</span><br><span class="line">        # 薪酬统计</span><br><span class="line">        with open(os.path.join(&quot;data&quot;, &quot;post_salary.csv&quot;),</span><br><span class="line">                  &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">            f_csv = csv.reader(f)</span><br><span class="line">            lst = [row[0] for row in f_csv]</span><br><span class="line">        counter = Counter(lst).most_common()</span><br><span class="line">        pprint(counter)</span><br><span class="line">        with open(os.path.join(&quot;data&quot;, &quot;post_salary_counter1.csv&quot;),</span><br><span class="line">                  &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">            f_csv = csv.writer(f)</span><br><span class="line">            f_csv.writerows(counter)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def world_cloud():</span><br><span class="line">        &quot;&quot;&quot; 生成词云</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        counter = &#123;&#125;</span><br><span class="line">        with open(os.path.join(&quot;data&quot;, &quot;post_pre_desc_counter.csv&quot;),</span><br><span class="line">                  &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">            f_csv = csv.reader(f)</span><br><span class="line">            for row in f_csv:</span><br><span class="line">                counter[row[0]] = counter.get(row[0], int(row[1]))</span><br><span class="line">            pprint(counter)</span><br><span class="line">        file_path = os.path.join(&quot;font&quot;, &quot;msyh.ttf&quot;)</span><br><span class="line">        wc = WordCloud(font_path=file_path,</span><br><span class="line">                       max_words=100,</span><br><span class="line">                       height=600,</span><br><span class="line">                       width=1200)</span><br><span class="line">        wc.generate_from_frequencies(counter)</span><br><span class="line">        plt.imshow(wc)</span><br><span class="line">        plt.axis(&apos;off&apos;)</span><br><span class="line">        plt.show()</span><br><span class="line">        wc.to_file(os.path.join(&quot;images&quot;, &quot;wc.jpg&quot;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    spider = JobSpider()</span><br><span class="line">    spider.job_spider()</span><br><span class="line">    spider.post_salary_locate()</span><br><span class="line">    spider.post_salary()</span><br><span class="line">    spider.post_salary_counter()</span><br><span class="line">    spider.post_counter()</span><br><span class="line">    spider.world_cloud()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="爬虫" scheme="http://gyunch.org/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Lua面向对象</title>
    <link href="http://gyunch.org/2016/07/14/Lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://gyunch.org/2016/07/14/Lua面向对象/</id>
    <published>2016-07-13T16:00:00.000Z</published>
    <updated>2018-05-23T04:30:56.118Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h2><ul><li>1） 封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。</li><li>2） 继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。</li><li>3） 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。</li><li>4）抽象：抽象是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。</li></ul><hr><h2 id="Lua面向对象"><a href="#Lua面向对象" class="headerlink" title="Lua面向对象"></a>Lua面向对象</h2><p>Lua中最基本的结构是table，所以需要用table来描述对象的属性。Lua中的function可以用来表示方法。那么Lua中的类可以通过table + function模拟出来。<br>同时在Lua中，table就是一种对象。首先table与对象一样可以拥有状态。其次，table与对象一样拥有一个独立于其值的标识（self）。最后table与对象一样具有独立于创建者和创建地的生命周期。<br>对象有其自己的操作，在table中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Account = &#123;balance = 0&#125;</span><br><span class="line">function Account.withdraw(v)</span><br><span class="line">    Account.balance = Account.balance - v</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>以上代码，创建了一个新函数，并将该函数存入Account对象的withdraw字段中，可以进行以下调用：<br><code>Account.withdraw(100.00)</code><br>这种函数就是所谓的“方法”。不过在函数中使用全局名称 Account是一个不好的变成习惯。因为这个函数只能针对特定对象工作，并且这个特定对象还必须存储在特定的全局。如果改变了对象的名称，withdraw就不能继续工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = Account</span><br><span class="line">Account = nil</span><br><span class="line">a.withdraw(100.0) --这里会报错</span><br></pre></td></tr></table></figure></p><p>这种做法违反了之前所说对象的特性，即对象拥有独立的生命周期。<br>我们有一种灵活的方式，即置顶一项操作所做用的“接受者”，因此需要一个额外的参数来表示该接受者。这个参数通常为self或this：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Account.withdraw(self, v)</span><br><span class="line">    self.balance = self.balance - v</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">a1 = Account</span><br><span class="line">Account = nil</span><br><span class="line">a1.withdraw(a1, 7)</span><br></pre></td></tr></table></figure></p><p>使用self参数是所有面向对象语言的一个核心，大多数面向对象语言都能对程序员隐藏部分self参数，从而使的程序员不必显式的申明这个参数。在Lua中，只需要使用冒号，则能隐藏该参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Account:withdraw(v)</span><br><span class="line">    self.balance = self.balance - v</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">a = Account</span><br><span class="line">a:withdraw(10)</span><br></pre></td></tr></table></figure></p><hr><h2 id="Lua中的类"><a href="#Lua中的类" class="headerlink" title="Lua中的类"></a>Lua中的类</h2><p>类可以看作一个创建对象的模具。大多面向对象的语言都提供了类的概念，在这些语言中，每个对象都是某个特定类的实例。Lua中没有类的概念，每个对象只能自定义行为和形态。不过在Lua中可以模拟类，可以参数一些基于原型的语言，例如newtonscript。在这些语言中对象没有类型，而是每个对象都有一个原型，原型也是一种常规的对象，当其他对象遇到一个未知操作时，原型会先查找它。在这种语言中要表示一个类，只需要创建一个专用作其他对象的原型。<br>Lua中实现原型很简单，如果有两个对象，a和b，要让b作为a的一个原型，只需要如下操作：<br><code>setmetatable(a, {__index = b})</code><br>之后，a就会在b中查找所有它没有的操作，可以将b称为对象a的类。</p><p>在之前的例子中，为了创建更多的Account，可以让这些新的对象可以从Account行为中继承这些操作，具体的做法就是使用__index元方法。可以应用一些优化，无需创建一个额外的table作为元表，而是使用Account table自身作为元表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Account:new(o)</span><br><span class="line">    o = o or &#123;&#125; --如果没有提供table，则创建一个</span><br><span class="line">    setmetatable(o, self)</span><br><span class="line">    self.__index = self</span><br><span class="line">    return o</span><br><span class="line">end</span><br><span class="line">a = Account:new&#123;balance = 0&#125;</span><br><span class="line">a : withdraw(7)</span><br></pre></td></tr></table></figure></p><p>下面提供一个完整的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Shape = &#123;area = 0&#125;</span><br><span class="line">-- 基础类方法 new</span><br><span class="line">function Shape:new (o,side)</span><br><span class="line">  o = o or &#123;&#125;</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  side = side or 0</span><br><span class="line">  self.area = side*side;</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line">-- 基础类方法 printArea</span><br><span class="line">function Shape:printArea ()</span><br><span class="line">  print(&quot;面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line">-- 创建对象</span><br><span class="line">myshape = Shape:new(nil,10)</span><br><span class="line">myshape:printArea()</span><br></pre></td></tr></table></figure></p><hr><h2 id="Lua继承"><a href="#Lua继承" class="headerlink" title="Lua继承"></a>Lua继承</h2><p>继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。<br>以下演示了一个简单的继承实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Shape = &#123;area = 0&#125;</span><br><span class="line">-- 基础类方法 new</span><br><span class="line">function Shape:new (o,side)</span><br><span class="line">  o = o or &#123;&#125;</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  side = side or 0</span><br><span class="line">  self.area = side*side;</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line">-- 基础类方法 printArea</span><br><span class="line">function Shape:printArea ()</span><br><span class="line">  print(&quot;面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">myshape = Shape:new(nil,10)</span><br><span class="line">myshape:printArea()</span><br><span class="line"></span><br><span class="line">Square = Shape:new()</span><br><span class="line">-- 派生类方法 new</span><br><span class="line">function Square:new (o,side)</span><br><span class="line">  o = o or Shape:new(o,side)</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 派生类方法 printArea</span><br><span class="line">function Square:printArea ()</span><br><span class="line">  print(&quot;正方形面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">mysquare = Square:new(nil,10)</span><br><span class="line">mysquare:printArea()</span><br><span class="line"></span><br><span class="line">Rectangle = Shape:new()</span><br><span class="line">-- 派生类方法 new</span><br><span class="line">function Rectangle:new (o,length,breadth)</span><br><span class="line">  o = o or Shape:new(o)</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  self.area = length * breadth</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 派生类方法 printArea</span><br><span class="line">function Rectangle:printArea ()</span><br><span class="line">  print(&quot;矩形面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">myrectangle = Rectangle:new(nil,10,20)</span><br><span class="line">myrectangle:printArea()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Lua" scheme="http://gyunch.org/categories/Lua/"/>
    
    
      <category term="OOP" scheme="http://gyunch.org/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Lua进阶</title>
    <link href="http://gyunch.org/2016/07/09/Lua%E8%BF%9B%E9%98%B6/"/>
    <id>http://gyunch.org/2016/07/09/Lua进阶/</id>
    <published>2016-07-08T16:00:00.000Z</published>
    <updated>2018-05-19T05:15:50.393Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="Lua协程"><a href="#Lua协程" class="headerlink" title="Lua协程"></a>Lua协程</h2><ul><li>协程类似于线程，是一条执行序列，拥有自己独立的栈、局部变量和指令指针，同时与其他协程共享全局变量等。</li><li>线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。就是说，一个具有多个协程的程序在任意时刻只能运行一个协程，并且正在运行的协程只有在其显式的要求挂起时，他的执行才会暂停。</li><li>Lua将所有协程相关的函数放在一个名为“coroutine”的table中，其中主要方法有：</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>create()</td><td>用于创建新的协程，返回一个协程类型的值，参数是一个函数</td></tr><tr><td>resume()</td><td>用于启动或重启一个协程</td></tr><tr><td>yield()</td><td>挂起一个协程</td></tr><tr><td>wrap()</td><td>创建一个新协程，返回一个函数，调用函数时开启协程</td></tr><tr><td>status()</td><td>查看协程状态</td></tr></tbody></table><blockquote><p>通过status可以查看到一个协程可以处于4种不同的状态，分别是挂起（suspended）、运行（running）、死亡（dead）、正常（normal），当创建一个协程时，它处于挂起状态:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">co = coroutine.create(</span><br><span class="line">        function ()</span><br><span class="line">            print(&apos;Hello, World&apos;)</span><br><span class="line">        end</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(coroutine.status(co))</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<code>suspended --协程处于挂起状态</code>  </p></blockquote><blockquote><p>通过resume启动这个协程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coroutine.resume(co)</span><br><span class="line">print(coroutine.status(co))</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, World</span><br><span class="line">dead -- 处于死亡状态</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>协程真正强大之处在于yield函数，该函数可以使一个运行中的协程处于挂起，而后再恢复他的运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">co = coroutine.create(</span><br><span class="line">        function ()</span><br><span class="line">            for i = 1, 10 do</span><br><span class="line">                print(i)</span><br><span class="line">                coroutine.yield()</span><br><span class="line">            end</span><br><span class="line"> end)</span><br><span class="line"></span><br><span class="line">coroutine.resume(co)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">suspended --处于挂起状态</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在这里，当唤醒协程时它开始执行，直到遇到yield，协程会被挂起，此时的活动都发生在yield调用中，当恢复协程执行，对于yield的调用才会最终返回，然后写成继续执行，直到下一个yield或执行结束：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i = 1, 10 do</span><br><span class="line">    coroutine.resume(co)</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出：<code>2 3 4 5 6 7 8 9 10</code><br>再最后一次调用时，协程的内容已经执行完毕，并已经返回。因此这是的协程处于死亡状态，没有输出，如果试图再次执行它，resume将返回false及一条错误信息：<code>print(coroutine.resume(co))</code><br>输出：<code>false    cannot resume dead coroutine</code>  </p></blockquote><blockquote><p>下面是一个综合的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function foo (a)</span><br><span class="line">    print(&quot;foo 函数输出&quot;, a)</span><br><span class="line">    return coroutine.yield(2 * a) -- 返回  2*a 的值</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">co = coroutine.create(function (a , b)</span><br><span class="line">    print(&quot;第一次协同程序执行输出&quot;, a, b) -- co-body 1 10</span><br><span class="line">    local r = foo(a + 1)</span><br><span class="line">     </span><br><span class="line">    print(&quot;第二次协同程序执行输出&quot;, r)</span><br><span class="line">    local r, s = coroutine.yield(a + b, a - b)  -- a，b的值为第一次调用协同程序时传入</span><br><span class="line">     </span><br><span class="line">    print(&quot;第三次协同程序执行输出&quot;, r, s)</span><br><span class="line">    return b, &quot;结束协同程序&quot;                   -- b的值为第二次调用协同程序时传入</span><br><span class="line">end)</span><br><span class="line">        </span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, 1, 10)) -- true, 4</span><br><span class="line">print(&quot;--分割线----&quot;)</span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, &quot;r&quot;)) -- true 11 -9</span><br><span class="line">print(&quot;---分割线---&quot;)</span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- true 10 end</span><br><span class="line">print(&quot;---分割线---&quot;)</span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- cannot resume dead coroutine</span><br><span class="line">print(&quot;---分割线---&quot;)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一次协同程序执行输出     1     10</span><br><span class="line">foo 函数输出     2</span><br><span class="line">main     true     4</span><br><span class="line">--分割线----</span><br><span class="line">第二次协同程序执行输出     r</span><br><span class="line">main     true     11     -9</span><br><span class="line">---分割线---</span><br><span class="line">第三次协同程序执行输出     x     y</span><br><span class="line">main     true     10     结束协同程序</span><br><span class="line">---分割线---</span><br><span class="line">main     false     cannot resume dead coroutine</span><br><span class="line">---分割线---</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="Lua元表和元方法"><a href="#Lua元表和元方法" class="headerlink" title="Lua元表和元方法"></a>Lua元表和元方法</h2><ul><li>通常Lua中的每个值都有一套预定义的操作集合。例如数字四则运算，字符串链接，增加table的键值对等。但无法将两个table相加,无法对函数做比较，也无法调用字符串。</li><li>我们可以通过元表来修改一个值的行为，使其在面对一个非预定义的操作时执行一个指定的操作。如上所诉，可以通过元表让两个table相加。当Lua试图将两个table相加时，会先检测两者之一是否有元表，然后检测该元表中是否有__add字段，若找到该字段，就调用该字段对应的值。这个值也就是所谓的元方法（通常是一个函数或者table），这个函数会用于计算两个table的和。</li><li>Lua中的每一个值都有一个元表，table和userdata可以有各自独立的元表，其他类型则共享其类型所属的单一元表。Lua在创建新的table时不会创建元表。<blockquote><p>Lua中有两个重要的函数处理元表:</p></blockquote></li><li><strong>setmetatable(table, metatable):</strong> 对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。</li><li><strong>getmetatable(table):</strong> 返回对象的元表(metatable)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;</span><br><span class="line">t1 = &#123;&#125;</span><br><span class="line">setmetatable(t, t1)</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码可以简化为一行：<br><code>t = setmetatable({}, {})</code></p></blockquote><ul><li>任何table都可以作为任何值的元表，而一组相关的table也可以共享一个通用的元表，此元表描述了他们的共同行为。一个table甚至可以作为其自己的元表，用于描述其特有的行为。</li><li>在Lua代码中只能设置table的元表，若要设置其他类型值的元表，则必须通过c代码来完成。</li></ul><h3 id="index元方法"><a href="#index元方法" class="headerlink" title="__index元方法"></a><strong>__index元方法</strong></h3><ul><li>当访问一个table不存在的字段时，会返回nil。这些访问会促使解释器去查找一个叫做__index的元方法，如果没有这个方法，那么访问结果就会为nil，否则就由这个元方法来提供结果。</li></ul><p>假设要创建一个窗口的table，table中需要有位置、大小、背景等参数，所有参数都有默认值，因此希望在创建窗口对象时可以仅指定除了默认值的其他参数，这里我们可以这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window = &#123;&#125; --命名空间</span><br><span class="line">window.prototype = &#123;x = 0, y = 0, width = 70, height = 70&#125; --原型窗口</span><br><span class="line">window.mt = &#123;&#125; --创建元表</span><br><span class="line">function window.new(o) --声明构造函数</span><br><span class="line">    setmetatable(o, window.mt)</span><br><span class="line">    return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">window.mt.__index = function(table, key) --定义元方法</span><br><span class="line">    return window.prototype[key]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">w = window.new&#123;x = 10, y = 20&#125; -- 创建一个新窗口</span><br><span class="line">print(w.width)--查询它没有的字段</span><br><span class="line">--这里输出 70</span><br></pre></td></tr></table></figure></p><h3 id="newindex元方法"><a href="#newindex元方法" class="headerlink" title="__newindex元方法"></a><strong>__newindex元方法</strong></h3><ul><li><strong>newindex元方法和</strong>index类似，不同之处在于前者用于table更新，而后者用于在table中查询，当对一个table中不存在的索引赋值时，解释器就会查找这个元方法，如果有，解释器就调用它，而不是执行赋值。如果这个元方法是一个table，解释器就在这个table中赋值，而不是对原来的table。例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 = &#123;&#125;</span><br><span class="line">t = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123; __newindex = t1 &#125;)</span><br><span class="line"></span><br><span class="line">print(t.key1)</span><br><span class="line"></span><br><span class="line">t.newkey = &quot;新值2&quot;</span><br><span class="line">print(t.newkey,t1.newkey)</span><br><span class="line"></span><br><span class="line">t.key1 = &quot;新值1&quot;</span><br><span class="line">print(t.key1,t1.key1)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value1</span><br><span class="line">nil   新值2</span><br><span class="line">新值1   nil</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="算数类元方法"><a href="#算数类元方法" class="headerlink" title="算数类元方法"></a><strong>算数类元方法</strong></h3><ul><li>Lua中每种算数操作符都有对应的字段名，如下所示：</li></ul><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>__add</td><td>对应运算符”+”</td></tr><tr><td>__sub</td><td>对应运算符”-”</td></tr><tr><td>__mul</td><td>对应运算符”*”</td></tr><tr><td>__div</td><td>对应运算符”/”</td></tr><tr><td>__unm</td><td>对应运算符”-”</td></tr><tr><td>__concat</td><td>对应运算符”..”</td></tr><tr><td>__eq</td><td>对应运算符”==”</td></tr><tr><td>__mod</td><td>对应运算符”%”</td></tr><tr><td>__pow</td><td>对应运算符”^”</td></tr><tr><td>__lt</td><td>对应运算符”&lt;”</td></tr></tbody></table><h3 id="tostring元方法"><a href="#tostring元方法" class="headerlink" title="__tostring元方法"></a><strong>__tostring元方法</strong></h3><ul><li>函数print总是调用tostring来格式化输出。当格式化任意值时，tosrting会检查该值是否有__tostring元方法，如果有，tostring就会用该值作为参数来调用这个元方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t = setmetatable(&#123; 10, 20, 30 &#125;, &#123;</span><br><span class="line">    __tostring = function(t)</span><br><span class="line">        sum = 0</span><br><span class="line">        for k, v in pairs(t) do</span><br><span class="line">            sum = sum + v</span><br><span class="line">        end</span><br><span class="line">        return &quot;表所有元素的和为 &quot; .. sum</span><br><span class="line">    end</span><br><span class="line">&#125;)</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<code>表所有元素的和为 60</code>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Lua" scheme="http://gyunch.org/categories/Lua/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Lua基础</title>
    <link href="http://gyunch.org/2016/07/04/Lua%E5%9F%BA%E7%A1%80/"/>
    <id>http://gyunch.org/2016/07/04/Lua基础/</id>
    <published>2016-07-03T16:00:00.000Z</published>
    <updated>2018-05-19T04:39:15.654Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="Lua-IDE"><a href="#Lua-IDE" class="headerlink" title="Lua IDE"></a><strong>Lua IDE</strong></h2><p>Mac端Lua IDE推荐使用Intellij+EmmyLua。这也是我使用过最好的Lua IDE<br>下载地址：<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a><br>EmmyLua安装方法：Preferences ——&gt;Plugins ——&gt;搜索EmmyLua<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1frejiznphnj31di14m7ew.jpg" alt=""></p><blockquote><p>在使用EmmyLua时出现bug，或对此插件有什么建议，可以加群：<code>29860775</code>进行反馈  </p></blockquote><hr><h2 id="Lua-数据类型"><a href="#Lua-数据类型" class="headerlink" title="Lua 数据类型"></a><strong>Lua 数据类型</strong></h2><p>Lua是一种动态类型的语言。在语言中没有类型定义的语法，每个值都携带了它自身的类型信息。<br>在Lua中有8种基础类型，分别是nil、boolean、number、string、userdata、function、thread和table</p><table><thead><tr><th>名称</th><th>数据类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>nil</td><td>空类型</td><td>表示一个无效值</td><td>a</td></tr><tr><td>boolean</td><td>布尔</td><td>包含两个值：false和true</td><td>a = true</td></tr><tr><td>number</td><td>数字</td><td>双精度类型的实浮点数</td><td>a = 7</td></tr><tr><td>string</td><td>字符串</td><td>由一对双引号或单引号来表示</td><td>a = ‘yu’</td></tr><tr><td>userdata</td><td>自定义类型</td><td>任意存储在变量中的C数据结构</td><td>标准i/o库</td></tr><tr><td>function</td><td>函数</td><td>由 C 或 Lua 编写的函数</td><td>见下文</td></tr><tr><td>thread</td><td>协程</td><td>表示执行的独立线路，用于执行协同程序</td><td></td></tr><tr><td>table</td><td>表</td><td>Lua 中的表其实是一个”关联数组”</td><td>a = {}</td></tr></tbody></table><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h2><ul><li>Lua中的字符串通常表示“一个字符序列”。</li><li>Lua完全采用8位编码，Lua字符串中的字符可以具有任何数值编码，包括数值0。 也就是说，可以将任意二进制数据存储到一个字符串中。</li><li>Lua的字符串是不可变的值。</li><li>Lua的字符串和其他Lua对象一样，都是自动内存管理机制所管理的对象</li><li>Lua字符串可以用以下方式来表示：<br><code>s = &#39;Hello, World&#39;</code><br><code>s = &quot;Hello, World&quot;</code></li><li>Lua 提供了很多的方法来支持字符串的操作，可以查阅<a href="https://www.runoob.com/lua/lua-strings.html" target="_blank" rel="noopener">Lua 字符串</a>来了解更多</li></ul><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><ul><li>Lua 变量有两种类型：全局变量、局部变量。</li><li>Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声 明为局部变量。</li><li>局部变量的作用域为从声明位置开始到所在语句块结束。</li><li>变量的默认值均为 nil。<br><code>local i = 1 --局部变量</code></li></ul><hr><h2 id="Lua-流程控制"><a href="#Lua-流程控制" class="headerlink" title="Lua 流程控制"></a><strong>Lua 流程控制</strong></h2><ul><li>lua提供了一组传统的流程控制，if-else</li><li>if语句先测试条件，然后根据结果执行then部分或else部分，其中else部分是可选的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = 0</span><br><span class="line">if a &gt; 0 then</span><br><span class="line">    print(&apos;a &gt; 0&apos;)</span><br><span class="line">elseif a &lt; 0 then</span><br><span class="line">    print(&apos;a&lt; 0&apos;)</span><br><span class="line">else</span><br><span class="line">    print(&apos;a = 0&apos;)</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Lua-循环"><a href="#Lua-循环" class="headerlink" title="Lua 循环"></a><strong>Lua 循环</strong></h2><ul><li>Lua 语言提供了以下几种循环:</li></ul><ol><li>while</li><li>for</li><li>repeat…until</li></ol><ul><li>同时Lua 支持 break语句</li></ul><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><ul><li>与其他语言一样，Lua中的while循环先测试条件，如果条件为真，就执行循环体，否则结束循环：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 0</span><br><span class="line">while a &lt; 10 do</span><br><span class="line">    print(a)</span><br><span class="line">    a = a + 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><ul><li>Lua中repeat-until语句会重复执行循环体至条件为真时结束：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 0</span><br><span class="line">repeat</span><br><span class="line">    print(a)</span><br><span class="line">    a = a + 1</span><br><span class="line">until a &gt; 10</span><br></pre></td></tr></table></figure></li></ul><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><ul><li>Lua的for循环有两种形式：</li></ul><ol><li>数字型for</li><li>泛型for</li></ol><h4 id="数字型："><a href="#数字型：" class="headerlink" title="数字型："></a>数字型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i = 1, 10, 2 do</span><br><span class="line">    print(i)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>含义为，i从1变化到10，每次变化以2作为步长递增并执行循环体。 其中步长是可选的，若不指定，则步长默认为1  </p></blockquote><h4 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">days = &#123;&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;&#125;</span><br><span class="line">for i,v in ipairs(days) do </span><br><span class="line">    print(i, v) </span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>泛型for循环通过一个迭代器函数来遍历所有的值，在Lua中，提供了ipairs这个用于便利数组的迭代器函数。每次循环，i会被赋予一个索引值，v会被赋予一个对应该索引值的数组元素值。<br>泛型for循环的功能非常强大，可以通过不同的迭代器来遍历所有东西。如：<br>迭代文件中的每行（io.lines）、迭代table元素（pairs）、迭代数组元素（ipairs）、迭代字符串中的字符（string.gmatch）等。当然，还可以自己编写迭代器。  </p></blockquote><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><ul><li>break语句用于结束一个循环，它只会跳出包含它的内部循环，而不会改变外部循环。<br>例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = 0</span><br><span class="line">while a &lt; 10 do</span><br><span class="line">    a = a + 1</span><br><span class="line">    if a &gt; 5 then</span><br><span class="line">        break</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    print(a)</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="function"><a href="#function" class="headerlink" title="function"></a><strong>function</strong></h2><ul><li>在Lua中，函数作为“一等对象”。这表示函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。这种特性使语言具有极大的灵活性。</li><li>Lua对函数式编程也提供了良好的支持。</li><li>Lua既可以调用自身的Lua编写的函数，也可以调用c编写的函数。</li><li>函数的定义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function SumTowNum(num1 , num2)</span><br><span class="line">    return num1 + num2</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(SumTowNum(10, 11))</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>输出：<br><code>21</code></p></blockquote><ul><li>Lua函数可以返回多个结果值，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function maximum (a)</span><br><span class="line">    local mi = 1             -- 最大值索引</span><br><span class="line">    local m = a[mi]          -- 最大值</span><br><span class="line">    for i,val in ipairs(a) do</span><br><span class="line">       if val &gt; m then</span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       end</span><br><span class="line">    end</span><br><span class="line">    return m, mi</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(maximum(&#123;8,10,23,12,5&#125;))</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>输出:<br><code>23  3</code></p></blockquote><ul><li>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 <strong>…</strong>表示函数有可变的参数。</li></ul><hr><h2 id="table表"><a href="#table表" class="headerlink" title="table表"></a><strong>table表</strong></h2><ul><li>Lua table 实现了关联数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。</li><li><p>Lua table 是不固定大小的，你可以根据自己需要进行扩容。</p><blockquote><p>table是Lua中主要的（事实上也是仅有的）数据结构机制，具有强大的功能，基于table，可以以一种简单、统一和高效的方式来表示普通数组、符号表、集合、记录、队列及其他数据结构。同时Lua也是通过table来表示模块、包和对象的  </p></blockquote></li><li><p>可以将table想象成一种动态分配的对象，程序仅持有一个对它的引用（或指针）。</p></li><li><p>table的创建是通过构造表达式完成的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--创建table</span><br><span class="line">a = &#123;&#125;</span><br><span class="line">b = &apos;x&apos;</span><br><span class="line">a.b = 10 -- key = &apos;x&apos;. value = 10</span><br></pre></td></tr></table></figure></li><li><p>tabel永远是匿名的，一个持有table的变量和table自身之间没有固定的关联性。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Lua" scheme="http://gyunch.org/categories/Lua/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Lua简介</title>
    <link href="http://gyunch.org/2016/07/03/Lua%E7%AE%80%E4%BB%8B/"/>
    <id>http://gyunch.org/2016/07/03/Lua简介/</id>
    <published>2016-07-02T16:00:00.000Z</published>
    <updated>2018-05-17T10:19:52.541Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><p>Lua是可扩展的轻量级编程语言，它是用C语言编写的，并于1993年开始作为一个内部项目开始诞生。Lua代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。一个完整的Lua解释器不过200k，在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。<br>它从一开始就设计为可以与用C语言编写等常规语言的代码集成软件。这种整合带来了很多好处。它不会尝试做C已经可以做东西，但旨在提供那些C是不好的：从测试和调试的硬件，动态结构，没有冗余，松藕合。对于这一点，lua有一个安全的环境，自动内存管理，以及处理字符串和其他类型的动态尺寸数据良好的设计。</p><hr><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h2><p>Lua提供了一组独特的功能，使得它与其他语言不同。这些包括：</p><ul><li>扩展</li><li>简单</li><li>高效</li><li>便携</li><li>免费和开源</li></ul><blockquote><p>示例代码:<br><code>print(&quot;Hello World!&quot;)</code></p></blockquote><hr><h2 id="Lua如何实现"><a href="#Lua如何实现" class="headerlink" title="Lua如何实现"></a><strong>Lua如何实现</strong></h2><p>Lua中包括的部件为Lua解释部分和运行软件系统。该软件系统功能是一个实际的计算机应用程序，它可以解释写在Lua的编程语言程序。 Lua解释是用ANSI C编写，因此它是非常便携，可以从高端网络服务器，以及小型设备设备上运行。<br>Lua语言解释器非常成熟，体积小，速度快。它已经从其他编程语言和上层软件的标准演变而来的。作为小型程序可以在低内存小的设备上运行。</p><hr><h2 id="Lua相关用途"><a href="#Lua相关用途" class="headerlink" title="Lua相关用途"></a><strong>Lua相关用途</strong></h2><ul><li>游戏编程</li><li>脚本中的独立应用程序</li><li>网页脚本</li><li>扩展和插件像MySQL代理和MySQL数据库的工作台</li><li>安全系统，如入侵检测系统</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Lua" scheme="http://gyunch.org/categories/Lua/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器</title>
    <link href="http://gyunch.org/2016/06/25/python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://gyunch.org/2016/06/25/python装饰器/</id>
    <published>2016-06-24T16:00:00.000Z</published>
    <updated>2018-05-17T10:22:39.685Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="装饰器介绍"><a href="#装饰器介绍" class="headerlink" title="装饰器介绍"></a><strong>装饰器介绍</strong></h2><blockquote><p>Python装饰器是程序开发中经常使用到的功能，熟练掌握装饰器会让你的编程思路更加广阔  </p></blockquote><p>要理解装饰器，首先要先理解：</p><ol><li>在 Python 中“函数是一等对象” 。即函数是一种特殊类型的变量，可以和其余变量一样，可以作为参数传递给函数，也可以作为返回值返回。Python 中的整数、字符串和字典等都是一等对象。</li><li>函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。</li></ol><hr><h2 id="装饰器实现"><a href="#装饰器实现" class="headerlink" title="装饰器实现"></a><strong>装饰器实现</strong></h2><p>装饰器本质上是python函数，它可以使其他函数在不需要做代码变动的情况下增加新的功能，装饰器返回值也是一个函数对象。</p><blockquote><p>以下是一个简单的例子：<br>假设现在有一个函数sayHi，用来输出一句话</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def sayHi():</span><br><span class="line">    print(&apos;Hello, World&apos;)</span><br><span class="line">s = sayHi</span><br><span class="line">s()</span><br></pre></td></tr></table></figure><blockquote><p>输出：<code>Hello, World</code>  </p></blockquote><p>我想希望在不修改sayHi函数的情况下在其之前再输出一句话,这种在代码运行期间动态增加功能的方式，称之为“装饰器”。<br>本质上，装饰器就是一个返回函数的<a href="http://gyunch.org/2016/10/27/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">高阶函数</a></p><blockquote><p>我们可以这么写：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def sayName(func):</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;I&apos;m Yu&quot;)</span><br><span class="line">        return func</span><br><span class="line">    return inner()</span><br><span class="line"></span><br><span class="line">def sayHi():</span><br><span class="line">    print(&apos;Hello, World&apos;)</span><br><span class="line">s = sayName(sayHi)</span><br><span class="line">s()</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Yu</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure></p></blockquote><p>但代码美中不足的是，我们每次给sayHi增加功能都需要用到类似<code>s = sayName(sayHi)</code>这句话。<br>python为了简化这种情况，提供了一个语法糖“@”。</p><blockquote><p>简化上边的代码:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def sayName(func):</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;I&apos;m Yu&quot;)</span><br><span class="line">        return func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@sayName</span><br><span class="line">def sayHi():</span><br><span class="line">    print(&apos;Hello, World&apos;)</span><br><span class="line"></span><br><span class="line">sayHi()</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Yu</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="装饰器原理"><a href="#装饰器原理" class="headerlink" title="装饰器原理"></a><strong>装饰器原理</strong></h2><p>以上代码中，首先，在装饰器函数sayName中，sayName需要接受一个参数func，在其内部又定义了一个inner函数，在inner函数中增加一句输出，并返回func对象，然后sayName函数返回内部函数inner，其实就是一个闭包函数。<br>接下来在sayHi上边增加一个@sayName，其意义就是在python解释器之行到此处时，会调用装饰器函数（sayName），并把被装饰得函数（sayHi）作为参数传入。此时的sayHi已经不是未加装饰时的函数了，而是指向sayName.inner函数地址。在接下来调用sayHi()时，其实就是调用sayName.inner。</p><hr><h2 id="有参函数装饰"><a href="#有参函数装饰" class="headerlink" title="有参函数装饰"></a><strong>有参函数装饰</strong></h2><p>之前的例子是对无参函数的装饰，如果装饰带参数的函数该如何处理？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def sayName(func):</span><br><span class="line">    def inner(name):</span><br><span class="line">        print(&quot;I&apos;m Yu&quot;)</span><br><span class="line">        return func(name)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@sayName</span><br><span class="line">def sayHi(name):</span><br><span class="line">    print(&apos;Hi,&apos; + name)</span><br><span class="line"></span><br><span class="line">sayHi(&apos;siri&apos;)</span><br></pre></td></tr></table></figure></p><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Yu</span><br><span class="line">Hi,siri</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="两个装饰器装饰函数"><a href="#两个装饰器装饰函数" class="headerlink" title="两个装饰器装饰函数"></a><strong>两个装饰器装饰函数</strong></h2><p>这里测试两个装饰器装饰一个函数的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def sayName(func):</span><br><span class="line">    print(&apos;name&apos;)</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;I&apos;m Yu&quot;)</span><br><span class="line">        return func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">def sayAge(func):</span><br><span class="line">    print(&apos;age&apos;)</span><br><span class="line">    def inner():</span><br><span class="line">        print(&quot;i&apos;m 30&quot;)</span><br><span class="line">        return  func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@sayName</span><br><span class="line">@sayAge</span><br><span class="line">def sayHi():</span><br><span class="line">    print(&apos;Hello, World&apos;)</span><br><span class="line"></span><br><span class="line">sayHi()</span><br></pre></td></tr></table></figure></p><blockquote><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age</span><br><span class="line">name</span><br><span class="line">I&apos;m Yu</span><br><span class="line">i&apos;m 30</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure></p></blockquote><p>接下来分析输出这个结果的原因：<br>首先，python解释器执行到第一个装饰器@sayName，在接下来发现装饰器下边不是一个函数而是另一个装饰器，解释器会执行第二个的装饰器@sayAge，然后把sayHi函数传入装饰器，所以首先输出了“age”，当@sayAge装饰完成，此时的sayHi函数地址指向了sayAge.inner的地址，解释器会返回去执行@sayName装饰器来装饰新的sayHi，从而输出了“name”，接着函数当前指向sayName.inner会先输出“I’m Yu”，在这里返回的func()其实就是返回的sayAge.inner，所以在下面输出i’m 30，最后输出原本sayHi的“Hello, World”</p><hr><h2 id="有参装饰器"><a href="#有参装饰器" class="headerlink" title="有参装饰器"></a><strong>有参装饰器</strong></h2><p>下边是装饰器带参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def now(time):</span><br><span class="line">    def sayName(func):</span><br><span class="line">        def inner(name):</span><br><span class="line">            print(&apos;现在是: %s&apos; % time)</span><br><span class="line">            print(&quot;I&apos;m Yu&quot;)</span><br><span class="line">            return func(name)</span><br><span class="line">        return inner</span><br><span class="line">    return sayName</span><br><span class="line"></span><br><span class="line">@now(&apos;2016/10/30&apos;)</span><br><span class="line">def sayHi(name):</span><br><span class="line">    print(&apos;Hello,&apos; + name)</span><br><span class="line"></span><br><span class="line">sayHi(&apos;siri&apos;)</span><br></pre></td></tr></table></figure></p><blockquote><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在是: 2016/10/30</span><br><span class="line">I&apos;m Yu</span><br><span class="line">Hello,siri</span><br></pre></td></tr></table></figure></p></blockquote><hr><h3 id="以上就是python装饰器的相关介绍"><a href="#以上就是python装饰器的相关介绍" class="headerlink" title="以上就是python装饰器的相关介绍"></a><strong>以上就是python装饰器的相关介绍</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="设计模式" scheme="http://gyunch.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python函数式编程</title>
    <link href="http://gyunch.org/2016/06/17/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://gyunch.org/2016/06/17/python函数式编程/</id>
    <published>2016-06-16T16:00:00.000Z</published>
    <updated>2018-05-17T10:19:58.603Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a><strong>函数式编程</strong></h2><p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p><p>函数式编程Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。函数式编程就是一种抽象程度很高的编程范式。<br>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。<br>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。<br>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1freb7yyae5j30jm07pwf0.jpg" alt=" "><br>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。<br>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！<br>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言</p><hr><h2 id="函数式编程的优点"><a href="#函数式编程的优点" class="headerlink" title="函数式编程的优点"></a><strong>函数式编程的优点</strong></h2><ol><li><strong>逻辑可证</strong> <blockquote><p>这是一个学术上的优点：没有”边界效应”使得更容易从逻辑上证明程序是正确的。  </p></blockquote></li></ol><ul><li>边界效应是指在进行程序设计时，我们的编程思想、算法以及分析测试的数据有可能会接近我们所没有注意的边界。所有的操作设计都会有一个边界，例如整形数据的内存，很多情况下在进行程序设计时，往往会被我们所忽略</li></ul><ol start="2"><li><p><strong>模块化</strong> </p><blockquote><p>函数式编程推崇简单原则，一个函数只做一件事情，将大的功能拆分成尽可能小的模块。小的函数更易于阅读和检查错误。  </p></blockquote></li><li><p><strong>组件化</strong> </p><blockquote><p>小的函数更容易加以组合形成新的功能。  </p></blockquote></li><li><p><strong>易于调试</strong> </p><blockquote><p>细化的、定义清晰的函数使得调试更加简单。当程序不正常运行时，每一个函数都是检查数据是否正确的接口，能更快速地排除没有问题的代码，定位到出现问题的地方。  </p></blockquote></li><li><p><strong>易于测试</strong> </p><blockquote><p>不依赖于系统状态的函数无须在测试前构造测试桩，使得编写单元测试更加容易。  </p></blockquote></li><li><p><strong>更高的生产率</strong> </p><blockquote><p>函数式编程产生的代码比其他技术更少（往往是其他技术的一半左右），并且更容易阅读和维护。  </p></blockquote></li></ol><hr><h2 id="函数式编程的特征"><a href="#函数式编程的特征" class="headerlink" title="函数式编程的特征"></a><strong>函数式编程的特征</strong></h2><p>在支持函数式编程的语言中，大量使用如下特征的代码即可被认为是函数式：</p><ol><li><p><strong>函数是一等公民</strong></p><blockquote><p>函数能作为参数传递，或者是作为返回值返回。  </p></blockquote></li><li><p><strong>匿名函数(lambda)</strong></p><blockquote><p>lambda提供了快速编写简单函数的能力  </p></blockquote></li><li><p><strong>闭包</strong></p><blockquote><p>闭包引用了外层函数的变量，然后返回内层函数  </p></blockquote></li><li><p><strong>内置的不可变数据结构</strong></p><blockquote><p>如python中的元组  </p></blockquote></li><li><p><strong>内置模板函数</strong><br>::见下文中的高阶函数::</p></li><li><p>递归</p></li></ol><hr><h2 id="匿名函数-lambda"><a href="#匿名函数-lambda" class="headerlink" title="匿名函数(lambda)"></a><strong>匿名函数(lambda)</strong></h2><p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = lambda x: x+x</span><br><span class="line">print(p(10)</span><br></pre></td></tr></table></figure></p><p>其等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test(x):</span><br><span class="line">    return x+x</span><br><span class="line">p = test(10)</span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure></p><ul><li>这里我建议尽量避免使用lambda。lambda功能十分有限，只能有一个表达式，返回值就是该表达式的结果。最主要是语句过于复杂，lambda表达式会很难阅读</li></ul><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a><strong>高阶函数</strong></h2><ul><li>能接收函数做参数的函数:</li><li>变量可以指向函数</li><li>函数的参数可以接收变量</li><li><p>一个函数可以接收另一个函数作为参数<br>如：python内置函数，map()函数、reduce()函数、filter()函数等</p><blockquote><p>Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数  </p></blockquote></li><li><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test(x, y, z):</span><br><span class="line">    return z(x, y)</span><br><span class="line">print(test(2, 3, pow)) </span><br><span class="line">这里x，y是两个数值，z是一个函数</span><br></pre></td></tr></table></figure></li></ul><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a><strong>偏函数</strong></h2><p>Python的functools模块提供了很多有用的功能，偏函数是其中之一，偏函数把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br>如int()函数，其提供了base参数，默认值为10。如果传入base参数，就可以做进制的转换<br><code>int(&#39;101010&#39;, base=2)</code><br>如果经常需要做二进制转换我们就可以自己定义一个int2()函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def int2(x, base=2):</span><br><span class="line">    return int(x, base)</span><br></pre></td></tr></table></figure></p><p>这里如果我们使用functools.partial，就可以非常方便的直接创建一个int2()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line">int2 = partial(int, base=2)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="Functional" scheme="http://gyunch.org/tags/Functional/"/>
    
  </entry>
  
  <entry>
    <title>C#</title>
    <link href="http://gyunch.org/2016/05/01/C#%E7%AE%80%E4%BB%8B/"/>
    <id>http://gyunch.org/2016/05/01/C#简介/</id>
    <published>2016-04-30T16:00:00.000Z</published>
    <updated>2018-05-17T10:24:43.192Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><ul><li>C# 是一种面向对象的语言。不仅如此，C# 还进一步支持面向组件的编程。 当代软件设计越来越依赖采用自描述的独立功能包形式的软件组件。 此类组件的关键特征包括：为编程模型提供属性、方法和事件；包含提供组件声明性信息的特性；包含自己的文档。 C# 提供了语言构造来直接支持这些概念，让 C# 成为一种非常自然的语言，可用于创建和使用软件组件。</li><li>多项 C# 功能有助于构造可靠耐用的应用程序：垃圾回收可自动回收无法访问的未使用对象占用的内存；异常处理提供了一种结构化的可扩展方法来执行错误检测和恢复；C# 语言的类型安全设计禁止读取未初始化的变量、为范围之外的数组编制索引或执行未检查的类型转换。</li><li>C# 采用统一的类型系统。 所有 C# 类型（包括 int 和 double 等基元类型）均继承自一个根 object 类型。 因此，所有类型共用一组通用运算，任何类型的值都可以一致地进行存储、传输和处理。 此外，C# 还支持用户定义的引用类型和值类型，从而支持对象动态分配以及轻量级结构的内嵌式存储。<br>为了确保 C# 程序和库能够随着时间的推移以兼容的方式发展，C# 设计更强调版本控制。 许多编程语言很少关注这个问题，因此，当引入新版依赖库时，用这些语言编写的程序会出现更多不必要的中断现象。 由于更强调版本控制，直接受影响的 C# 设计方面包括单独的 virtual 和 override 修饰符、关于方法重载决策的规则，以及对显式接口成员声明的支持。</li><li>C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。<br>下面列出了 C# 成为一种广泛应用的专业语言的原因：<br>现代的、通用的编程语言。<br>面向对象。<br>面向组件。<br>容易学习。<br>结构化语言。<br>它产生高效率的程序。<br>它可以在多种计算机平台上编译。<br>.Net 框架的一部分。<br>C# 强大的编程功能<br>虽然 C# 的构想十分接近于传统高级语言 C 和 C++，是一门面向对象的编程语言，但是它与 Java 非常相似，有许多强大的编程功能，因此得到广大程序员的青睐。<br>下面列出 C# 一些重要的功能：<br>布尔条件（Boolean Conditions）<br>自动垃圾回收（Automatic Garbage Collection）<br>标准库（Standard Library）<br>组件版本（Assembly Versioning）<br>属性（Properties）和事件（Events）<br>委托（Delegates）和事件管理（Events Management）<br>易于使用的泛型（Generics）<br>索引器（Indexers）<br>条件编译（Conditional Compilation）<br>简单的多线程（Multithreading）<br>LINQ 和 Lambda 表达式<br>集成 Windows<br>详细指南可参考msdn，.net官方指南</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="C#" scheme="http://gyunch.org/categories/C/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Web渗透测试</title>
    <link href="http://gyunch.org/2016/04/20/Web%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    <id>http://gyunch.org/2016/04/20/Web渗透测试/</id>
    <published>2016-04-19T16:00:00.000Z</published>
    <updated>2018-05-24T03:45:08.161Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a><strong>渗透测试流程</strong></h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1frma0a4ur7j30ju0lt40g.jpg" alt=" "></p><hr><h2 id="渗透测试执行标准"><a href="#渗透测试执行标准" class="headerlink" title="渗透测试执行标准"></a><strong>渗透测试执行标准</strong></h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1frma22s4uaj30p055oh22.jpg" alt=" "></p><hr><h2 id="具体技术点"><a href="#具体技术点" class="headerlink" title="具体技术点"></a><strong>具体技术点</strong></h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1frma3ji8maj30yg1wuthq.jpg" alt=" "></p><hr><h2 id="渗透的艺术"><a href="#渗透的艺术" class="headerlink" title="渗透的艺术"></a><strong>渗透的艺术</strong></h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1frma3ji8maj30yg1wuthq.jpg" alt=" "></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="安全" scheme="http://gyunch.org/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="渗透" scheme="http://gyunch.org/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python面向对象</title>
    <link href="http://gyunch.org/2016/04/01/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://gyunch.org/2016/04/01/Python面向对象/</id>
    <published>2016-03-31T16:00:00.000Z</published>
    <updated>2018-05-17T10:20:15.881Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="面向对象的编程"><a href="#面向对象的编程" class="headerlink" title="面向对象的编程"></a><strong>面向对象的编程</strong></h2><p>类与对象是面向对象编程的两个主要方面。一个类能够创建一种新的类型 ，其中对象就是类的实例。可以这样来类比:你可以拥有类型 int 的变量，也就是说存储整数的变量是 int 类的实例。 </p><blockquote><p>即使是整数也会被视为对象。这不同于 C++ 与c#，在它们那儿整数是原始内置类型  </p></blockquote><ul><li><strong>在Python中，一切皆为对象</strong>。 </li></ul><p>对象可以使用属于它的普通变量来存储数据。这种从属于对象或类的变量叫作字段 。对象还可以使用属于类的函数来实现某些功能，这种函数叫作类的方法 。这两个术语很重要，它有助于我们区分函数与变量，哪些是独立的，哪些又是属于类或对象的。总之，字段与方法通称类的属性。<br>字段有两种类型——它们属于某一类的各个实例或对象，或是从属于某一类本身。它们被分别称作实例变量与类变量。 </p><hr><h2 id="self"><a href="#self" class="headerlink" title="self"></a><strong>self</strong></h2><p>类方法与普通函数只有一种特定的区别——前者必须有一个额外的名字，这个名字必须添加到参数列表的开头，但是你不用在你调用这个功能时为这个参数赋值，Python 会为它提供。 这种特定的变量引用的是对象本身，按照惯例，它被赋􏰀 self 这一名称。 </p><blockquote><p>Python 中的 self 相当于 C++ 中的指针以及 Java 与 C# 中的 this 指针。  </p></blockquote><hr><h2 id="类"><a href="#类" class="headerlink" title="类"></a><strong>类</strong></h2><p>这是一个最简单的类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person:  </span><br><span class="line">    pass   # 空的代码块  </span><br><span class="line">p = Person()  # 创建Person的对象p</span><br></pre></td></tr></table></figure></p><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h2><p>一个简单的方法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person:  </span><br><span class="line">     def sayHi(self):  </span><br><span class="line">     print(‘Hello, World’)  </span><br><span class="line">p = Person()  </span><br><span class="line">p.sayHi()</span><br></pre></td></tr></table></figure><ul><li>输出:  <code>Hello, World</code> </li></ul><blockquote><p>唯一与函数不同的地方在于这里多了一个self  </p></blockquote><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><p>面向对象编程的一大优点是对代码的重用，重用的一种实现方法就是通过继承机制。继承指的是根据一个现有的类型，定义一个修改版本的新类的能力。继承最好是想象成在类之间实现类型与子类型关系的工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class SchoolMember: &apos;&apos;&apos;代表任何学校里的成员。&apos;&apos;&apos;</span><br><span class="line">def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        print(&apos;(Initialized SchoolMember: &#123;&#125;)&apos;.format(self.name))</span><br><span class="line">def tell(self):</span><br><span class="line">&apos;&apos;&apos;告诉我有关我的细节。&apos;&apos;&apos;</span><br><span class="line">print(&apos;Name:&quot;&#123;&#125;&quot; Age:&quot;&#123;&#125;&quot;&apos;.format(self.name, self.age), end=&quot; &quot;)</span><br><span class="line">class Teacher(SchoolMember): &apos;&apos;&apos;代表一位老师。&apos;&apos;&apos;</span><br><span class="line">def __init__(self, name, age, salary):</span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.salary = salary</span><br><span class="line">        print(&apos;(Initialized Teacher: &#123;&#125;)&apos;.format(self.name))</span><br><span class="line">    def tell(self):</span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        print(&apos;Salary: &quot;&#123;:d&#125;&quot;&apos;.format(self.salary))</span><br><span class="line">class Student(SchoolMember): &apos;&apos;&apos;代表一位学生。&apos;&apos;&apos;</span><br><span class="line">def __init__(self, name, age, marks):</span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.marks = marks</span><br><span class="line">        print(&apos;(Initialized Student: &#123;&#125;)&apos;.format(self.name))</span><br><span class="line">    def tell(self):</span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        print(&apos;Marks: &quot;&#123;:d&#125;&quot;&apos;.format(self.marks))</span><br><span class="line">t = Teacher(&apos;Mrs. Shrividya&apos;, 40, 30000)</span><br><span class="line">s = Student(&apos;Swaroop&apos;, 25, 75)</span><br><span class="line"># 打印一行空白行 print()</span><br><span class="line">members = [t, s]</span><br><span class="line">for member in members:</span><br><span class="line"># 对全体师生工作 member.tell()</span><br></pre></td></tr></table></figure></p><blockquote><p>有一些特征是他们都具有的，例如姓名、年龄和地址。另外一些特征是他们独有的，一如教师的薪水、课程与假期，学生的成绩和学费。你可以为每一种类型创建两个独立的类，并对它们进行处理。但增添一条共有特征就意味着将其添加进两个独立的类。这很快就会使程序变得笨重。<br>一个更好的方法是创建一个公共类叫作 SchoolMember ，然后让教师和学生从这个类中继承 ，也就是说他们将成为这一类型(类)的子类型，而我们就可以向这些子类型中添加某些该类独有的特征。<br>这种方法有诸多优点。如果我们增加或修改了 SchoolMember 的任何功能，它将自动反映在子类型中。举个例子，你可以通过简单地向 SchoolMember 类进行操作，来为所有老师与学生添加一条新的 ID 卡字段。不过，对某一子类型作出的改动并不会影响到其它子类型。另一大优点是你可以将某一老师或学生对象看作 SchoolMember 的对象并加以引用，这在某些情况下会大为有用，例如清点学校中的成员数量。这被称作多态性(Polymorphism)，在任何情 况下，如果父类型希望，子类型都可以被替换，也就是说，该对象可以被看作父类的实例。<br>同时还需要注意的是我们重用父类的代码，但我们不需要再其它类中重复它们，当我们使用独立类型时才会必要地重复这些代码。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="OOP" scheme="http://gyunch.org/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构</title>
    <link href="http://gyunch.org/2016/04/01/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://gyunch.org/2016/04/01/Python数据结构/</id>
    <published>2016-03-31T16:00:00.000Z</published>
    <updated>2018-05-18T10:44:19.644Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h2><p><strong>字符串</strong>是字符的序列，可以使用单引号、双引号及三引号来指定字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;etnly&apos;   </span><br><span class="line">name = &quot;etnly&quot;   </span><br><span class="line"># 两者工作机制完全相同   </span><br><span class="line">&apos;&apos;&apos;这是一个多行字符串   </span><br><span class="line">这是第二行   </span><br><span class="line">这位是第三行&apos;&apos;&apos;</span><br></pre></td></tr></table></figure></p><blockquote><p>在程序中使用的所有字符串都是str类下的对象，并且它也具有自己的方法，具体的方法清单可以查阅   help(str)   。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> # 返回字符串长度</span><br><span class="line">name = &apos;etnly&apos;</span><br><span class="line">len(name)</span><br><span class="line"> # 遍历字符串</span><br><span class="line">name = &apos;etnly&apos;</span><br><span class="line">for i in name:</span><br><span class="line">    print(i)</span><br><span class="line"> # 字符串切片</span><br><span class="line">print(name[1:3])</span><br><span class="line"> # 输出 tn</span><br></pre></td></tr></table></figure><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h2><p><strong>列表</strong>是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序列。和字符串类似，在字符串中这些项目是字符，而列表中它可以是任何类型，列表中的值称为<em>元素</em>。</p><ul><li>创建列表最简单的方式是使用 [] 方括号：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = [1, 2, 3]   </span><br><span class="line">name = [&apos;张三&apos;, &apos;李四&apos;]   </span><br><span class="line">other = [[1, 2, 3], &apos;a&apos;, &apos;b&apos; 3.0]</span><br></pre></td></tr></table></figure><blockquote><p>字符串的值是不可变的，而列表的值是可变的。如：   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num[1] = 3   </span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure><ul><li>输出：<br><code>[1, 3, 3]</code>  </li></ul><blockquote><p>列表对象也有自己的方法，具体可以查阅   help(list)   。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> # 列表遍历</span><br><span class="line">num = [1, 2, 3]</span><br><span class="line">for i in num:</span><br><span class="line">    print(i)</span><br><span class="line"> # 列表拼接</span><br><span class="line">num2 = [2, 3, 4]</span><br><span class="line">num3 = num + num2</span><br><span class="line"> # 列表切片</span><br><span class="line">print(num3[1:3])</span><br><span class="line"> # 这里输出 [2, 3]</span><br><span class="line"> # 添加元素</span><br><span class="line">num.append(4)</span><br></pre></td></tr></table></figure><hr><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a><strong>字典</strong></h2><p>字典类似于列表，但更加通用，在列表中下表必须是整数，而字典中，下标基本可以是任意类型。</p><p>字典包含键（下标）和值。每一个键都关联一个值，这种方式称为键值对，字典体现了键到值的映射，所以可以说每一个键映射到一个值。</p><ul><li><p>新建一个字典可以：</p><p> <code>d = {&#39;a&#39; : 1, &#39;b&#39; : 2, &#39;c&#39; : 3}</code><br> <code>d = dict() # 新建一个空字典</code></p></li></ul><blockquote><p>字典是通过散列表的方式实现的，意味着键必须是可散列的。<br>散列是一个函数，接收值并返回一个整数，字典使用这些被称为散列值的整数来保存和查找键值对。  </p></blockquote><hr><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a><strong>元组</strong></h2><p>元组用于将多个对象保存到一起，其值可以是任何类型，并按照下标索引，元组和列表非常相似，其二者主要区别在于，元组是不可变的。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值。</p><ul><li><p>元组语法上用逗号分隔一列值，可以用括号括起来：</p><p> <code>t = &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2</code><br> <code>t = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2)</code></p></li></ul><blockquote><p>用括号括起来单独的值如   t = (‘a’)   并不是元组，如要新建元组可以使用内置函数tuple  </p></blockquote><p><code>t = tuple()</code></p><blockquote><p>严格的来说函数只能返回一个值，但如果返回的是元组，就可以达到类似返回多个值的效果。  </p></blockquote><h3 id="元组、列表和字典"><a href="#元组、列表和字典" class="headerlink" title="元组、列表和字典"></a><strong>元组、列表和字典</strong></h3><h4 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h4><p>zip函数，接收两个或多个序列，并返回一个元组列表，每个元组包含来自每个序列的一个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;abc&apos;   </span><br><span class="line">b = [0, 1, 2]   </span><br><span class="line">print(zip(a, b))</span><br></pre></td></tr></table></figure><ul><li>结果返回   <code>&lt;zip object at 0x10d5e1b08&gt;</code>  </li></ul><blockquote><p>这是一个zip对象，它知道如何遍历每个元素对，zip对象是一种迭代器，即用来迭代访问一个序列的对象  </p></blockquote><p>使用zip最常见的方法是在for循环中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in zip(a, b):   </span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p><ul><li>输出：<code>(&#39;a&#39;, 0) (&#39;b&#39;, 1) (&#39;c&#39;, 2)</code></li></ul><p>如果需要使用列表的操作，可以利用zip对象制作一个列表：<br> <code>list(zip(a, b))</code></p><h4 id="字典和元组"><a href="#字典和元组" class="headerlink" title="字典和元组"></a>字典和元组</h4><p>字典方法items可以返回一个元组序列，其中每个元组是一个键值对：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;0 : &apos;a&apos;, 1 : &apos;b&apos;, 2 : &apos;c&apos;&#125;   </span><br><span class="line">t = d.items()   </span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure></p><ul><li>输出：  <code>dict_items([(0, &#39;a&#39;), (1, &#39;b&#39;), (2, ‘c’)])</code></li></ul><p>反过来可以使用元组列表来初始化一个字典：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = [(0, &apos;a&apos;), (1, &apos;b&apos;), (2, ‘c’)]   </span><br><span class="line">d = dict(t)</span><br></pre></td></tr></table></figure></p><ul><li><p>我们可以通过dict和items得到一个简洁的创建新字典的方法：</p><p><code>d = dict(zip(&#39;abc&#39;, range(3)))</code> </p></li></ul><hr><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a><strong>序列</strong></h2><p>列表、元组和字符串可以看作序列(Sequence)的某种表现形式，序列的主要功能是资格测试(也就是 in 与 not in 表达式)和索引操作，它们能够允许我们直接获取序列中的特定项目。</p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h2><p>当你创建了一个对象并将其分配给某个变量时，变量只会查阅某个对象，并且它也 不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部分。这叫作将名称绑定给那一个对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="数据结构" scheme="http://gyunch.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Python基础(2)</title>
    <link href="http://gyunch.org/2016/03/30/Python%E5%9F%BA%E7%A1%80(2)/"/>
    <id>http://gyunch.org/2016/03/30/Python基础(2)/</id>
    <published>2016-03-29T16:00:00.000Z</published>
    <updated>2018-05-17T10:20:10.744Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><p><strong>函数</strong>是指可重复使用的程序片段。它们允许你为某个代码块赋􏰀名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用函数。</p><ul><li>函数可以通过关键字 def 来定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def say():   </span><br><span class="line">    print(&apos;Hello, World&apos;)   </span><br><span class="line">say()</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h3><p>函数可以获取参数，这个参数的值由你所提供，借此，函数便可以利用这些值来做一些事情。这些参数与变量类似，这些变量的值在我们调用函数时已被定义，且在函数运行时均已赋值完成。在定义函数 时给定的名称称作“形参”，在调用函数时你所提供给函数的值称作“实参”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def reaArea(a, b):   </span><br><span class="line">    s = a * b   </span><br><span class="line">    return s   </span><br><span class="line">x = 10   </span><br><span class="line">y = 5   </span><br><span class="line">print(reaArea(x, y))</span><br></pre></td></tr></table></figure></p><blockquote><p>以上为计算机型面积的函数，调用reaArea函数时，我们以变量作为实参来调用函数，使得x的值赋给行参a、y的值赋给行参b，并返回两者的乘积。  </p></blockquote><ul><li>函数参数可以设置默认参数值，如：<br><code>def reaArea(a , b = 5):</code></li></ul><p>有时可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通 过使用星号来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func(a = 7, *b, **c):   </span><br><span class="line">    print(&apos;a&apos;, a)   </span><br><span class="line">    for i in b:   </span><br><span class="line">        print(&apos;b&apos;, i)   </span><br><span class="line">    for key, value in c.items():   </span><br><span class="line">        print(key, value)   </span><br><span class="line">func(10, 9, 8, 7, 6, 5, x = 1, y = 2, z = 3)</span><br></pre></td></tr></table></figure><ul><li>输出：<br><code>a 10   b 9   b 8   b 7   b 6   b 5   x 1   y 2   z 3</code></li></ul><blockquote><p>当声明一个如*a 星号参数时，从此处开始直到结束的所有位置参数都将被收集并汇集成一个元组。<br>类似地，当声明一个诸如 **b 的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个字典。  </p></blockquote><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a><strong>局部变量</strong></h3><p>在一个函数的定义中声明变量时，它们不会以任何方式与处于函数之外但具有相同名称的变量产生关系，也就是说，这些变量名只存在于函数这一局部。这被称为变量的作用域。所有变量的作用域是它们被定义的块，从定义它们的名字的定义点开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = 7   </span><br><span class="line">def func(n):   </span><br><span class="line">    print(&quot;1:&quot;, n)   </span><br><span class="line">    n = 10   </span><br><span class="line">    print(&quot;2:&quot;, n)   </span><br><span class="line">func(n)   </span><br><span class="line">print(&quot;3:&quot;, n)</span><br></pre></td></tr></table></figure></p><ul><li>输出：<br><code>1: 7     2: 10     3: 7</code></li></ul><blockquote><p>第一次打印出存在于函数块第一行名为 n 的值时，使用的是在函数声明之上的主代码块中声明的这一参数的值。<br>接着，将10赋值给n。n是我们这一函数的局部变量。因此，当改变函数中n的值的时候，主代码块中的n则不会受到影响。<br>最后一句 print 语句，打印出主代码块中定义的n的值，由此确认它不受先前调用的函数中的局部变量的影响。  </p></blockquote><h3 id="global语句"><a href="#global语句" class="headerlink" title="global语句"></a><strong>global语句</strong></h3><p>如果想给一个在程序顶层的变量赋值(也就是说它不存在于任何作用域中，无论是函数还是类)，那么你必须告诉程序这一变量并非局部的，而是全局的。我们需要通过global语句来完成这件事。因为在不使用global语句的情况下，不可能为一个定义于函数之外的变量赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = 7   </span><br><span class="line">def func():   </span><br><span class="line">    global n   </span><br><span class="line">    print(&quot;1:&quot;, n)   </span><br><span class="line">    n = 10   </span><br><span class="line">    print(&quot;2:&quot;, n)   </span><br><span class="line">func()   </span><br><span class="line">print(&quot;3:&quot;, n)</span><br></pre></td></tr></table></figure><ul><li>输出：<br> <code>1: 7     2: 10     3: 10</code></li></ul><blockquote><p>global语句用以声明n是一个全局变量，因此，当我们在函数中为n进行赋值时，这一改动将影响到我们在主代码块中使用的n的值  </p></blockquote><h3 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a><strong>return 语句</strong></h3><p> return 语句用于从函数中返回，也就是中断函数。我们也可以选择在中断函数时从函数中返回一个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def reaArea(a, b):   </span><br><span class="line">    s = a * b   </span><br><span class="line">    return s   </span><br><span class="line">x = 10   </span><br><span class="line">y = 5   </span><br><span class="line">print(reaArea(x, y))</span><br></pre></td></tr></table></figure></p><blockquote><p>如果 return 语句没有搭配任何一个值则代表着返回 None 。 None 在 Python 中一个特殊的类型，代表空。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python基础(1)</title>
    <link href="http://gyunch.org/2016/03/27/Python%E5%9F%BA%E7%A1%80(1)/"/>
    <id>http://gyunch.org/2016/03/27/Python基础(1)/</id>
    <published>2016-03-26T16:00:00.000Z</published>
    <updated>2018-05-17T10:20:05.689Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a><strong>赋值</strong></h2><p><strong>赋值语句</strong>可以创建新的变量，并为其赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">say = &apos;Hello, World&apos;</span><br><span class="line">num = 7</span><br></pre></td></tr></table></figure></p><blockquote><p>第一个语句将<strong>字符串</strong>赋给“say”变量；第二个语句将17赋给num。  </p></blockquote><hr><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a><strong>表达式</strong></h2><p><strong>表达式</strong>是变量、值、操作符的组合，单独的值与变量也被看作一个表达式</p><hr><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a><strong>语句</strong></h2><p><strong>语句</strong>是一段可以产生效果的代码单元，如创建一个变量或显示一个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">say = &apos;Hello, World&apos;</span><br><span class="line">print(say)</span><br></pre></td></tr></table></figure><blockquote><p>print语句显示say的值  </p></blockquote><hr><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><p>Python中注释以“#”开头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这里是注释 </span><br><span class="line">say = &apos;Hello, World&apos; </span><br><span class="line">print(say) # 输出say的值</span><br></pre></td></tr></table></figure></p><blockquote><p>如上所示，注释可以单独占一行，也可以加入到代码结尾。  </p></blockquote><hr><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a><strong>控制流</strong></h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><strong>if语句</strong></h3><p><strong>if语句</strong>用以检查条件:如果 条件为真(True)，我们将运行一块语句(if 块)，否则 我们将运行另一块语句(else 块)。else 从句是可选 的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = 7 </span><br><span class="line">if num &gt; 0: </span><br><span class="line">   print(&apos;num为正数&apos;) </span><br><span class="line">elif num == 0: </span><br><span class="line">   print(&apos;num等于0&apos;) </span><br><span class="line">else: </span><br><span class="line">   print(&apos;num为负数&apos;)</span><br></pre></td></tr></table></figure></p><ul><li>此处输出：<br><code>num为正数</code></li></ul><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a><strong>for语句</strong></h3><p>for…in 语句是循环语句的一种，其特点是会在一系列对象上进行迭代，意即它会遍历序列中的每一个项目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, 10): </span><br><span class="line"> print(i) </span><br><span class="line">else: </span><br><span class="line">   print(&apos;循环结束&apos;)</span><br></pre></td></tr></table></figure></p><ul><li>此处输出：<br><code>1 2 3 4 5 6 7 8 9 循环结束</code></li></ul><blockquote><p>for 循环就会在(1-9)这一范围内展开递归—— for i in range(1,10) 等价于 for i in [1，2，3， 4，5，6，7，8，9] ，这个操作将依次将队列里的每个数字(或是对象)分配给 i ，一次一个，然后以 每个 i 的值执行语句块<br>else 部分是可选的。当循环中包含他时，它总会在 for 循环结束后开始执 行，除非程序遇到了 break 语句。  </p></blockquote><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a><strong>while语句</strong></h3><p>while 语句能够让你在条件为真的前提下重复执行某块语句。 while 语句也是 一种循环语句。 while 语句同样可以拥有 else 子句作为可选选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num = 7 </span><br><span class="line">isRun = True </span><br><span class="line">whileisRun: </span><br><span class="line">  if num == 0: </span><br><span class="line">   isRun = False </span><br><span class="line">   else: </span><br><span class="line">   num = num - 1 </span><br><span class="line">else: </span><br><span class="line">   print(num)</span><br></pre></td></tr></table></figure></p><ul><li>此处输出：<br><code>0</code></li></ul><blockquote><p>While会在循环开始前检查变量是否为true，之后再执行相应的 while 块，直到变量为false，循环结束。  </p></blockquote><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a><strong>break语句</strong></h3><p>break 语句用以中断循环语句，也就是中止循环语句的执行，即使循环条件没有变更为 False ，或队列中的项目尚未完全迭代依旧如此。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, 10): </span><br><span class="line">   print(i)  </span><br><span class="line">   if i == 3: </span><br><span class="line">   break </span><br><span class="line">else: </span><br><span class="line">   print(&apos;循环结束&apos;)</span><br></pre></td></tr></table></figure></p><ul><li>此处输出：<br><code>1 2 3</code></li></ul><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a><strong>continue语句</strong></h3><p>continue 语句用以告诉 Python 跳过当前循环块中的剩余语句，并继续该循环的下一次迭代。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while True: </span><br><span class="line">    s = input(&apos;请输入名字&apos;) </span><br><span class="line">    if s == &apos;yu&apos;: </span><br><span class="line">        break </span><br><span class="line">    if len(s) &lt; 2: </span><br><span class="line">        print(&apos;请输入至少两个字符&apos;) </span><br><span class="line">        continue </span><br><span class="line">    print(&apos;名字为&apos;, s)</span><br></pre></td></tr></table></figure></p><blockquote><p>此处接收用户输入的内容，只有字符串长度大于等于2程序才会对其进行处理。如果其长度小 于 2，便通过使用 continue 语句跳过代码块中的其余语句。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyunch.org/categories/Python/"/>
    
    
      <category term="基础" scheme="http://gyunch.org/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>反汇编基础(不同语言的反汇编入口)</title>
    <link href="http://gyunch.org/2015/10/01/%E5%8F%8D%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%8D%E6%B1%87%E7%BC%96%E5%85%A5%E5%8F%A3)/"/>
    <id>http://gyunch.org/2015/10/01/反汇编基础(不同语言的反汇编入口)/</id>
    <published>2015-09-30T16:00:00.000Z</published>
    <updated>2018-05-24T03:45:10.388Z</updated>
    
    <content type="html"><![CDATA[<p>🤔</p><hr><a id="more"></a><ul><li>在我们反汇编时，第一步（这里不考虑脱壳的情况，脱壳会在之后介绍）就是要找代码的入口函数。</li><li>一般使用OD打开工程时，并不会直接跳转到程序入口，而是先执行一系列的初始化工作，这些初始化工作通常是我们不需要关心的，所以我们需要先跳出这些函数，直接找到程序入口。<blockquote><p>如何找到入口时反汇编最基础的操作，因为太简单，过程不做赘述，下边是我总结的几种语言的入口特征：<br>c++  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00401B70 &gt;/$  55           PUSH EBP                                 </span><br><span class="line">00401B71  |.  8BEC         MOV EBP,ESP</span><br><span class="line">00401B73  |.  6A FF        PUSH -1</span><br><span class="line">00401B75  |.  68 08254000  PUSH crackme.00402508</span><br><span class="line">00401B7A  |.  68 F61C4000  PUSH &lt;JMP.&amp;MSVCRT._except_handler3&gt;      </span><br><span class="line">00401B7F  |.  64:A1 0000000  MOV EAX,DWORD PTR FS:[0]</span><br><span class="line">00401B85  |.  50              PUSH EAX</span><br><span class="line">00401B86  |.  64:8925 00000   MOV DWORD PTR FS:[0],ESP</span><br><span class="line">00401B8D  |.  83EC 68         SUB ESP,68</span><br><span class="line">00401B90  |.  53              PUSH EBX</span><br><span class="line">00401B91  |.  56              PUSH ESI</span><br><span class="line">00401B92  |.  57              PUSH EDI</span><br><span class="line">00401B93  |.  8965 E8         MOV [LOCAL.6],ESP</span><br><span class="line">00401B96  |.  33DB            XOR EBX,EBX</span><br><span class="line">00401B98  |.  895D FC         MOV [LOCAL.1],EBX</span><br><span class="line">00401B9B  |.  6A 02           PUSH 2</span><br><span class="line">00401B9D  |.  FF15 98214000  CALL DWORD PTR DS:[&lt;&amp;MSVCRT.__set_app_ty&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00401025 &gt;/$  6A F6          PUSH -0A                                </span><br><span class="line">00401027  |.  E8 A0000000    CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt;        </span><br><span class="line">0040102C  |.  A3 00304000    MOV DWORD PTR DS:[403000],EAX</span><br><span class="line">00401031  |.  6A F5          PUSH -0B                                </span><br><span class="line">00401033  |.  E8 94000000    CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt;       </span><br><span class="line">00401038  |.  A3 04304000    MOV DWORD PTR DS:[403004],EAX</span><br><span class="line">0040103D  |.  6A 01          PUSH 1                                   </span><br><span class="line">0040103F  |.  68 00104000    PUSH EchoLine.00401000                   </span><br><span class="line">00401044  |.  E8 8F000000    CALL &lt;JMP.&amp;kernel32.SetConsoleCtrlHandle&gt;</span><br><span class="line">00401049  |.  6A 07          PUSH 7                                   </span><br><span class="line">0040104B  |.  FF35 00304000 PUSH DWORD PTR DS:[403000]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Delphi<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0045D408 &gt; $  55             push ebp</span><br><span class="line">0045D409   .  8BEC           mov ebp,esp</span><br><span class="line">0045D40B   .  83C4 F0        add esp,-0x10</span><br><span class="line">0045D40E   .  B8 28D24500    mov eax,DELPHI.0045D228</span><br><span class="line">0045D413   .  E8 6088FAFF    call DELPHI.00405C78</span><br><span class="line">0045D418   .  A1 4CF14500    mov eax,dword ptr ds:[0x45F14C]</span><br><span class="line">0045D41D   .  8B00           mov eax,dword ptr ds:[eax]</span><br><span class="line">0045D41F   .  E8 08DFFFFF    call DELPHI.0045B32C</span><br><span class="line">0045D424   .  8B0D 40F24500  mov ecx,dword ptr ds:[0x45F240] </span><br><span class="line">0045D42A   .  A1 4CF14500    mov eax,dword ptr ds:[0x45F14C]</span><br><span class="line">0045D42F   .  8B00           mov eax,dword ptr ds:[eax]</span><br><span class="line">0045D431   .  8B15 CCC84500  mov edx,dword ptr ds:[0x45C8CC] </span><br><span class="line">0045D437   .  E8 08DFFFFF    call DELPHI.0045B344</span><br><span class="line">0045D43C   .  A1 4CF14500    mov eax,dword ptr ds:[0x45F14C]</span><br><span class="line">0045D441   .  8B00           mov eax,dword ptr ds:[eax]</span><br><span class="line">0045D443   .  E8 7CDFFFFF    call DELPHI.0045B3C4</span><br><span class="line">0045D448   .  E8 2769FAFF    call DELPHI.00403D74</span><br><span class="line">0045D44D   .  8D40 00        lea eax,dword ptr ds:[eax]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>易语言<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">004464D1 &gt;/$  55            push ebp</span><br><span class="line">004464D2  |.  8BEC          mov ebp,esp</span><br><span class="line">004464D4  |.  6A FF         push -0x1</span><br><span class="line">004464D6  |.  68 B0C14600   push 易语言.0046C1B0</span><br><span class="line">004464DB  |.  68 DCAC4400   push 易语言.0044ACDC  </span><br><span class="line">004464E0  |.  64:A1 0000000&gt;mov eax,dword ptr fs:[0]</span><br><span class="line">004464E6  |.  50            push eax</span><br><span class="line">004464E7  |.  64:8925 00000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">004464EE  |.  83EC 58       sub esp,0x58</span><br><span class="line">004464F1  |.  53            push ebx</span><br><span class="line">004464F2  |.  56            push esi</span><br><span class="line">004464F3  |.  57            push edi       ;  ntdll.7C930228</span><br><span class="line">004464F4  |.  8965 E8       mov [local.6],esp</span><br><span class="line">004464F7  |.  FF15 98514600 call dword ptr ds:[&lt;&amp;KERNEL32.GetVersion&gt;;  kernel32.GetVersion</span><br><span class="line">004464FD  |.  33D2          xor edx,edx</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>vb<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">004013EC &gt; $  68 A4244000   PUSH Crack.004024A4</span><br><span class="line">004013F1   .  E8 F0FFFFFF      CALL &lt;JMP.&amp;MSVBVM60.ThunRTMain&gt;</span><br><span class="line">004013F6   .  0000                ADD BYTE PTR DS:[EAX],AL</span><br><span class="line">004013F8   .  0000                ADD BYTE PTR DS:[EAX],AL</span><br><span class="line">004013FA   .  0000                ADD BYTE PTR DS:[EAX],AL</span><br><span class="line">004013FC   .  3000                XOR BYTE PTR DS:[EAX],AL</span><br><span class="line">004013FE   .  0000                ADD BYTE PTR DS:[EAX],AL</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🤔&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="安全" scheme="http://gyunch.org/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="逆向" scheme="http://gyunch.org/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Hello,world</title>
    <link href="http://gyunch.org/2015/07/23/Hello,World/"/>
    <id>http://gyunch.org/2015/07/23/Hello,World/</id>
    <published>2015-07-22T16:00:00.000Z</published>
    <updated>2018-05-24T05:40:57.099Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="One"><a href="#One" class="headerlink" title="One"></a><strong>One</strong></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;One&quot;&gt;&lt;a href=&quot;#One&quot; class=&quot;headerlink&quot; title=&quot;One&quot;&gt;&lt;/a&gt;&lt;strong&gt;One&lt;/strong&gt;&lt;/h1&gt;
      
    
    </summary>
    
      <category term="介绍" scheme="http://gyunch.org/categories/%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="Yu" scheme="http://gyunch.org/tags/Yu/"/>
    
  </entry>
  
</feed>
