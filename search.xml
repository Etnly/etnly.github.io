<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[区块链]]></title>
    <url>%2F2018%2F01%2F30%2F%E5%8C%BA%E5%9D%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[🤔 什么是区块链 区块链源起比特币，但并不局限在币圈。区块链技术是储存、验证和数据保护等问题的实际解决办法。区块链可被视为分散的、极度安全的数据库。更专业一点来说，区块链是分布式的点对点的基于密码学的共享账本，可以在金融服务、保险、医疗、政府等领域内被广泛应用。 理解区块链，首先需要明确的是，区块链是一套协议和规范，用英文表述就是 Protocol，不是具体的代码或者项目。理解了这套协议，你可以基于不同的语言和技术去实现它，这和我们平时定义了一套 API，然后基于不同的技术实现没有什么分别。 但是区块链在不同领域的人眼里，可能是不同的东西。角度不同，我们得出的结论也不一样。金融领域的人会认为区块链是个分布式的账本，是一个分布式的去中心化的记账系统。搞安全和密码学的人会说区块链是基于密码学构建的对等网络。而我们程序员了解了区块链技术，会认为这不就是一个保证最终一致性的分布式数据库嘛。 记账系统对于普通人来说，记账系统最容易理解，我们从账本说起。比如大家一起做生意，总要有个账本，最初这个账本由账房先生管理。但一个人管，总会出现对账不平衡的情况（比如挪用），于是大家开始轮流管。这种方式也有问题，在某个人保管账本和记账期间，一旦发生了数据丢失或账本损坏的情况，也会搞不清真实原因。最后大家决定用一种新的记账方式，每个人一个自己的账本，任何人改动了自己的账本都要告诉其他所有人，其他人也会在自己的账本记上一笔。只要有人发现新的账目不对，可以拒绝接受。最后以大多数人一致的账目为准。这就是分布式的去中心化的记账系统。但这种做法时间长了还是会有问题，有人天天记，有人偷懒不记，会产生不公平。于是大家决定每天早上掷骰子，根据点数决定谁来记当天的账，其他人核对一下，没问题就复制过来。并且，当天的记账者会获得一点点奖励（这就是挖矿）。 去中心化的分布式数据库把上面的记账系统用软件技术实现了，就是去中心化的分布式数据库。什么是中心化，早期互联网大都采用 CS 架构，一个服务器 N 个客户端，Client 和 Server 之间进行通讯，系统可靠性严重依赖 Server，这叫中性化。随着业务复杂度的增加，服务器端也开始分拆，横向和纵向扩展，读写分离等等，这就是我们常用的分布式架构系统，系统可靠性依赖分布式系统的热备份和容灾恢复能力。这时候服务器虽然分布了，但依然是中性化的。大部分商业公司都采用类似的架构和模式。去中心化是怎么回事呢？就是数据库不属于任何机构和管理员。只要服务器端被某个机构或管理员控制，就存在宕机或数据篡改的风险。区块链和 P2P 的网络通信技术最终实现了去中心化。区块链的作用就是存储信息，可以认为是一个数据库，而任何人都可以通过 P2P 网络架设服务器，接入区块链网络，成为一个节点。这下人人平等了，大家都是 Server，也就没有了 Server，每个节点既是生产者也是消费者。你可以向任何一个节点读写数据，一旦写入就是历史，最后所有的节点都会同步数据，保证「账本」的一致性。区块链是没有管理员的，也不需要人工审核和干涉。那人人都能写数据，数据的可信度怎么保证呢？数据被篡改了咋办？别担心，P2P 网络只是进行信息通讯，保证数据安全的还有共识算法和加密算法。 共识算法关于共识算法、拜占庭将军问题，大家可以参考这一篇文章，很长，但容易看懂。分布式一致性与共识算法（https://draveness.me/consensus）简单来说，共识算法就是保证少数服从多数，也就是我在记账系统中写过的「最后以大多数人一致的账目为准」。大多数人认可的事情，就是事实。这种规则听起来挺吓人的，比如我们常常在文学作品和历史经验中知道，真理往往掌握在少数人手里。但是在 P2P 的网络里，有无数的节点，要想大部分节点一起作恶，除非这些节点都被某个组织控制了。这种可能性虽然不是没有，但几率非常小。总的来说，共识算法解决的是对某个提案（Proposal）达成一致意见的过程。提案的含义在分布式系统中十分宽泛，包括多个事件发生的顺序、某个键对应的值…等等，可以认为任何需要达成一致的信息都是一个提案。有了共识算法和相关的加密算法，就可以保证数据的安全性和一致性。 为什么会挖矿？谈到比特币，大家耳熟能详的就是挖矿和矿机这种事。那为什么会挖矿呢？挖矿其实是一种激励和竞争机制。在区块链系统中，总有些节点被选中进行数据整理、验证、打包，并把相关的改动广播出去，这个工作还是挺耗资源的，所以会有奖励机制。负责打包的节点会获得系统的奖励，类似积分，对于比特币系统来说，就是奖励比特币。有了奖励，很多节点都希望获得这样的奖励，于是有些区块链系统，比如比特币就会设计出一种竞争机制，让各个节点凭借自己的算力和资源去抢，能抢到这个数据打包的机会，就会获得奖励，也就是比特币。这个竞争的过程就是挖矿。什么是算力呢？就是计算机每秒产生 hash 碰撞的能力。也就是说，手里的矿机每秒能做多少次 hash 碰撞。算力越高，获得的奖励越多。 区块链的未来很多人觉得区块链的唯一应用就是发行虚拟货币，最近国内外市场也是烽烟四起，比如超过百年历史的伊士曼柯达公司宣布推出基于区块链技术的「柯达币」（KodakCoin）和 KodakOne 平台，让全球的摄影师能够更好的控制图片的版权和交易。然后股价就飙升了……了解了区块链的技术特点，我们就知道，区块链的能力远不止虚拟货币领域，未来的 金融服务、物流、保险、医疗、共享经济、智能合约领域，应该都会有区块链的身影。繁华落尽，洗尽铅华，所有的技术都将经历时间的洗礼。历经爆发期、衰退期并进入成熟期的技术，才是真正能具备生命力的技术。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuaFramework]]></title>
    <url>%2F2017%2F09%2F13%2FLuaFramework%2F</url>
    <content type="text"><![CDATA[🤔 LuaFramework是基于UGUI+tolua的简单游戏框架tolua作者:蒙哥，LuaFramework作者:骏擎想了解更多luaframework相关，可以关注博客uLua/cstoluatolua技术群:286510803 , tolua技术讨论群:434341400(已满) 543826216此文档更新于 2018/5/1 ，这里讲的部分方法是所对应的最新版本 LuaFramework热更新流程 Main脚本调用启动函数Startup； 游戏管理器GameManager生成； GameManager调用CheckExtractResource函数，检查“数据目录”是否存在； 若“数据目录”不存在，说明是初次运行游戏，将“游戏包资源目录”的内容解压缩到“数据目录”； 若“数据目录”存在，检查是否需要从服务器下载资源，GameManager调用OnUpdateResource函数下载“网络资源地址”上的files.txt，然后与“数据目录”中文件的md5码做对比，更新有变化的文件； 更新完成后，GameManager调用OnResourceInited函数，启动Lua状态机，游戏开始。 调试：在Main.lua加入调试语句，在LuaManager的StartMain访问热更新增的Lua脚本，生成新打包的Prefab AppConst类的UpdateMode设为true，则从指定服务器下载资源，否则从本地“数据目录”获取。LuaBundleMode设为true，则从AssetBundle解压Lua脚本，否则直接读取项目脚本。可以打开AssetsLuaFrameworkEditorCustomSettings.cs看到所有可以供lua调用的类 添加新的Lua脚本到AssetBundle包 将Lua脚本存放到 Assets/LuaFramework/Lua 目录,因为，当按下LuaFramework-Build XXX Resources的时候，框架会自动将Assets/LuaFramework/Lua下的所有内容打成AssetBundle包，放在StreamingAssets下，可以发现，StreamingAssets文件夹下会有个Lua文件夹，里面放的就是Assets/LuaFramework/Lua在打包之后的结果 主要注意以下几点 1：打开StreamingAssets/Lua，会发现，这个文件夹下大致分为两部分，3rd文件夹，和一堆资源包其中，资源包的命名特点是对应路径信息的，例如lua_3rd_cjson和lua_3rd_cjson.unity3d这一组资源包,他对应着的是LuaFramework/Lua/3rd/cjson里面的Lua文件，这组资源包就是这个文件夹下的lua文件打包出来的结果。 2：StreamingAssets/Lua文件夹下，除了资源包外，还有一个3rd文件夹，可以打开Assets/LuaFramework/Lua/3rd 目录，然后打开其中一个，例如cjson的文件夹，可以发现，这文件夹里除了一些lua文件，还有一些txt配置文件或说明文件，所以，这个StreamingAssets/Lua/3rd文件夹下，放的就是这些lua文件外的文件资源 3：综上所述，如果我们要打包一个自定义的Lua文件（不是框架提供的Main.lua文件）的话，那么我们完全可以先在Assets/LuaFramework/Lua这个文件夹下，自定义一个专门存放我们编写的Lua文件的文件夹，当打包出来后，会发现，StreamingAssets/Lua下会有一个自定义的文件夹名.unity3d的一组资源包。 4：更改Lua入口，不用框架提供给我们的Main.lua这个文件：找到LuaManger这个类，然后找到StartMain()这个方法，只需要把lua.DoFile里面的参数修改为你自定义的lua文件名，然后LuaFunction main=lua.GetFunction(“Main”)这一行的括号内的参数，修改为作为入口且存在于你自定义的lua文件中的lua方法即可。不管是不是自己定义lua入口文件，最好都放在Assets/LuaFramework/Lua下，不要再另外加文件夹，因为放在Assets/LuaFramework/Lua路径下的所有lua文件都会直接一同打包在lua.unity3d资源包中，而程序设置好就是去这个包里读取lua的入口文件，除非你会改动lua入口文件的读取路径。 5：可以读取多个lua文件: 创建新的AssetBundle包 LuaFramework/Build XXX Resources 的功能全都写在了Assets/LuaFramework/Editor/Packager.cs，这个类中，以及跟随打包生成的 StreamingAssets/files 这个MD5校验码文件是如何生成，也是写在这个Packager.cs 文件中，所以，如果想打包一些此框架没提供的平台资源，可以到这个Packager 模仿增加对应的打包方法 打包函数的主体代码是 Packager.cs 中的 BuildAssetResource ， HandleExampleBundle ， AddBuildMap ， HandleLuaBundle ， HandleLuaFile 这五个方法 BuildAssetResource进行资源文件夹刷新，并且根据AppConst类里静态布尔属性设置情况的不同，分别调用HandleExampleBundle ， HandleLuaBundle ， HandleLuaFile 函数 HandleExampleBundle 作用是告诉使用者如何打包美术素材，框架格式是什么，如果有打包的美术资源，可以根据这个格式自定义一个方法，来进行打包，AddBuildMap 方法里第一个参数：打包出来的资源名字，这个名字是用 AppConst.ExtName （值为 unity3D ）作为后缀名。第二个参数：要打包的资源原本的格式， *.XXX 代表所有这种格式的资源。第三个参数：次框架是对指定路径的文件夹进行整体打包操作的，所以，第三个参数是你要打包的资源位于项目哪个文件夹中 所以综上所述，如果你要打包美术资源，先在项目中创建一个专门存放你自己的美术资源的文件夹，然后在 Packager.cs 中新建一个函数，里面的代码复制HandleExampleBundle，然后修改 AddBuildMap 参数，在完成上述步骤后，因为你的项目打包出来之前会删掉框架提供的示例场景，所以要把 AppConst 中的 ExampleMode 设置为 false ，最后在 Packager.cs 加入如图else代码，调用你的自定义打包函数 HandleLuaBundle ， HandleLuaFile 这两个函数是告诉用户如何将 Lua 文件打包成 AssetBundle 的，通常状况下不建议修改，因为功能已经很齐全了，当然，如果你想将这种功能实现应用到如 Xlua 中，可以去查看这两个函数是如何写的。 热更新主要由三部分组成： C# 与 Lua 的互相调用机制 Lua 文件的打包 网络传输，校验XLua ， ToLua ， ULua… 只是提供了 C# 与 Lua 的互相调用机制，并没有提供其余两者的功能实现，所以如果自己想开发个基于如 Xlua 这样的热更新框架，可以参照这个基于 ToLua 的框架 使用框架对下载的资源进行加载 在此之前，你要明白为何这个框架可以让lua脚本访问到C#的类 当你按下Lua/Clear wrap Files 时，会有弹出框，按下确定框架就会自动生成一堆Wrap结尾的文件，这个自动生成的文件所对应的就是一个叫 AppConst 的类，而这个框架就是让 Lua 通过访问这些自动生成的 wrap 的类来达到访问 C#类的目的 接下来就是资源的加载与生成： 在ResourceManager类中，框架提供了三个重载LoadPrefab方法其参数分别是： 要加载的AssetBundle包的名字 需要加载此包中哪些美术素材 回调方法（这个方法的参数列表有一个UnityEngine.Object[]类型的变量的，这个数组变量存的就是你所加载的美术资源） Lua中调用：12345678910111213function Main() print(&quot;logic start&quot;) LuaHelper = LuaFramework.LuaHelper resMgr = LuaHelper.GetResManager resMgr: LoadPrefab(&quot;myprefabs.unity3d&quot;, &#123;&quot;Sphere&quot;, &quot;Cube&quot;&#125;, LoadAssetBundle)endfunction LoadAssetBundle(go) for i = 0, go.Length - 1, 1 do UnityEngine.GameObject.Instantiate(go[i]) --go是userdata类型，遍历的时候必须用Length去取得长度 endend]]></content>
      <categories>
        <category>toLua</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shader入门]]></title>
    <url>%2F2016%2F09%2F07%2FShader%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[🤔 渲染流水线流水线 在了解什么是渲染流水线前先看一下现实生活中的流水线。 流水线是一种工业上的生产方式，每一个生产单位只专注处理一个片段的工作。比如一个制造手机的工厂，一台手机的制造流程可以分为四个步骤，第一步，制作外壳；第二步，制作屏幕模组；第三步，制作主板；第四步组装手机并进行产品包装。在没有流水线时，只有在每台手机四个工序完成后才能开始制作下一台，这是非常耗时的。如果我们加入流水线，虽然制作一台手机任需要四个步骤，但不需要从头到尾完成全部步骤，而是每个步骤由专人来完成，所有步骤并行进行。使用流水线的好处在于可以提高单位时间的生产量。 渲染流水线 流水线的概念同样可以用于计算机的图像渲染中。计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以观察到的图像。这个工作通常有CPU和GPU共同完成 渲染流水线通常分为三个阶段：应用阶段 ———&gt; 几何阶段 ————&gt; 光栅化阶段 应用阶段： 这个阶段有应用主导，通常由CPU负责实现。这一阶段开发者有三个主要任务，首先，需要准备好场景数据（摄相机位置、视锥体、模型和光源等）。其次，为了提高渲染性能，需要做粗粒度的剔除工作。最后，需要设置好每个模型的渲染状态（使用的材质、使用的纹理、使用的Shader等）这一阶段最重要的输出是渲染所需的几何信息，即渲染图元。 几何阶段：几何阶段主要用于处理所有和我们绘制的几何相关的事情。几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作。这个阶段可以进一步分成更小的流水线阶段。几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。 光栅化阶段： 这一阶段会使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。 CPU和GPU之间的通信渲染流水线的起点是CPU，即应用阶段。大致可分为三个阶段： 把数据加载到显存中：所有渲染所需的数据都需要从硬盘中加载到系统内存，然后，网格和纹理等数据又被加载到显存。 设置渲染状态：这些状态定义了场景中的网格如何被渲染。 调用Draw Call：Draw Call实际上就是一个命令，它的发起方是CPU,接收方是GPU，这个命令仅仅会指向一个需要被渲染的图元列表，而不会再包含任何材质信息。 当给定一个Draw Call时，GPU就会根据渲染状态和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的像素。 GPU流水线 当GPU从CPU得到渲染命令后，就会进行一系列的流水线操作，最终把图元渲染到屏幕上（就是上边的调用Draw Call） 对于渲染流水线中的后两个阶段（几何阶段和光栅化阶段）开发者无法拥有绝对的控制权，其实现的载体是GPU。GPU通过实现流水线化，大大加快了渲染速度，虽然我们无法完全控制这两个阶段的实现细节，但其向开发者开放了很多控制权。下图展示了不同流水线阶段以及它们的可配执性和可编程性： 顶点着色器 顶点着色器是流水线的第一个阶段，它的输入来自于CPU。顶点着色器的处理单位是顶点,输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或销毁任何顶点，并无法得到顶点与顶点之间的关系 顶点着色器是完全可编程的，它通常用于实现顶点的坐标变换和逐顶点光照。 坐标变换：就是对顶点的坐标进行某种变换—把顶点坐标从模型空间转换到齐次裁剪空间。我们可以通过坐标变换来模拟水面、面料等。 曲面细分着色器 是一个可选的着色器，主要用于细分图元。 几何着色器 是一个可选的着色器，可用于执行逐图元的着色操作，或者被用于产生更多的图元。 裁剪 这一阶段是可配置的。目的是把那些不在视野内的顶点裁剪掉，并剔除某些三角形图元的面片。 一个图元与摄像机视野的关系有3种：完全在视野内、部分在视野内、完全在视野外。 完全在视野内的图元会继续传递给下一个流水线阶段 完全在视野外的图元不会继续向下传递 部分在视野内的图元需要做裁剪处理 和顶点着色器不同的是，这一步是不可编程的。我们无法通过编程来控制裁剪的过程，而是硬件上的固定操作。 屏幕映射 这一阶段是不可配置和编程的，负责把每个图元的坐标转换成屏幕坐标。 这一步输入的坐标仍然是三维坐标系下的坐标。屏幕映射的任务是把每个图元的x和y坐标转换到屏幕坐标系下。 屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素的距离。 一个需要注意的地方，屏幕坐标系在OpenGL和DirectX中，OpenGL把屏幕左下角当作最小的窗口坐标值，DirectX则在屏幕左上角为最小窗口坐标值。 三角形设置 由这一步开始进入光栅化阶段。 上一阶段输出的信息是屏幕坐标系下的顶点位置以及和它们相关的其他信息，如深度值、法线方向、视角方向等。 光栅化阶段的目标：1.计算每个图元覆盖了哪些像素 2.为这些像素计算它们的颜色 三角形设置作为光栅化的第一个阶段，会计算出光栅化一个三角网格所需要的信息。上一阶段的输出是三角网格的顶点，如果想得到整个三角网格的覆盖情况，就必须计算每条边上的像素坐标，为了计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个得到三角形边界表示方式的过程就是三角形设置。 它的输出是为下一个阶段做准备 三角形遍历 三角形遍历阶段将会检查每个像素是否被一个三角网格所覆盖。如果被覆盖，就会生成一个片元。而这样一个找到哪些像素被三角网格覆盖的过程，就是三角形遍历，这个阶段也被称为扫描变换。 三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角网格覆盖了哪些像素，并使用三角网格三个顶点的顶点信息对整个覆盖区域的像素进行插值。 这一步的输出就是得到一个片元序列。 一个片元并不是真正意义上的像素，而是包含了很多状态的几何，这些状态用于计算每个像素的最终颜色 片元着色器 片元着色器是另一个非常重要的可编程着色器阶段，在DirectX中，片元着色器被称为像素着色器。 片元着色器的输入就是上一阶段对顶点信息插值得到的结果，更具体点说，是根据从顶点着色器中输出的数据插值得到的。而其的输出是一个或者多个颜色值。 这一阶段可以完成很多重要的渲染技术，如纹理采样，但是它的局限在于，它仅可以影响单个片元。 逐片元操作 这是渲染流水线的最后一步，这一步骤的目的是：合并 这一阶段有几个主要任务： 决定每个片元的可见性。这涉及了深度测试、模板测试等 如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说是混合。 这一阶段是高度可配置性的 这个阶段首先需要解决每个片元的可见性问题。这需要进行一系列的测试。 片元 ——&gt; 模版测试 ——&gt; 深度测试 ——&gt; 混合 ——&gt; 颜色缓冲区 深度测试和模版测试的简化流程图： 模板测试：如果开启了模板测试，GPU会首先读取模板缓冲区中该片元位置的模板值，然后将该值和读取到的参考值（可以开发者自己指定）进行比较，开发者可以设定成小于时舍弃或者大于等于时舍弃该片元。模板测试通常用于限制渲染的区域，另外模板测试还有别的高级用法，如渲染阴影，轮廓渲染。 深度测试：如果一个片元幸运的通过了模板测试，那么就会进行深度测试，如果开启了深度深度，GPU就会把该片的深度值和已经存在于深度缓冲区中的深度值进行比较，这个比较函数也是由开发者设定的，可以选择大于此值时舍弃也可以选择小于等于此值时舍弃。但通常这个比较函数是小于等于的关系，这是因为我们我们总想只显示出离摄像机最近的物体，而那些被其他物体遮挡的片元就不需要出现在屏幕上。和模板测试不同的是，如果一个片元没有通过深度测试，他就没有权利修改深度缓冲区中的值。而如果通过了测试，开发者可以通开启/关闭深度写入来决定是否要利用这个片元的深度值覆盖缓冲区中的值。 合并：我们所讨论的渲染过程是一个物体接着一个物体渲染到屏幕上，而每个像素的颜色信息被存储在一个名为颜色缓冲的地方，因此当我们执行这次渲染时，颜色缓冲中往往已经有了上次渲染的颜色结果，那么我们是使用这次渲染得到的颜色完全覆盖掉之前的结果，还是进行其他处理，这就是合并需要解决的问题。对于不透明物体，开发者可以关闭混合操作，这样片元着色器计算得到的颜色值就会直接覆盖掉颜色缓冲区中的像素值。但对于半透明的物体，我们就需要开启混合操作来让这个物体看起来是半透明的。混合操作是高度可配置的，开发者可以选择开启/关闭混合功能。如果开启了，GPU会取出源颜色和目标颜色，将两种颜色进行混合。源颜色是指片元着色器得到的颜色值，而目标颜色则是已经存在于颜色缓冲区中的颜色值。 总结真正实现渲染流水线的过程远比描述的要复杂，但Unity为我们封装了很多功能，我们只需要在一个Unity Shader设置一些输入、编写顶点着色器和片元着色器、设置一些状态，就可以实现大部分屏幕效果。在最新的unity中还集成了Shader蓝图工具供开发者使用。]]></content>
      <categories>
        <category>Shader</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-近邻算法]]></title>
    <url>%2F2016%2F09%2F02%2FK-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[🤔 K-近邻算法概述 简单的说，K-近邻算法采用测量不同特征值之间的距离方法进行分类。 优点：精度高，对异常值不敏感，无数据输入假定。 缺点：计算复杂度高，空间复杂度高。 适用范围：数值型和标称型。 K-近邻算法工作原理存在一个样本数据集合，可以称之为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最邻近数据的分类标签。一般来说我们只选择样本数据集中前k个最相似的数据，这就是K-近邻算法中k的由来，通常k是不大于20的整数。最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类。 下边是K-近邻算法的一个示例： 收集数据：提供文本文件。 准备数据：使用python解析文件。 分析数据：使用Matplotlib画而为扩散图 训练算法： 测试算法：以文件部分数据作为测试样本 使用算法：可以输入特征数据以判断是否正确 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&apos;&apos;&apos;在文件datingTest中存放着某约会网站的样本数据，每个样本占据一行，共1000行。其中主要包括： 每年飞行里程数， 玩游戏所耗时间比， 每周消费的冰淇淋数。&apos;&apos;&apos;from numpy import *import osimport operatorimport matplotlibimport matplotlib.pyplot as pltfrom os import listdirdef file2matrix(filename): &apos;&apos;&apos; 处理输入格式 :param filename: :return: &apos;&apos;&apos; fr = open(filename) numberOfLines = len(fr.readlines()) #得到文件行数 returnMat = zeros((numberOfLines,3)) #创建返回的NumPy矩阵 classLabelVector = [] fr = open(filename) index = 0 for line in fr.readlines(): #解析文件数据到列表 line = line.strip() listFromLine = line.split(&apos;\t&apos;) returnMat[index,:] = listFromLine[0:3] classLabelVector.append(int(listFromLine[-1])) index += 1 return returnMat,classLabelVectordef autoNorm(dataSet): &apos;&apos;&apos; 将每列的最小值放在变量minVals中，最大值放在maxVals中， 其中dataSet.min（0）中的参数0使得函数可以从列中取最小值，而不是选取当前行最小值。 然后函数计算可能的取之范围，并创建新的矩阵返回 :param dataSet: :return: &apos;&apos;&apos; minVals = dataSet.min(0) maxVals = dataSet.max(0) ranges = maxVals - minVals normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] normDataSet = dataSet - tile(minVals, (m, 1)) normDataSet = normDataSet / tile(ranges, (m, 1)) #特征值相除 return normDataSet, ranges, minValsdef classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] #距离计算 diffMat = tile(inX, (dataSetSize,1)) - dataSet sqDiffMat = diffMat**2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 sortedDistIndicies = distances.argsort() classCount=&#123;&#125; for i in range(k): #选择距离最小的k个点 voteIlabel = labels[sortedDistIndicies[i]] classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 #排序 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]def datingClassTest(): &apos;&apos;&apos; 使用file2matrix和autoNorm函数从文件中读取数据并转换为归一化特征值 接着计算测试向量的数量，决定normMat向量中哪些数据用于测试，哪些用于训练样本 然后将两部分数据输入到原始分类起函数classify0， 最后计算错误率并返回 :return: &apos;&apos;&apos; hoRatio = 0.10 datingDataMat, datingLabels = file2matrix(&apos;datingTestSet.txt&apos;) normMat, range, minvals = autoNorm(datingDataMat) m = normMat.shape[0] numTestVecs = int(m*hoRatio) errorCount = 0.0 for i in range(numTestVecs): classifierResult = classify0(normMat[i,:], normMat[numTestVecs:m, :], datingLabels[numTestVecs:m], 3) print(&quot;the classifier came back with : %d, the real answer is : %d&quot; %(classifierResult, datingLabels[i])) if(classifierResult != datingLabels[i]): errorCount += 1.0 print(&quot;the total error rate is : %f&quot; %(errorCount/float(numTestVecs)))datingClassTest()datingDataMat, datingLabels = file2matrix(&apos;datingTestSet2.txt&apos;)fig = plt.figure()ax = fig.add_subplot(111)ax.scatter(datingDataMat[:,1], datingDataMat[:,2])ax.scatter(datingDataMat[:, 1], datingDataMat[:, 2], 15.0*array(datingLabels), 15.0*array(datingLabels))plt.show()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FSM状态机]]></title>
    <url>%2F2016%2F08%2F13%2FFSM%E7%8A%B6%E6%80%81%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[🤔 有限状态机，FSM，简称状态机，是表示有限个 以及在这些状态之间的转移和动作等行为的 在unity中我们经常会判断一个人物（或怪物）的运动状态，如巡逻、追逐、攻击、死亡等，然后作出相应的操作，这些时候我们可以使用有限状态机来集中管理这些状态。 FSM在unity中算是一个比较重要的技巧 以下是我写的一个简单的FSM状态机的例子：FSMState.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106using System.Collections;using System.Collections.Generic;using UnityEngine.SceneManagement;using UnityEngine;public abstract class FSMState &#123; //字典，字典中每一项都记录了一个“转换-状态”对 的信息 protected Dictionary&lt;Transition, FSMStateID&gt; map = new Dictionary&lt;Transition, FSMStateID&gt;(); //状态编号ID protected FSMStateID stateID; public FSMStateID ID &#123; get &#123; return stateID; &#125; &#125; //目标点位置 protected Vector3 destPos; //巡逻点数组 protected Transform[] waypoints; //旋转速度 protected float curRotSpeed; //移动速度 protected float curSpeed; //发现对面的距离 public float chaseDistance&#123; get &#123; if (SceneManager.GetActiveScene ().name == &quot;PTMainScenes&quot;) return 10f; else return 1f;&#125;&#125; //攻击距离 public float SRAttackDistance&#123; get &#123; if (SceneManager.GetActiveScene ().name == &quot;PTMainScenes&quot;) return 1f; else return 0.1f;&#125;&#125; //目标点距离 protected float arriveDistance&#123; get &#123; if (SceneManager.GetActiveScene ().name == &quot;PTMainScenes&quot;) return 2f; else return 0.2f;&#125;&#125; /// &lt;summary&gt; /// 向字典添加项，每项是一个&quot;转换--状态&quot;对 /// &lt;/summary&gt; /// &lt;param name=&quot;transition&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt; public void AddTransition(Transition transition, FSMStateID id) &#123; if (map.ContainsKey(transition)) &#123; return; &#125; map.Add(transition, id); &#125; /// &lt;summary&gt; /// 从字典中删除项 /// &lt;/summary&gt; /// &lt;param name=&quot;trans&quot;&gt;&lt;/param&gt; public void DeleteTransition(Transition trans) &#123; if (map.ContainsKey(trans)) &#123; map.Remove(trans); return; &#125; &#125; /// &lt;summary&gt; /// 通过查询字典，确定在当前状态下，发生trans转换时，应该转换到新的状态编号并返回 /// &lt;/summary&gt; /// &lt;param name=&quot;trans&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public FSMStateID GetOutputState(Transition trans) &#123; return map[trans]; &#125; /// &lt;summary&gt; /// 用来确定是否需要转换到其他状态，应该发生哪个转换 /// &lt;/summary&gt; /// &lt;param name=&quot;player&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;npc&quot;&gt;&lt;/param&gt; public abstract void Reason(Transform hero, Transform monster); /// &lt;summary&gt; /// 定义了在本状态的角色行为，移动，动画等 /// &lt;/summary&gt; /// &lt;param name=&quot;player&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;npc&quot;&gt;&lt;/param&gt; public abstract void Act(Transform hero, Transform monster); public virtual void Enter (Transform hero, Transform monster)&#123; &#125; /// &lt;summary&gt; /// 选择随机逻辑点 /// &lt;/summary&gt; public void FindNextPoint()&#123; int rndIndex = Random.Range (0, waypoints.Length); Vector3 rndPosition = Vector3.zero; destPos = waypoints [rndIndex].position + rndPosition; &#125;&#125; FSM.cs123456789101112131415161718192021222324252627282930313233343536using UnityEngine;using System.Collections;public class FSM : MonoBehaviour&#123; // 玩家位置 protected Transform playerTranform; // 下一个巡逻点 protected Vector3 destPos; // 巡逻点表单 protected GameObject[] pointList; // protected float elapsedTime; protected virtual void Initialize()&#123;&#125; protected virtual void FSMUpdate()&#123;&#125; protected virtual void FSMFixedUpdate()&#123;&#125; // 初始化 void Start()&#123; Initialize (); &#125; //循环执行 void Update()&#123; FSMUpdate (); &#125; void FixedUpdate()&#123; FSMFixedUpdate (); &#125;&#125; AdvancedFSM.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103using System.Collections;using System.Collections.Generic;using UnityEngine;public enum Transition&#123; SawPlayer = 0, //是否看到玩家 ReachPlayer, //接近玩家 LostPlayer, //玩家离开视线 NoHealth, //死亡&#125;public enum FSMStateID&#123; Patrolling = 0, // 巡逻编号 Chasing, // 追踪编号 Attacking, Dead, // 死亡编号&#125;public class AdvancedFSM : FSM&#123; //FSM中的所有状态组成的列表 private List&lt;FSMState&gt; fsmStates; //当前状态的编号 private FSMStateID currentStateID; public FSMStateID CurrentStateID &#123; get &#123; return currentStateID; &#125; &#125; //当前状态 private FSMState currentState; public FSMState CurrentState &#123; get &#123; return currentState; &#125; &#125; public AdvancedFSM() &#123; //新建一个空的状态列表 fsmStates = new List&lt;FSMState&gt;(); &#125; /// &lt;summary&gt; ///向状态列表中加入一个新的状态 /// &lt;/summary&gt; public void AddFSMState(FSMState fsmState) &#123; if (fsmState == null) &#123; Debug.LogError(&quot;状态为空&quot;); return; &#125; if (fsmStates.Count == 0) &#123; fsmStates.Add(fsmState); currentState = fsmState; currentStateID = fsmState.ID; return; &#125; foreach (FSMState state in fsmStates) &#123; if (state.ID == fsmState.ID) &#123; Debug.LogError(&quot;状态已存在&quot;); return; &#125; &#125; //如果要加入的状态不在列表中，将它加入列表 fsmStates.Add(fsmState); &#125; //从状态中删除一个状态 public void DeleteState(FSMStateID fsmState) &#123; // 搜索整个状态列表，如果要删除的状态在列表中，那么将它移除，否则报错 foreach (FSMState state in fsmStates) &#123; if (state.ID == fsmState) &#123; fsmStates.Remove(state); return; &#125; &#125; Debug.LogError(&quot;要删除的状态不在列表中&quot;); &#125; /// &lt;summary&gt; /// 根据当前状态，和参数中传递的转换，转换到新状态 /// &lt;/summary&gt; public void PerformTransition(Transition trans) &#123; FSMStateID id = currentState.GetOutputState(trans); currentStateID = id; foreach (FSMState state in fsmStates) &#123; if (state.ID == currentStateID) &#123; currentState = state; break; &#125; &#125; &#125;&#125; AttackState.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System.Collections;using UnityEngine;public class AttackState : FSMState &#123; Animator monsterAnimator; AnimatorStateInfo stateInfo; public AttackState(Transform[] wp)&#123; waypoints = wp; stateID = FSMStateID.Attacking; curRotSpeed = 12; curSpeed = 100; FindNextPoint (); &#125; public override void Enter (Transform hero, Transform monster) &#123; monsterAnimator = monster.GetComponent&lt;Animator&gt;(); &#125; public override void Reason(Transform hero, Transform monster)&#123; if (hero != null) &#123; stateInfo = monsterAnimator.GetCurrentAnimatorStateInfo (0); float dist = Vector3.Distance (monster.position, hero.position); if (dist &gt;= SRAttackDistance &amp;&amp; dist &lt; chaseDistance) &#123; if (stateInfo.IsName (&quot;skill&quot;) &amp;&amp; stateInfo.normalizedTime % 1 &gt; 0.9f) monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.SawPlayer); &#125; else if (dist &gt;= chaseDistance) &#123; if (stateInfo.IsName (&quot;skill&quot;) &amp;&amp; stateInfo.normalizedTime % 1 &gt; 0.9f) monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer); &#125; &#125;else&#123; monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer); &#125; &#125; public override void Act(Transform hero, Transform monster)&#123; destPos = hero.position; Quaternion targetRotation = Quaternion.LookRotation (destPos - monster.position); monster.rotation = Quaternion.Slerp (monster.rotation, targetRotation, Time.deltaTime * curRotSpeed);// CharacterController controller = monster.GetComponent&lt;CharacterController&gt; ();// controller.SimpleMove (monster.transform.forward * Time.deltaTime * curSpeed); //播放攻击动画// Animator monsterAnimator = monster.GetComponent&lt;Animator&gt;(); monsterAnimator.SetBool (&quot;isRun&quot;,false); monsterAnimator.SetBool (&quot;isAttack&quot;, true); monsterAnimator.SetBool (&quot;isWalk&quot;, false); monsterAnimator.SetBool (&quot;isDead&quot;, false); &#125;&#125; ChaseState.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using System.Collections;using System.Collections.Generic;using UnityEngine.AI;using UnityEngine;using UnityEngine.SceneManagement;public class ChaseState : FSMState &#123; NavMeshAgent monsterAgent; Animator monsterAnimator; public ChaseState(Transform[] wp)&#123; waypoints = wp; stateID = FSMStateID.Chasing; curRotSpeed = 7; curSpeed = 300; FindNextPoint (); &#125; public override void Enter (Transform hero, Transform monster) &#123; monsterAnimator = monster.GetComponent&lt;Animator&gt;(); monsterAgent = monster.GetComponent&lt;NavMeshAgent&gt; (); &#125; public override void Reason(Transform hero, Transform monster)&#123; if (hero != null) &#123; destPos = hero.position; float dist = Vector3.Distance (monster.position, destPos); if (dist &lt;= SRAttackDistance) &#123; AudioManager.Instance.PlayFXAudio (&quot;Sound_MonsterPatrolPlayer&quot;, monster.transform.position); monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.ReachPlayer); &#125; else if (dist &gt;= chaseDistance) &#123; monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer); &#125; &#125;else&#123; monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer); &#125; &#125; public override void Act(Transform hero, Transform monster)&#123; destPos = hero.position; Quaternion targetRotation = Quaternion.LookRotation (destPos - monster.position); monster.rotation = Quaternion.Slerp (monster.rotation, targetRotation, Time.deltaTime * curRotSpeed); monsterAgent.SetDestination (destPos); if(SceneManager.GetActiveScene().name == &quot;PTMainScenes&quot;) monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 2; if (SceneManager.GetActiveScene ().name == &quot;ARMainScenes&quot;) monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 0.2f; //播放奔跑动画 monsterAnimator.SetBool (&quot;isRun&quot;,true); monsterAnimator.SetBool (&quot;isAttack&quot;, false); monsterAnimator.SetBool (&quot;isWalk&quot;, false); monsterAnimator.SetBool (&quot;isDead&quot;, false); &#125;&#125; PatrolState.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using System.Collections;using System.Collections.Generic;using UnityEngine.AI;using UnityEngine;using UnityEngine.SceneManagement;public class PatrolState : FSMState&#123; Animator monsterAnimator; NavMeshAgent monsterAgent; public PatrolState(Transform[] wp)&#123; waypoints = wp; stateID = FSMStateID.Patrolling; curRotSpeed = 6; curSpeed = 200; FindNextPoint (); &#125; public override void Enter (Transform hero, Transform monster) &#123; &#125; public override void Reason(Transform hero, Transform monster)&#123; if (hero != null) &#123; if (Vector3.Distance (monster.position, hero.position) &lt;= chaseDistance) &#123; AudioManager.Instance.PlayFXAudio (&quot;Sound_MonsterSawPlayer&quot;, monster.transform.position); monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.SawPlayer); &#125; &#125; &#125; public override void Act(Transform hero, Transform monster)&#123; monsterAgent = monster.GetComponent&lt;NavMeshAgent&gt; (); if (!(monsterAgent.pathPending || monsterAgent.remainingDistance &gt; (monsterAgent.stoppingDistance + 0.5f) || monsterAgent.velocity != Vector3.zero)) &#123; FindNextPoint (); &#125;// Physics.SphereCastAll ();// Quaternion targetRotation = Quaternion.LookRotation (destPos - monster.position);// monster.rotation = Quaternion.Slerp (monster.rotation, targetRotation, Time.deltaTime * curRotSpeed); monsterAgent.SetDestination (destPos); if(SceneManager.GetActiveScene().name == &quot;PTMainScenes&quot;) monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 1; if (SceneManager.GetActiveScene ().name == &quot;ARMainScenes&quot;) monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 0.1f; //播放行走动画 monsterAnimator = monster.GetComponent&lt;Animator&gt; (); monsterAnimator.SetBool (&quot;isRun&quot;,false); monsterAnimator.SetBool (&quot;isAttack&quot;, false); monsterAnimator.SetBool (&quot;isWalk&quot;, true); monsterAnimator.SetBool (&quot;isDead&quot;, false); &#125;&#125; DeadState.cs12345678910111213141516171819202122232425262728293031323334using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class DeadState : FSMState &#123; public DeadState()&#123; stateID = FSMStateID.Dead; &#125; public override void Enter (Transform hero, Transform monster) &#123; monster.GetComponent&lt;NavMeshAgent&gt; ().enabled = false; monster.GetComponent&lt;Collider&gt; ().enabled = false; GameManager.Instance.AddScore (); &#125; public override void Reason(Transform hero, Transform monster)&#123; &#125; public override void Act (Transform hero, Transform monster)&#123; //播放死亡动画 Animator monsterAnimator = monster.GetComponent&lt;Animator&gt;(); monsterAnimator.SetBool (&quot;isRun&quot;,false); monsterAnimator.SetBool (&quot;isAttack&quot;, false); monsterAnimator.SetBool (&quot;isWalk&quot;, false); monsterAnimator.SetBool (&quot;isDead&quot;, true); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity对象池]]></title>
    <url>%2F2016%2F08%2F10%2Funity%E5%AF%B9%E8%B1%A1%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[🤔 对象池的含义很简单，我们将对象储存在一个“池”中，当需要它时可以重复使用，而不是创建一个新的对象，尽可能的复用内存中已经驻留的资源来减少频繁的IO耗时操作。有经验的开发者在程序设计时就会做一个规范，其中包含了角色池，怪物池，特效池，经验池等。 以下代码中是一个简单的对象池示例，具体的说明在代码注释中呈现： Singleton.cs12345678910111213using UnityEngine;/// &lt;summary&gt;/// 单例模版类/// &lt;/summary&gt;public class Singleton&lt;T&gt; where T : new() &#123; private static readonly T instance = new T(); public static T Instance&#123; get&#123; return instance; &#125; &#125;&#125; MonoSingleton.cs1234567891011121314151617181920212223using UnityEngine;/// &lt;summary&gt;/// 组建单例模版/// &lt;/summary&gt;public class MonoSingleten&lt;T&gt; : MonoBehaviour where T : MonoBehaviour&#123; private static T instance; public static T Instance&#123; get&#123; if (instance == null)&#123; GameObject go = new GameObject(typeof(T).Name); instance = go.AddComponent&lt;T&gt;(); &#125; return instance; &#125; set &#123; instance = value; &#125; &#125; protected virtual void Awake()&#123; Instance = this as T; &#125;&#125; IReusable.cs12345678910using UnityEngine;/// &lt;summary&gt;/// 对象池接口/// &lt;/summary&gt;public interface IReusable&#123; //对象从对象池实例化的回调 void OnSpawned(); //对象返回对象池后的回调 void OnUnSpawned();&#125; PrefabType.cs12345public enum PrefabType&#123; None = 0, Effects = 1, Roles = 2,&#125; ResourcesPath.cs123456789101112131415161718192021using UnityEngine;/// &lt;summary&gt;/// 资源路径/// &lt;/summary&gt;public class ResourcesPath &#123; public const string prefabRoles = &quot;Prefabs/Roles/&quot;; public const string prefabEffects = &quot;Prefabs/Effects/&quot;; public static string GetPath(PrefabType type, string name)&#123; string path = string.Empty; switch(type)&#123; case PrefabType.Effects: path = ResourcesPath.prefabEffects + name; break; case PrefabType.Roles: path = ResourcesPath.prefabRoles + name; break; &#125; return path; &#125;&#125; ResourceFactory.cs12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 资源工厂/// &lt;/summary&gt;public class ResourceFactory : Singleton&lt;ResourceFactory&gt; &#123; /// &lt;summary&gt; /// 加载资源 /// &lt;/summary&gt; /// &lt;returns&gt;The load.&lt;/returns&gt; /// &lt;param name=&quot;path&quot;&gt;Path.&lt;/param&gt; /// &lt;typeparam name=&quot;T&quot;&gt;The 1st type parameter.&lt;/typeparam&gt; public T Load&lt;T&gt;(string path) where T : Object&#123; T res = Resources.Load&lt;T&gt;(path); return res; &#125;&#125; ObjectPoolMananger.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 对象池管理器/// &lt;/summary&gt;public class ObjectPoolMananger : MonoSingleten&lt;ObjectPoolMananger&gt; &#123; private Dictionary&lt;string, ObjectPool&gt; mPools = new Dictionary&lt;string, ObjectPool&gt;(); //从对象池取出对象 public GameObject Spawn(PrefabType type, string name, Vector3 pos = default(Vector3), Quaternion rotation = default(Quaternion), Transform parent = null)&#123; ObjectPool pool = null; if (!mPools.ContainsKey(name))&#123; //创建对象池 RegisterPoll(type, name); &#125; pool = mPools[name]; //从对象池中取出一个物体 GameObject obj = pool.Spawn(); obj.transform.SetParent(parent); obj.transform.localPosition = pos; obj.transform.localRotation = rotation; return obj; &#125; /// &lt;summary&gt; /// 对象池回收物体 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;Object.&lt;/param&gt; public void UnSpawn(GameObject obj)&#123; foreach(ObjectPool pool in mPools.Values)&#123; if (pool.Contains(obj))&#123; pool.UnSpawn(obj); return ; &#125; &#125; Destroy(obj); &#125; /// &lt;summary&gt; /// 回收所有物体 /// &lt;/summary&gt; public void UnSpwanAll()&#123; foreach(ObjectPool pool in mPools.Values)&#123; pool.UnSpawnAll(); &#125; &#125; private void RegisterPoll(PrefabType type, string name)&#123; string path = ResourcesPath.GetPath(type, name); GameObject prefab = ResourceFactory.Instance.Load&lt;GameObject&gt;(path); ObjectPool pool = new ObjectPool(prefab); mPools.Add(name, pool); &#125;&#125; ObjectPool.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 对象池类/// &lt;/summary&gt;public class ObjectPool&#123; //预制体 private GameObject mPrefab; //对象池 private List&lt;GameObject&gt; objectlist = new List&lt;GameObject&gt;(); //构造方法 public ObjectPool(GameObject prefab)&#123; this.mPrefab = prefab; &#125; /// &lt;summary&gt; /// 取出物体 /// &lt;/summary&gt; /// &lt;returns&gt;The spawn.&lt;/returns&gt; public GameObject Spawn()&#123; GameObject obj = null; for (int i = 0; i &lt; objectlist.Count; i++)&#123; if (!objectlist[i].activeSelf)&#123;//如果有物体隐藏 obj = objectlist[i]; break; &#125; &#125; if (obj == null)&#123; obj = GameObject.Instantiate(mPrefab); objectlist.Add(obj); &#125; obj.SetActive(true); //获取对象池接口 IReusable reusable = obj.GetComponent&lt;IReusable&gt;(); if (reusable != null)&#123; reusable.OnSpawned(); &#125; return obj; &#125; /// &lt;summary&gt; /// 回收物体 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;Object.&lt;/param&gt; public void UnSpawn(GameObject obj)&#123; obj.SetActive(false); IReusable reusable = obj.GetComponent&lt;IReusable&gt;(); if (reusable != null)&#123; reusable.OnUnSpawned(); &#125; &#125; public void UnSpawnAll() &#123; foreach (GameObject obj in objectlist)&#123; obj.SetActive(false); IReusable reusable = obj.GetComponent&lt;IReusable&gt;(); if (reusable != null)&#123; reusable.OnUnSpawned(); &#125; &#125; &#125; /// &lt;summary&gt; /// 判断物体是否存在 /// &lt;/summary&gt; /// &lt;returns&gt;The contains.&lt;/returns&gt; /// &lt;param name=&quot;obj&quot;&gt;Object.&lt;/param&gt; public bool Contains(GameObject obj)&#123; return objectlist.Contains(obj); &#125;&#125; DestoryObjectPool.cs1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 对象池销毁/// &lt;/summary&gt;public class DestoryObjectPool : MonoBehaviour, IReusable &#123; public float mDestoryTime = 0.1f; public void OnSpawned() &#123; Invoke(&quot;UnSpawn&quot;, mDestoryTime); &#125; public void OnUnSpawned() &#123; &#125; private void UnSpawn()&#123; ObjectPoolMananger.Instance.UnSpawn(gameObject); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity单例]]></title>
    <url>%2F2016%2F08%2F07%2FUnity%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[🤔 什么是单例 单例模式是开发中运用最广泛的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 其中要注意： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 为什么要使用单例 在我们的整个游戏生命周期当中，有很多对象从始至终有且只有一个。这个唯一的实例只需要生成一次，并且直到游戏结束才需要销毁。 单例模式一般应用于管理器类，或者是一些需要持久化存在的对象。 单例的实现 c#单例的实现(如果在unity中不需要使用monobeheviour，也可以这样来创建单例)：1234567891011121314151617181920public sealed class Singleton &#123; private static volatile Singleton instance; private static object syncRoot = new Object(); public static Singleton Instance &#123; get &#123; if (instance == null) &#123; lock (syncRoot) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125; &#125; &#125; unity需要使用monobeheviour的单例实现：1234567891011121314151617181920212223242526272829public sealed class SingletonMoBehaviour: MonoBehaviour&#123; private static volatile SingletonBehaviour instance; private static object syncRoot = new Object(); public static SingletonBehaviour Instance &#123; get &#123; if (instance == null) &#123; lock (syncRoot) &#123; if (instance == null) &#123; SingletonBehaviour[] instances = FindObjectsOfType&lt;SingletonBehaviour&gt;(); if (instances != null)&#123; for (var i = 0; i &lt; instances.Length; i++) &#123; Destroy(instances[i].gameObject); &#125; &#125; GameObject go = new GameObject(&quot;_SingletonBehaviour&quot;); instance = go.AddComponent&lt;SingletonBehaviour&gt;(); DontDestroyOnLoad(go); &#125; &#125; &#125; return instance; &#125; &#125; &#125; 其中主要区别在于monobeheviour不能使用构造函数进行实例化，只能挂载到GameObject上，而切换场景时当前场景的GameObject都会被销毁，所以单例也会被销毁，这里我们就需要DontDestroyOnLoad处理，同时为了保持场景当中只有一个实例，我们要对当前场景中的单例进行判断，如果存在其他的实例，则应该将其全部删除。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫基础]]></title>
    <url>%2F2016%2F07%2F20%2Fpython%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[🤔 爬虫介绍 爬虫是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本（来自于百度百科）。 爬虫的目的 爬取数据，进行市场调研和商业分析。 作为机器学习、数据挖掘的原始数据 爬取优质的资源 爬虫实现过程 大部分爬虫都是按“发送请求——获得页面——解析页面——抽取并储存内容”这样的流程来进行，这其实也是模拟了我们使用浏览器获取网页信息的过程。 python中的相关包 在python中有很多爬虫可用的包，如：urllib、requests、bs4、scrapy、pyspider 等 简单的爬虫实例 以下是一个简单的python爬虫，爬取前程无忧上成都unity3d的人才需求：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193import osfrom pprint import pprintimport csvfrom collections import Counterfrom bs4 import BeautifulSoupimport requestsimport matplotlib.pyplot as pltimport jiebafrom wordcloud import WordCloudclass JobSpider: def __init__(self): self.company = [] self.text = &quot;&quot; self.headers = &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;,&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos; &#125; def job_spider(self): &quot;&quot;&quot; 爬虫入口 &quot;&quot;&quot; #要抓取的页面 url = &quot;https://search.51job.com/list/090200,000000,0000,00,9,99,Unity3d,2,1.html?lang=c&amp;stype=&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;providesalary=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=&quot; urls = [url.format(p) for p in range(1, 100)] for url in urls: #请求网页 r = requests.get(url, headers=self.headers).content #解析 bs = BeautifulSoup(r, &apos;lxml&apos;).find(&quot;div&quot;, class_=&quot;dw_table&quot;).find_all(&quot;div&quot;, class_=&quot;el&quot;) for b in bs: try: href, post = b.find(&apos;a&apos;)[&apos;href&apos;], b.find(&apos;a&apos;)[&apos;title&apos;] locate = b.find(&apos;span&apos;, class_=&apos;t3&apos;).text salary = b.find(&apos;span&apos;, class_=&apos;t4&apos;).text d = &#123; &apos;href&apos;: href, &apos;post&apos;: post, &apos;locate&apos;: locate, &apos;salary&apos;: salary &#125; self.company.append(d) except Exception: pass def post_require(self): &quot;&quot;&quot; 爬取职位描述 &quot;&quot;&quot; for c in self.company: r = requests.get( c.get(&apos;href&apos;), headers=self.headers).content.decode(&apos;gbk&apos;) bs = BeautifulSoup(r, &apos;lxml&apos;).find( &apos;div&apos;, class_=&quot;bmsg job_msg inbox&quot;).text s = bs.replace(&quot;举报&quot;, &quot;&quot;).replace(&quot;分享&quot;, &quot;&quot;).replace(&quot;\t&quot;, &quot;&quot;).strip() self.text += s print(self.text) with open(os.path.join(&quot;data&quot;, &quot;post_require.txt&quot;), &quot;w+&quot;) as f: f.write(self.text) @staticmethod def post_desc_counter(): &quot;&quot;&quot; 职位描述统计 &quot;&quot;&quot; post = open(os.path.join(&quot;data&quot;, &quot;post_require.txt&quot;), &quot;r&quot;).read() # 使用 jieba 分词 file_path = os.path.join(&quot;data&quot;, &quot;user_dict.txt&quot;) jieba.load_userdict(file_path) seg_list = jieba.cut(post, cut_all=False) counter = dict() for seg in seg_list: counter[seg] = counter.get(seg, 1) + 1 counter_sort = sorted( counter.items(), key=lambda value: value[1], reverse=True) pprint(counter_sort) with open(os.path.join(&quot;data&quot;, &quot;post_pre_desc_counter.csv&quot;), &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.writer(f) f_csv.writerows(counter_sort) def post_counter(self): &quot;&quot;&quot; 职位统计 &quot;&quot;&quot; lst = [c.get(&apos;post&apos;) for c in self.company] counter = Counter(lst) counter_most = counter.most_common() pprint(counter_most) with open(os.path.join(&quot;data&quot;, &quot;post_pre_counter.csv&quot;), &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.writer(f) f_csv.writerows(counter_most) def post_salary_locate(self): &quot;&quot;&quot; 招聘大概信息，职位，薪酬以及工作地点 &quot;&quot;&quot; lst = [] for c in self.company: lst.append((c.get(&apos;salary&apos;), c.get(&apos;post&apos;),c.get(&apos;title&apos;), c.get(&apos;href&apos;), c.get(&apos;locate&apos;))) pprint(lst) file_path = os.path.join(&quot;data&quot;, &quot;post_salary_locate.csv&quot;) with open(file_path, &quot;w+&quot;) as f: f_csv = csv.writer(f) f_csv.writerows(lst) @staticmethod def post_salary(): &quot;&quot;&quot; 薪酬统一处理 &quot;&quot;&quot; mouth = [] year = [] thousand = [] with open(os.path.join(&quot;data&quot;, &quot;post_salary_locate.csv&quot;), &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.reader(f) for row in f_csv: if &quot;万/月&quot; in row[0]: mouth.append((row[0][:-3], row[2], row[1])) elif &quot;万/年&quot; in row[0]: year.append((row[0][:-3], row[2], row[1])) elif &quot;千/月&quot; in row[0]: thousand.append((row[0][:-3], row[2], row[1])) # pprint(mouth) calc = [] for m in mouth: s = m[0].split(&quot;-&quot;) calc.append( (round( (float(s[1]) - float(s[0])) * 0.4 + float(s[0]), 1), m[1], m[2])) for y in year: s = y[0].split(&quot;-&quot;) calc.append( (round( ((float(s[1]) - float(s[0])) * 0.4 + float(s[0])) / 12, 1), y[1], y[2])) for t in thousand: s = t[0].split(&quot;-&quot;) calc.append( (round( ((float(s[1]) - float(s[0])) * 0.4 + float(s[0])) / 10, 1), t[1], t[2])) pprint(calc) with open(os.path.join(&quot;data&quot;, &quot;post_salary.csv&quot;), &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.writer(f) f_csv.writerows(calc) @staticmethod def post_salary_counter(): # 薪酬统计 with open(os.path.join(&quot;data&quot;, &quot;post_salary.csv&quot;), &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.reader(f) lst = [row[0] for row in f_csv] counter = Counter(lst).most_common() pprint(counter) with open(os.path.join(&quot;data&quot;, &quot;post_salary_counter1.csv&quot;), &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.writer(f) f_csv.writerows(counter) @staticmethod def world_cloud(): &quot;&quot;&quot; 生成词云 &quot;&quot;&quot; counter = &#123;&#125; with open(os.path.join(&quot;data&quot;, &quot;post_pre_desc_counter.csv&quot;), &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.reader(f) for row in f_csv: counter[row[0]] = counter.get(row[0], int(row[1])) pprint(counter) file_path = os.path.join(&quot;font&quot;, &quot;msyh.ttf&quot;) wc = WordCloud(font_path=file_path, max_words=100, height=600, width=1200) wc.generate_from_frequencies(counter) plt.imshow(wc) plt.axis(&apos;off&apos;) plt.show() wc.to_file(os.path.join(&quot;images&quot;, &quot;wc.jpg&quot;))if __name__ == &quot;__main__&quot;: spider = JobSpider() spider.job_spider() spider.post_salary_locate() spider.post_salary() spider.post_salary_counter() spider.post_counter() spider.world_cloud()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua面向对象]]></title>
    <url>%2F2016%2F07%2F14%2FLua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[🤔 面向对象的特征 1） 封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。 2） 继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。 3） 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。 4）抽象：抽象是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。 Lua面向对象Lua中最基本的结构是table，所以需要用table来描述对象的属性。Lua中的function可以用来表示方法。那么Lua中的类可以通过table + function模拟出来。同时在Lua中，table就是一种对象。首先table与对象一样可以拥有状态。其次，table与对象一样拥有一个独立于其值的标识（self）。最后table与对象一样具有独立于创建者和创建地的生命周期。对象有其自己的操作，在table中：1234Account = &#123;balance = 0&#125;function Account.withdraw(v) Account.balance = Account.balance - vend 以上代码，创建了一个新函数，并将该函数存入Account对象的withdraw字段中，可以进行以下调用：Account.withdraw(100.00)这种函数就是所谓的“方法”。不过在函数中使用全局名称 Account是一个不好的变成习惯。因为这个函数只能针对特定对象工作，并且这个特定对象还必须存储在特定的全局。如果改变了对象的名称，withdraw就不能继续工作：123a = AccountAccount = nila.withdraw(100.0) --这里会报错 这种做法违反了之前所说对象的特性，即对象拥有独立的生命周期。我们有一种灵活的方式，即置顶一项操作所做用的“接受者”，因此需要一个额外的参数来表示该接受者。这个参数通常为self或this：1234567function Account.withdraw(self, v) self.balance = self.balance - venda1 = AccountAccount = nila1.withdraw(a1, 7) 使用self参数是所有面向对象语言的一个核心，大多数面向对象语言都能对程序员隐藏部分self参数，从而使的程序员不必显式的申明这个参数。在Lua中，只需要使用冒号，则能隐藏该参数。123456function Account:withdraw(v) self.balance = self.balance - venda = Accounta:withdraw(10) Lua中的类类可以看作一个创建对象的模具。大多面向对象的语言都提供了类的概念，在这些语言中，每个对象都是某个特定类的实例。Lua中没有类的概念，每个对象只能自定义行为和形态。不过在Lua中可以模拟类，可以参数一些基于原型的语言，例如newtonscript。在这些语言中对象没有类型，而是每个对象都有一个原型，原型也是一种常规的对象，当其他对象遇到一个未知操作时，原型会先查找它。在这种语言中要表示一个类，只需要创建一个专用作其他对象的原型。Lua中实现原型很简单，如果有两个对象，a和b，要让b作为a的一个原型，只需要如下操作：setmetatable(a, {__index = b})之后，a就会在b中查找所有它没有的操作，可以将b称为对象a的类。 在之前的例子中，为了创建更多的Account，可以让这些新的对象可以从Account行为中继承这些操作，具体的做法就是使用__index元方法。可以应用一些优化，无需创建一个额外的table作为元表，而是使用Account table自身作为元表：12345678function Account:new(o) o = o or &#123;&#125; --如果没有提供table，则创建一个 setmetatable(o, self) self.__index = self return oenda = Account:new&#123;balance = 0&#125;a : withdraw(7) 下面提供一个完整的实例：1234567891011121314151617Shape = &#123;area = 0&#125;-- 基础类方法 newfunction Shape:new (o,side) o = o or &#123;&#125; setmetatable(o, self) self.__index = self side = side or 0 self.area = side*side; return oend-- 基础类方法 printAreafunction Shape:printArea () print(&quot;面积为 &quot;,self.area)end-- 创建对象myshape = Shape:new(nil,10)myshape:printArea() Lua继承继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。以下演示了一个简单的继承实例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Shape = &#123;area = 0&#125;-- 基础类方法 newfunction Shape:new (o,side) o = o or &#123;&#125; setmetatable(o, self) self.__index = self side = side or 0 self.area = side*side; return oend-- 基础类方法 printAreafunction Shape:printArea () print(&quot;面积为 &quot;,self.area)end-- 创建对象myshape = Shape:new(nil,10)myshape:printArea()Square = Shape:new()-- 派生类方法 newfunction Square:new (o,side) o = o or Shape:new(o,side) setmetatable(o, self) self.__index = self return oend-- 派生类方法 printAreafunction Square:printArea () print(&quot;正方形面积为 &quot;,self.area)end-- 创建对象mysquare = Square:new(nil,10)mysquare:printArea()Rectangle = Shape:new()-- 派生类方法 newfunction Rectangle:new (o,length,breadth) o = o or Shape:new(o) setmetatable(o, self) self.__index = self self.area = length * breadth return oend-- 派生类方法 printAreafunction Rectangle:printArea () print(&quot;矩形面积为 &quot;,self.area)end-- 创建对象myrectangle = Rectangle:new(nil,10,20)myrectangle:printArea()]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua进阶]]></title>
    <url>%2F2016%2F07%2F09%2FLua%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[🤔 Lua协程 协程类似于线程，是一条执行序列，拥有自己独立的栈、局部变量和指令指针，同时与其他协程共享全局变量等。 线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。就是说，一个具有多个协程的程序在任意时刻只能运行一个协程，并且正在运行的协程只有在其显式的要求挂起时，他的执行才会暂停。 Lua将所有协程相关的函数放在一个名为“coroutine”的table中，其中主要方法有： 方法 描述 create() 用于创建新的协程，返回一个协程类型的值，参数是一个函数 resume() 用于启动或重启一个协程 yield() 挂起一个协程 wrap() 创建一个新协程，返回一个函数，调用函数时开启协程 status() 查看协程状态 通过status可以查看到一个协程可以处于4种不同的状态，分别是挂起（suspended）、运行（running）、死亡（dead）、正常（normal），当创建一个协程时，它处于挂起状态:1234567co = coroutine.create( function () print(&apos;Hello, World&apos;) end)print(coroutine.status(co)) 输出：suspended --协程处于挂起状态 通过resume启动这个协程：12coroutine.resume(co)print(coroutine.status(co)) 输出：12Hello, Worlddead -- 处于死亡状态 协程真正强大之处在于yield函数，该函数可以使一个运行中的协程处于挂起，而后再恢复他的运行：123456789co = coroutine.create( function () for i = 1, 10 do print(i) coroutine.yield() end end)coroutine.resume(co) 输出：121suspended --处于挂起状态 在这里，当唤醒协程时它开始执行，直到遇到yield，协程会被挂起，此时的活动都发生在yield调用中，当恢复协程执行，对于yield的调用才会最终返回，然后写成继续执行，直到下一个yield或执行结束：123for i = 1, 10 do coroutine.resume(co)end 输出：2 3 4 5 6 7 8 9 10再最后一次调用时，协程的内容已经执行完毕，并已经返回。因此这是的协程处于死亡状态，没有输出，如果试图再次执行它，resume将返回false及一条错误信息：print(coroutine.resume(co))输出：false cannot resume dead coroutine 下面是一个综合的实例：123456789101112131415161718192021222324function foo (a) print(&quot;foo 函数输出&quot;, a) return coroutine.yield(2 * a) -- 返回 2*a 的值end co = coroutine.create(function (a , b) print(&quot;第一次协同程序执行输出&quot;, a, b) -- co-body 1 10 local r = foo(a + 1) print(&quot;第二次协同程序执行输出&quot;, r) local r, s = coroutine.yield(a + b, a - b) -- a，b的值为第一次调用协同程序时传入 print(&quot;第三次协同程序执行输出&quot;, r, s) return b, &quot;结束协同程序&quot; -- b的值为第二次调用协同程序时传入end) print(&quot;main&quot;, coroutine.resume(co, 1, 10)) -- true, 4print(&quot;--分割线----&quot;)print(&quot;main&quot;, coroutine.resume(co, &quot;r&quot;)) -- true 11 -9print(&quot;---分割线---&quot;)print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- true 10 endprint(&quot;---分割线---&quot;)print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- cannot resume dead coroutineprint(&quot;---分割线---&quot;) 输出:123456789101112第一次协同程序执行输出 1 10foo 函数输出 2main true 4--分割线----第二次协同程序执行输出 rmain true 11 -9---分割线---第三次协同程序执行输出 x ymain true 10 结束协同程序---分割线---main false cannot resume dead coroutine---分割线--- Lua元表和元方法 通常Lua中的每个值都有一套预定义的操作集合。例如数字四则运算，字符串链接，增加table的键值对等。但无法将两个table相加,无法对函数做比较，也无法调用字符串。 我们可以通过元表来修改一个值的行为，使其在面对一个非预定义的操作时执行一个指定的操作。如上所诉，可以通过元表让两个table相加。当Lua试图将两个table相加时，会先检测两者之一是否有元表，然后检测该元表中是否有__add字段，若找到该字段，就调用该字段对应的值。这个值也就是所谓的元方法（通常是一个函数或者table），这个函数会用于计算两个table的和。 Lua中的每一个值都有一个元表，table和userdata可以有各自独立的元表，其他类型则共享其类型所属的单一元表。Lua在创建新的table时不会创建元表。 Lua中有两个重要的函数处理元表: setmetatable(table, metatable): 对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。 getmetatable(table): 返回对象的元表(metatable)。 123t = &#123;&#125;t1 = &#123;&#125;setmetatable(t, t1) 上面的代码可以简化为一行：t = setmetatable({}, {}) 任何table都可以作为任何值的元表，而一组相关的table也可以共享一个通用的元表，此元表描述了他们的共同行为。一个table甚至可以作为其自己的元表，用于描述其特有的行为。 在Lua代码中只能设置table的元表，若要设置其他类型值的元表，则必须通过c代码来完成。 __index元方法 当访问一个table不存在的字段时，会返回nil。这些访问会促使解释器去查找一个叫做__index的元方法，如果没有这个方法，那么访问结果就会为nil，否则就由这个元方法来提供结果。 假设要创建一个窗口的table，table中需要有位置、大小、背景等参数，所有参数都有默认值，因此希望在创建窗口对象时可以仅指定除了默认值的其他参数，这里我们可以这样实现：123456789101112131415window = &#123;&#125; --命名空间window.prototype = &#123;x = 0, y = 0, width = 70, height = 70&#125; --原型窗口window.mt = &#123;&#125; --创建元表function window.new(o) --声明构造函数 setmetatable(o, window.mt) return oendwindow.mt.__index = function(table, key) --定义元方法 return window.prototype[key]endw = window.new&#123;x = 10, y = 20&#125; -- 创建一个新窗口print(w.width)--查询它没有的字段--这里输出 70 __newindex元方法 newindex元方法和index类似，不同之处在于前者用于table更新，而后者用于在table中查询，当对一个table中不存在的索引赋值时，解释器就会查找这个元方法，如果有，解释器就调用它，而不是执行赋值。如果这个元方法是一个table，解释器就在这个table中赋值，而不是对原来的table。例： 12345678910t1 = &#123;&#125;t = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123; __newindex = t1 &#125;)print(t.key1)t.newkey = &quot;新值2&quot;print(t.newkey,t1.newkey)t.key1 = &quot;新值1&quot;print(t.key1,t1.key1) 输出：123value1nil 新值2新值1 nil 算数类元方法 Lua中每种算数操作符都有对应的字段名，如下所示： 字段名 描述 __add 对应运算符”+” __sub 对应运算符”-” __mul 对应运算符”*” __div 对应运算符”/” __unm 对应运算符”-” __concat 对应运算符”..” __eq 对应运算符”==” __mod 对应运算符”%” __pow 对应运算符”^” __lt 对应运算符”&lt;” __tostring元方法 函数print总是调用tostring来格式化输出。当格式化任意值时，tosrting会检查该值是否有__tostring元方法，如果有，tostring就会用该值作为参数来调用这个元方法。 12345678910t = setmetatable(&#123; 10, 20, 30 &#125;, &#123; __tostring = function(t) sum = 0 for k, v in pairs(t) do sum = sum + v end return &quot;表所有元素的和为 &quot; .. sum end&#125;)print(t) 输出：表所有元素的和为 60]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua基础]]></title>
    <url>%2F2016%2F07%2F04%2FLua%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[🤔 Lua IDEMac端Lua IDE推荐使用Intellij+EmmyLua。这也是我使用过最好的Lua IDE下载地址：IntelliJ IDEAEmmyLua安装方法：Preferences ——&gt;Plugins ——&gt;搜索EmmyLua 在使用EmmyLua时出现bug，或对此插件有什么建议，可以加群：29860775进行反馈 Lua 数据类型Lua是一种动态类型的语言。在语言中没有类型定义的语法，每个值都携带了它自身的类型信息。在Lua中有8种基础类型，分别是nil、boolean、number、string、userdata、function、thread和table 名称 数据类型 描述 示例 nil 空类型 表示一个无效值 a boolean 布尔 包含两个值：false和true a = true number 数字 双精度类型的实浮点数 a = 7 string 字符串 由一对双引号或单引号来表示 a = ‘yu’ userdata 自定义类型 任意存储在变量中的C数据结构 标准i/o库 function 函数 由 C 或 Lua 编写的函数 见下文 thread 协程 表示执行的独立线路，用于执行协同程序 table 表 Lua 中的表其实是一个”关联数组” a = {} 字符串 Lua中的字符串通常表示“一个字符序列”。 Lua完全采用8位编码，Lua字符串中的字符可以具有任何数值编码，包括数值0。 也就是说，可以将任意二进制数据存储到一个字符串中。 Lua的字符串是不可变的值。 Lua的字符串和其他Lua对象一样，都是自动内存管理机制所管理的对象 Lua字符串可以用以下方式来表示：s = &#39;Hello, World&#39;s = &quot;Hello, World&quot; Lua 提供了很多的方法来支持字符串的操作，可以查阅Lua 字符串来了解更多 变量 Lua 变量有两种类型：全局变量、局部变量。 Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声 明为局部变量。 局部变量的作用域为从声明位置开始到所在语句块结束。 变量的默认值均为 nil。local i = 1 --局部变量 Lua 流程控制 lua提供了一组传统的流程控制，if-else if语句先测试条件，然后根据结果执行then部分或else部分，其中else部分是可选的：123456789a = 0if a &gt; 0 then print(&apos;a &gt; 0&apos;)elseif a &lt; 0 then print(&apos;a&lt; 0&apos;)else print(&apos;a = 0&apos;)end Lua 循环 Lua 语言提供了以下几种循环: while for repeat…until 同时Lua 支持 break语句 while 与其他语言一样，Lua中的while循环先测试条件，如果条件为真，就执行循环体，否则结束循环：12345a = 0while a &lt; 10 do print(a) a = a + 1end repeat Lua中repeat-until语句会重复执行循环体至条件为真时结束：12345a = 0repeat print(a) a = a + 1until a &gt; 10 for Lua的for循环有两种形式： 数字型for 泛型for 数字型：123for i = 1, 10, 2 do print(i)end 含义为，i从1变化到10，每次变化以2作为步长递增并执行循环体。 其中步长是可选的，若不指定，则步长默认为1 泛型：1234days = &#123;&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;&#125;for i,v in ipairs(days) do print(i, v) end 泛型for循环通过一个迭代器函数来遍历所有的值，在Lua中，提供了ipairs这个用于便利数组的迭代器函数。每次循环，i会被赋予一个索引值，v会被赋予一个对应该索引值的数组元素值。泛型for循环的功能非常强大，可以通过不同的迭代器来遍历所有东西。如：迭代文件中的每行（io.lines）、迭代table元素（pairs）、迭代数组元素（ipairs）、迭代字符串中的字符（string.gmatch）等。当然，还可以自己编写迭代器。 break break语句用于结束一个循环，它只会跳出包含它的内部循环，而不会改变外部循环。例：123456789a = 0while a &lt; 10 do a = a + 1 if a &gt; 5 then break end print(a)end function 在Lua中，函数作为“一等对象”。这表示函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。这种特性使语言具有极大的灵活性。 Lua对函数式编程也提供了良好的支持。 Lua既可以调用自身的Lua编写的函数，也可以调用c编写的函数。 函数的定义如下：12345function SumTowNum(num1 , num2) return num1 + num2endprint(SumTowNum(10, 11)) 输出：21 Lua函数可以返回多个结果值，比如：12345678910111213function maximum (a) local mi = 1 -- 最大值索引 local m = a[mi] -- 最大值 for i,val in ipairs(a) do if val &gt; m then mi = i m = val end end return m, miendprint(maximum(&#123;8,10,23,12,5&#125;)) 输出:23 3 Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 …表示函数有可变的参数。 table表 Lua table 实现了关联数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。 Lua table 是不固定大小的，你可以根据自己需要进行扩容。 table是Lua中主要的（事实上也是仅有的）数据结构机制，具有强大的功能，基于table，可以以一种简单、统一和高效的方式来表示普通数组、符号表、集合、记录、队列及其他数据结构。同时Lua也是通过table来表示模块、包和对象的 可以将table想象成一种动态分配的对象，程序仅持有一个对它的引用（或指针）。 table的创建是通过构造表达式完成的： 1234--创建tablea = &#123;&#125;b = &apos;x&apos;a.b = 10 -- key = &apos;x&apos;. value = 10 tabel永远是匿名的，一个持有table的变量和table自身之间没有固定的关联性。]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua简介]]></title>
    <url>%2F2016%2F07%2F03%2FLua%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[🤔 Lua是可扩展的轻量级编程语言，它是用C语言编写的，并于1993年开始作为一个内部项目开始诞生。Lua代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。一个完整的Lua解释器不过200k，在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。它从一开始就设计为可以与用C语言编写等常规语言的代码集成软件。这种整合带来了很多好处。它不会尝试做C已经可以做东西，但旨在提供那些C是不好的：从测试和调试的硬件，动态结构，没有冗余，松藕合。对于这一点，lua有一个安全的环境，自动内存管理，以及处理字符串和其他类型的动态尺寸数据良好的设计。 特点Lua提供了一组独特的功能，使得它与其他语言不同。这些包括： 扩展 简单 高效 便携 免费和开源 示例代码:print(&quot;Hello World!&quot;) Lua如何实现Lua中包括的部件为Lua解释部分和运行软件系统。该软件系统功能是一个实际的计算机应用程序，它可以解释写在Lua的编程语言程序。 Lua解释是用ANSI C编写，因此它是非常便携，可以从高端网络服务器，以及小型设备设备上运行。Lua语言解释器非常成熟，体积小，速度快。它已经从其他编程语言和上层软件的标准演变而来的。作为小型程序可以在低内存小的设备上运行。 Lua相关用途 游戏编程 脚本中的独立应用程序 网页脚本 扩展和插件像MySQL代理和MySQL数据库的工作台 安全系统，如入侵检测系统]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python装饰器]]></title>
    <url>%2F2016%2F06%2F25%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[🤔 装饰器介绍 Python装饰器是程序开发中经常使用到的功能，熟练掌握装饰器会让你的编程思路更加广阔 要理解装饰器，首先要先理解： 在 Python 中“函数是一等对象” 。即函数是一种特殊类型的变量，可以和其余变量一样，可以作为参数传递给函数，也可以作为返回值返回。Python 中的整数、字符串和字典等都是一等对象。 函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。 装饰器实现装饰器本质上是python函数，它可以使其他函数在不需要做代码变动的情况下增加新的功能，装饰器返回值也是一个函数对象。 以下是一个简单的例子：假设现在有一个函数sayHi，用来输出一句话 1234def sayHi(): print(&apos;Hello, World&apos;)s = sayHis() 输出：Hello, World 我想希望在不修改sayHi函数的情况下在其之前再输出一句话,这种在代码运行期间动态增加功能的方式，称之为“装饰器”。本质上，装饰器就是一个返回函数的高阶函数 我们可以这么写： 12345678910def sayName(func): def inner(): print(&quot;I&apos;m Yu&quot;) return func return inner()def sayHi(): print(&apos;Hello, World&apos;)s = sayName(sayHi)s() 输出：12I&apos;m YuHello, World 但代码美中不足的是，我们每次给sayHi增加功能都需要用到类似s = sayName(sayHi)这句话。python为了简化这种情况，提供了一个语法糖“@”。 简化上边的代码: 1234567891011def sayName(func): def inner(): print(&quot;I&apos;m Yu&quot;) return func() return inner@sayNamedef sayHi(): print(&apos;Hello, World&apos;)sayHi() 输出：12I&apos;m YuHello, World 装饰器原理以上代码中，首先，在装饰器函数sayName中，sayName需要接受一个参数func，在其内部又定义了一个inner函数，在inner函数中增加一句输出，并返回func对象，然后sayName函数返回内部函数inner，其实就是一个闭包函数。接下来在sayHi上边增加一个@sayName，其意义就是在python解释器之行到此处时，会调用装饰器函数（sayName），并把被装饰得函数（sayHi）作为参数传入。此时的sayHi已经不是未加装饰时的函数了，而是指向sayName.inner函数地址。在接下来调用sayHi()时，其实就是调用sayName.inner。 有参函数装饰之前的例子是对无参函数的装饰，如果装饰带参数的函数该如何处理？1234567891011def sayName(func): def inner(name): print(&quot;I&apos;m Yu&quot;) return func(name) return inner@sayNamedef sayHi(name): print(&apos;Hi,&apos; + name)sayHi(&apos;siri&apos;) 输出：12I&apos;m YuHi,siri 两个装饰器装饰函数这里测试两个装饰器装饰一个函数的结果：1234567891011121314151617181920def sayName(func): print(&apos;name&apos;) def inner(): print(&quot;I&apos;m Yu&quot;) return func() return innerdef sayAge(func): print(&apos;age&apos;) def inner(): print(&quot;i&apos;m 30&quot;) return func() return inner@sayName@sayAgedef sayHi(): print(&apos;Hello, World&apos;)sayHi() 输出:12345agenameI&apos;m Yui&apos;m 30Hello, World 接下来分析输出这个结果的原因：首先，python解释器执行到第一个装饰器@sayName，在接下来发现装饰器下边不是一个函数而是另一个装饰器，解释器会执行第二个的装饰器@sayAge，然后把sayHi函数传入装饰器，所以首先输出了“age”，当@sayAge装饰完成，此时的sayHi函数地址指向了sayAge.inner的地址，解释器会返回去执行@sayName装饰器来装饰新的sayHi，从而输出了“name”，接着函数当前指向sayName.inner会先输出“I’m Yu”，在这里返回的func()其实就是返回的sayAge.inner，所以在下面输出i’m 30，最后输出原本sayHi的“Hello, World” 有参装饰器下边是装饰器带参数：1234567891011121314def now(time): def sayName(func): def inner(name): print(&apos;现在是: %s&apos; % time) print(&quot;I&apos;m Yu&quot;) return func(name) return inner return sayName@now(&apos;2016/10/30&apos;)def sayHi(name): print(&apos;Hello,&apos; + name)sayHi(&apos;siri&apos;) 输出：123现在是: 2016/10/30I&apos;m YuHello,siri 以上就是python装饰器的相关介绍]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数式编程]]></title>
    <url>%2F2016%2F06%2F17%2Fpython%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[🤔 函数式编程函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。 函数式编程Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。函数式编程就是一种抽象程度很高的编程范式。在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言 函数式编程的优点 逻辑可证 这是一个学术上的优点：没有”边界效应”使得更容易从逻辑上证明程序是正确的。 边界效应是指在进行程序设计时，我们的编程思想、算法以及分析测试的数据有可能会接近我们所没有注意的边界。所有的操作设计都会有一个边界，例如整形数据的内存，很多情况下在进行程序设计时，往往会被我们所忽略 模块化 函数式编程推崇简单原则，一个函数只做一件事情，将大的功能拆分成尽可能小的模块。小的函数更易于阅读和检查错误。 组件化 小的函数更容易加以组合形成新的功能。 易于调试 细化的、定义清晰的函数使得调试更加简单。当程序不正常运行时，每一个函数都是检查数据是否正确的接口，能更快速地排除没有问题的代码，定位到出现问题的地方。 易于测试 不依赖于系统状态的函数无须在测试前构造测试桩，使得编写单元测试更加容易。 更高的生产率 函数式编程产生的代码比其他技术更少（往往是其他技术的一半左右），并且更容易阅读和维护。 函数式编程的特征在支持函数式编程的语言中，大量使用如下特征的代码即可被认为是函数式： 函数是一等公民 函数能作为参数传递，或者是作为返回值返回。 匿名函数(lambda) lambda提供了快速编写简单函数的能力 闭包 闭包引用了外层函数的变量，然后返回内层函数 内置的不可变数据结构 如python中的元组 内置模板函数::见下文中的高阶函数:: 递归 匿名函数(lambda)当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。例：12p = lambda x: x+xprint(p(10) 其等价于：1234def test(x): return x+xp = test(10)print(p) 这里我建议尽量避免使用lambda。lambda功能十分有限，只能有一个表达式，返回值就是该表达式的结果。最主要是语句过于复杂，lambda表达式会很难阅读 高阶函数 能接收函数做参数的函数: 变量可以指向函数 函数的参数可以接收变量 一个函数可以接收另一个函数作为参数如：python内置函数，map()函数、reduce()函数、filter()函数等 Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数 例： 1234def test(x, y, z): return z(x, y)print(test(2, 3, pow)) 这里x，y是两个数值，z是一个函数 偏函数Python的functools模块提供了很多有用的功能，偏函数是其中之一，偏函数把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。如int()函数，其提供了base参数，默认值为10。如果传入base参数，就可以做进制的转换int(&#39;101010&#39;, base=2)如果经常需要做二进制转换我们就可以自己定义一个int2()函数12def int2(x, base=2): return int(x, base) 这里如果我们使用functools.partial，就可以非常方便的直接创建一个int2()12from functools import partialint2 = partial(int, base=2)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Functional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#]]></title>
    <url>%2F2016%2F05%2F01%2FC%23%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[🤔 C# 是一种面向对象的语言。不仅如此，C# 还进一步支持面向组件的编程。 当代软件设计越来越依赖采用自描述的独立功能包形式的软件组件。 此类组件的关键特征包括：为编程模型提供属性、方法和事件；包含提供组件声明性信息的特性；包含自己的文档。 C# 提供了语言构造来直接支持这些概念，让 C# 成为一种非常自然的语言，可用于创建和使用软件组件。 多项 C# 功能有助于构造可靠耐用的应用程序：垃圾回收可自动回收无法访问的未使用对象占用的内存；异常处理提供了一种结构化的可扩展方法来执行错误检测和恢复；C# 语言的类型安全设计禁止读取未初始化的变量、为范围之外的数组编制索引或执行未检查的类型转换。 C# 采用统一的类型系统。 所有 C# 类型（包括 int 和 double 等基元类型）均继承自一个根 object 类型。 因此，所有类型共用一组通用运算，任何类型的值都可以一致地进行存储、传输和处理。 此外，C# 还支持用户定义的引用类型和值类型，从而支持对象动态分配以及轻量级结构的内嵌式存储。为了确保 C# 程序和库能够随着时间的推移以兼容的方式发展，C# 设计更强调版本控制。 许多编程语言很少关注这个问题，因此，当引入新版依赖库时，用这些语言编写的程序会出现更多不必要的中断现象。 由于更强调版本控制，直接受影响的 C# 设计方面包括单独的 virtual 和 override 修饰符、关于方法重载决策的规则，以及对显式接口成员声明的支持。 C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。下面列出了 C# 成为一种广泛应用的专业语言的原因：现代的、通用的编程语言。面向对象。面向组件。容易学习。结构化语言。它产生高效率的程序。它可以在多种计算机平台上编译。.Net 框架的一部分。C# 强大的编程功能虽然 C# 的构想十分接近于传统高级语言 C 和 C++，是一门面向对象的编程语言，但是它与 Java 非常相似，有许多强大的编程功能，因此得到广大程序员的青睐。下面列出 C# 一些重要的功能：布尔条件（Boolean Conditions）自动垃圾回收（Automatic Garbage Collection）标准库（Standard Library）组件版本（Assembly Versioning）属性（Properties）和事件（Events）委托（Delegates）和事件管理（Events Management）易于使用的泛型（Generics）索引器（Indexers）条件编译（Conditional Compilation）简单的多线程（Multithreading）LINQ 和 Lambda 表达式集成 Windows详细指南可参考msdn，.net官方指南]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web渗透测试]]></title>
    <url>%2F2016%2F04%2F20%2FWeb%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[🤔 渗透测试流程 渗透测试执行标准 具体技术点 渗透的艺术]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据结构]]></title>
    <url>%2F2016%2F04%2F01%2FPython%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[🤔 字符串字符串是字符的序列，可以使用单引号、双引号及三引号来指定字符串123456name = &apos;etnly&apos; name = &quot;etnly&quot; # 两者工作机制完全相同 &apos;&apos;&apos;这是一个多行字符串 这是第二行 这位是第三行&apos;&apos;&apos; 在程序中使用的所有字符串都是str类下的对象，并且它也具有自己的方法，具体的方法清单可以查阅 help(str) 。 12345678910 # 返回字符串长度name = &apos;etnly&apos;len(name) # 遍历字符串name = &apos;etnly&apos;for i in name: print(i) # 字符串切片print(name[1:3]) # 输出 tn 列表列表是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序列。和字符串类似，在字符串中这些项目是字符，而列表中它可以是任何类型，列表中的值称为元素。 创建列表最简单的方式是使用 [] 方括号： 123num = [1, 2, 3] name = [&apos;张三&apos;, &apos;李四&apos;] other = [[1, 2, 3], &apos;a&apos;, &apos;b&apos; 3.0] 字符串的值是不可变的，而列表的值是可变的。如： 12num[1] = 3 print(num) 输出：[1, 3, 3] 列表对象也有自己的方法，具体可以查阅 help(list) 。 123456789101112 # 列表遍历num = [1, 2, 3]for i in num: print(i) # 列表拼接num2 = [2, 3, 4]num3 = num + num2 # 列表切片print(num3[1:3]) # 这里输出 [2, 3] # 添加元素num.append(4) 字典字典类似于列表，但更加通用，在列表中下表必须是整数，而字典中，下标基本可以是任意类型。 字典包含键（下标）和值。每一个键都关联一个值，这种方式称为键值对，字典体现了键到值的映射，所以可以说每一个键映射到一个值。 新建一个字典可以： d = {&#39;a&#39; : 1, &#39;b&#39; : 2, &#39;c&#39; : 3} d = dict() # 新建一个空字典 字典是通过散列表的方式实现的，意味着键必须是可散列的。散列是一个函数，接收值并返回一个整数，字典使用这些被称为散列值的整数来保存和查找键值对。 元组元组用于将多个对象保存到一起，其值可以是任何类型，并按照下标索引，元组和列表非常相似，其二者主要区别在于，元组是不可变的。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值。 元组语法上用逗号分隔一列值，可以用括号括起来： t = &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2 t = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2) 用括号括起来单独的值如 t = (‘a’) 并不是元组，如要新建元组可以使用内置函数tuple t = tuple() 严格的来说函数只能返回一个值，但如果返回的是元组，就可以达到类似返回多个值的效果。 元组、列表和字典列表和元组zip函数，接收两个或多个序列，并返回一个元组列表，每个元组包含来自每个序列的一个元素。 123a = &apos;abc&apos; b = [0, 1, 2] print(zip(a, b)) 结果返回 &lt;zip object at 0x10d5e1b08&gt; 这是一个zip对象，它知道如何遍历每个元素对，zip对象是一种迭代器，即用来迭代访问一个序列的对象 使用zip最常见的方法是在for循环中：12for i in zip(a, b): print(i) 输出：(&#39;a&#39;, 0) (&#39;b&#39;, 1) (&#39;c&#39;, 2) 如果需要使用列表的操作，可以利用zip对象制作一个列表： list(zip(a, b)) 字典和元组字典方法items可以返回一个元组序列，其中每个元组是一个键值对：123d = &#123;0 : &apos;a&apos;, 1 : &apos;b&apos;, 2 : &apos;c&apos;&#125; t = d.items() print(t) 输出： dict_items([(0, &#39;a&#39;), (1, &#39;b&#39;), (2, ‘c’)]) 反过来可以使用元组列表来初始化一个字典：12t = [(0, &apos;a&apos;), (1, &apos;b&apos;), (2, ‘c’)] d = dict(t) 我们可以通过dict和items得到一个简洁的创建新字典的方法： d = dict(zip(&#39;abc&#39;, range(3))) 序列列表、元组和字符串可以看作序列(Sequence)的某种表现形式，序列的主要功能是资格测试(也就是 in 与 not in 表达式)和索引操作，它们能够允许我们直接获取序列中的特定项目。 引用当你创建了一个对象并将其分配给某个变量时，变量只会查阅某个对象，并且它也 不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部分。这叫作将名称绑定给那一个对象。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象]]></title>
    <url>%2F2016%2F04%2F01%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[🤔 面向对象的编程类与对象是面向对象编程的两个主要方面。一个类能够创建一种新的类型 ，其中对象就是类的实例。可以这样来类比:你可以拥有类型 int 的变量，也就是说存储整数的变量是 int 类的实例。 即使是整数也会被视为对象。这不同于 C++ 与c#，在它们那儿整数是原始内置类型 在Python中，一切皆为对象。 对象可以使用属于它的普通变量来存储数据。这种从属于对象或类的变量叫作字段 。对象还可以使用属于类的函数来实现某些功能，这种函数叫作类的方法 。这两个术语很重要，它有助于我们区分函数与变量，哪些是独立的，哪些又是属于类或对象的。总之，字段与方法通称类的属性。字段有两种类型——它们属于某一类的各个实例或对象，或是从属于某一类本身。它们被分别称作实例变量与类变量。 self类方法与普通函数只有一种特定的区别——前者必须有一个额外的名字，这个名字必须添加到参数列表的开头，但是你不用在你调用这个功能时为这个参数赋值，Python 会为它提供。 这种特定的变量引用的是对象本身，按照惯例，它被赋􏰀 self 这一名称。 Python 中的 self 相当于 C++ 中的指针以及 Java 与 C# 中的 this 指针。 类这是一个最简单的类：123class Person: pass # 空的代码块 p = Person() # 创建Person的对象p 方法一个简单的方法： 12345class Person: def sayHi(self): print(‘Hello, World’) p = Person() p.sayHi() 输出: Hello, World 唯一与函数不同的地方在于这里多了一个self 继承面向对象编程的一大优点是对代码的重用，重用的一种实现方法就是通过继承机制。继承指的是根据一个现有的类型，定义一个修改版本的新类的能力。继承最好是想象成在类之间实现类型与子类型关系的工具。123456789101112131415161718192021222324252627282930class SchoolMember: &apos;&apos;&apos;代表任何学校里的成员。&apos;&apos;&apos;def __init__(self, name, age): self.name = name self.age = age print(&apos;(Initialized SchoolMember: &#123;&#125;)&apos;.format(self.name))def tell(self):&apos;&apos;&apos;告诉我有关我的细节。&apos;&apos;&apos;print(&apos;Name:&quot;&#123;&#125;&quot; Age:&quot;&#123;&#125;&quot;&apos;.format(self.name, self.age), end=&quot; &quot;)class Teacher(SchoolMember): &apos;&apos;&apos;代表一位老师。&apos;&apos;&apos;def __init__(self, name, age, salary): SchoolMember.__init__(self, name, age) self.salary = salary print(&apos;(Initialized Teacher: &#123;&#125;)&apos;.format(self.name)) def tell(self): SchoolMember.tell(self) print(&apos;Salary: &quot;&#123;:d&#125;&quot;&apos;.format(self.salary))class Student(SchoolMember): &apos;&apos;&apos;代表一位学生。&apos;&apos;&apos;def __init__(self, name, age, marks): SchoolMember.__init__(self, name, age) self.marks = marks print(&apos;(Initialized Student: &#123;&#125;)&apos;.format(self.name)) def tell(self): SchoolMember.tell(self) print(&apos;Marks: &quot;&#123;:d&#125;&quot;&apos;.format(self.marks))t = Teacher(&apos;Mrs. Shrividya&apos;, 40, 30000)s = Student(&apos;Swaroop&apos;, 25, 75)# 打印一行空白行 print()members = [t, s]for member in members:# 对全体师生工作 member.tell() 有一些特征是他们都具有的，例如姓名、年龄和地址。另外一些特征是他们独有的，一如教师的薪水、课程与假期，学生的成绩和学费。你可以为每一种类型创建两个独立的类，并对它们进行处理。但增添一条共有特征就意味着将其添加进两个独立的类。这很快就会使程序变得笨重。一个更好的方法是创建一个公共类叫作 SchoolMember ，然后让教师和学生从这个类中继承 ，也就是说他们将成为这一类型(类)的子类型，而我们就可以向这些子类型中添加某些该类独有的特征。这种方法有诸多优点。如果我们增加或修改了 SchoolMember 的任何功能，它将自动反映在子类型中。举个例子，你可以通过简单地向 SchoolMember 类进行操作，来为所有老师与学生添加一条新的 ID 卡字段。不过，对某一子类型作出的改动并不会影响到其它子类型。另一大优点是你可以将某一老师或学生对象看作 SchoolMember 的对象并加以引用，这在某些情况下会大为有用，例如清点学校中的成员数量。这被称作多态性(Polymorphism)，在任何情 况下，如果父类型希望，子类型都可以被替换，也就是说，该对象可以被看作父类的实例。同时还需要注意的是我们重用父类的代码，但我们不需要再其它类中重复它们，当我们使用独立类型时才会必要地重复这些代码。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础(2)]]></title>
    <url>%2F2016%2F03%2F30%2FPython%E5%9F%BA%E7%A1%80(2)%2F</url>
    <content type="text"><![CDATA[🤔 函数函数是指可重复使用的程序片段。它们允许你为某个代码块赋􏰀名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用函数。 函数可以通过关键字 def 来定义：123def say(): print(&apos;Hello, World&apos;) say() 函数参数函数可以获取参数，这个参数的值由你所提供，借此，函数便可以利用这些值来做一些事情。这些参数与变量类似，这些变量的值在我们调用函数时已被定义，且在函数运行时均已赋值完成。在定义函数 时给定的名称称作“形参”，在调用函数时你所提供给函数的值称作“实参”。123456def reaArea(a, b): s = a * b return s x = 10 y = 5 print(reaArea(x, y)) 以上为计算机型面积的函数，调用reaArea函数时，我们以变量作为实参来调用函数，使得x的值赋给行参a、y的值赋给行参b，并返回两者的乘积。 函数参数可以设置默认参数值，如：def reaArea(a , b = 5): 有时可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通 过使用星号来实现 1234567def func(a = 7, *b, **c): print(&apos;a&apos;, a) for i in b: print(&apos;b&apos;, i) for key, value in c.items(): print(key, value) func(10, 9, 8, 7, 6, 5, x = 1, y = 2, z = 3) 输出：a 10 b 9 b 8 b 7 b 6 b 5 x 1 y 2 z 3 当声明一个如*a 星号参数时，从此处开始直到结束的所有位置参数都将被收集并汇集成一个元组。类似地，当声明一个诸如 **b 的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个字典。 局部变量在一个函数的定义中声明变量时，它们不会以任何方式与处于函数之外但具有相同名称的变量产生关系，也就是说，这些变量名只存在于函数这一局部。这被称为变量的作用域。所有变量的作用域是它们被定义的块，从定义它们的名字的定义点开始。1234567n = 7 def func(n): print(&quot;1:&quot;, n) n = 10 print(&quot;2:&quot;, n) func(n) print(&quot;3:&quot;, n) 输出：1: 7 2: 10 3: 7 第一次打印出存在于函数块第一行名为 n 的值时，使用的是在函数声明之上的主代码块中声明的这一参数的值。接着，将10赋值给n。n是我们这一函数的局部变量。因此，当改变函数中n的值的时候，主代码块中的n则不会受到影响。最后一句 print 语句，打印出主代码块中定义的n的值，由此确认它不受先前调用的函数中的局部变量的影响。 global语句如果想给一个在程序顶层的变量赋值(也就是说它不存在于任何作用域中，无论是函数还是类)，那么你必须告诉程序这一变量并非局部的，而是全局的。我们需要通过global语句来完成这件事。因为在不使用global语句的情况下，不可能为一个定义于函数之外的变量赋值。 12345678n = 7 def func(): global n print(&quot;1:&quot;, n) n = 10 print(&quot;2:&quot;, n) func() print(&quot;3:&quot;, n) 输出： 1: 7 2: 10 3: 10 global语句用以声明n是一个全局变量，因此，当我们在函数中为n进行赋值时，这一改动将影响到我们在主代码块中使用的n的值 return 语句 return 语句用于从函数中返回，也就是中断函数。我们也可以选择在中断函数时从函数中返回一个值。123456def reaArea(a, b): s = a * b return s x = 10 y = 5 print(reaArea(x, y)) 如果 return 语句没有搭配任何一个值则代表着返回 None 。 None 在 Python 中一个特殊的类型，代表空。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础(1)]]></title>
    <url>%2F2016%2F03%2F27%2FPython%E5%9F%BA%E7%A1%80(1)%2F</url>
    <content type="text"><![CDATA[🤔 赋值赋值语句可以创建新的变量，并为其赋值：12say = &apos;Hello, World&apos;num = 7 第一个语句将字符串赋给“say”变量；第二个语句将17赋给num。 表达式表达式是变量、值、操作符的组合，单独的值与变量也被看作一个表达式 语句语句是一段可以产生效果的代码单元，如创建一个变量或显示一个值： 12say = &apos;Hello, World&apos;print(say) print语句显示say的值 注释Python中注释以“#”开头：123# 这里是注释 say = &apos;Hello, World&apos; print(say) # 输出say的值 如上所示，注释可以单独占一行，也可以加入到代码结尾。 控制流if语句if语句用以检查条件:如果 条件为真(True)，我们将运行一块语句(if 块)，否则 我们将运行另一块语句(else 块)。else 从句是可选 的。1234567num = 7 if num &gt; 0: print(&apos;num为正数&apos;) elif num == 0: print(&apos;num等于0&apos;) else: print(&apos;num为负数&apos;) 此处输出：num为正数 for语句for…in 语句是循环语句的一种，其特点是会在一系列对象上进行迭代，意即它会遍历序列中的每一个项目。1234for i in range(1, 10): print(i) else: print(&apos;循环结束&apos;) 此处输出：1 2 3 4 5 6 7 8 9 循环结束 for 循环就会在(1-9)这一范围内展开递归—— for i in range(1,10) 等价于 for i in [1，2，3， 4，5，6，7，8，9] ，这个操作将依次将队列里的每个数字(或是对象)分配给 i ，一次一个，然后以 每个 i 的值执行语句块else 部分是可选的。当循环中包含他时，它总会在 for 循环结束后开始执 行，除非程序遇到了 break 语句。 while语句while 语句能够让你在条件为真的前提下重复执行某块语句。 while 语句也是 一种循环语句。 while 语句同样可以拥有 else 子句作为可选选项。123456789num = 7 isRun = True while isRun: if num == 0: isRun = False else: num = num - 1 else: print(num) 此处输出：0 While会在循环开始前检查变量是否为true，之后再执行相应的 while 块，直到变量为false，循环结束。 break语句break 语句用以中断循环语句，也就是中止循环语句的执行，即使循环条件没有变更为 False ，或队列中的项目尚未完全迭代依旧如此。123456for i in range(1, 10): print(i) if i == 3: break else: print(&apos;循环结束&apos;) 此处输出：1 2 3 continue语句continue 语句用以告诉 Python 跳过当前循环块中的剩余语句，并继续该循环的下一次迭代。12345678while True: s = input(&apos;请输入名字&apos;) if s == &apos;yu&apos;: break if len(s) &lt; 2: print(&apos;请输入至少两个字符&apos;) continue print(&apos;名字为&apos;, s) 此处接收用户输入的内容，只有字符串长度大于等于2程序才会对其进行处理。如果其长度小 于 2，便通过使用 continue 语句跳过代码块中的其余语句。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反汇编基础(不同语言的反汇编入口)]]></title>
    <url>%2F2015%2F10%2F01%2F%E5%8F%8D%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%8D%E6%B1%87%E7%BC%96%E5%85%A5%E5%8F%A3)%2F</url>
    <content type="text"><![CDATA[🤔 在我们反汇编时，第一步（这里不考虑脱壳的情况，脱壳会在之后介绍）就是要找代码的入口函数。 一般使用OD打开工程时，并不会直接跳转到程序入口，而是先执行一系列的初始化工作，这些初始化工作通常是我们不需要关心的，所以我们需要先跳出这些函数，直接找到程序入口。 如何找到入口时反汇编最基础的操作，因为太简单，过程不做赘述，下边是我总结的几种语言的入口特征： c++123456789101112131415161700401B70 &gt;/$ 55 PUSH EBP 00401B71 |. 8BEC MOV EBP,ESP00401B73 |. 6A FF PUSH -100401B75 |. 68 08254000 PUSH crackme.0040250800401B7A |. 68 F61C4000 PUSH &lt;JMP.&amp;MSVCRT._except_handler3&gt; 00401B7F |. 64:A1 0000000 MOV EAX,DWORD PTR FS:[0]00401B85 |. 50 PUSH EAX00401B86 |. 64:8925 00000 MOV DWORD PTR FS:[0],ESP00401B8D |. 83EC 68 SUB ESP,6800401B90 |. 53 PUSH EBX00401B91 |. 56 PUSH ESI00401B92 |. 57 PUSH EDI00401B93 |. 8965 E8 MOV [LOCAL.6],ESP00401B96 |. 33DB XOR EBX,EBX00401B98 |. 895D FC MOV [LOCAL.1],EBX00401B9B |. 6A 02 PUSH 200401B9D |. FF15 98214000 CALL DWORD PTR DS:[&lt;&amp;MSVCRT.__set_app_ty&gt; 汇编123456789101100401025 &gt;/$ 6A F6 PUSH -0A 00401027 |. E8 A0000000 CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt; 0040102C |. A3 00304000 MOV DWORD PTR DS:[403000],EAX00401031 |. 6A F5 PUSH -0B 00401033 |. E8 94000000 CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt; 00401038 |. A3 04304000 MOV DWORD PTR DS:[403004],EAX0040103D |. 6A 01 PUSH 1 0040103F |. 68 00104000 PUSH EchoLine.00401000 00401044 |. E8 8F000000 CALL &lt;JMP.&amp;kernel32.SetConsoleCtrlHandle&gt;00401049 |. 6A 07 PUSH 7 0040104B |. FF35 00304000 PUSH DWORD PTR DS:[403000] Delphi1234567891011121314151617180045D408 &gt; $ 55 push ebp0045D409 . 8BEC mov ebp,esp0045D40B . 83C4 F0 add esp,-0x100045D40E . B8 28D24500 mov eax,DELPHI.0045D2280045D413 . E8 6088FAFF call DELPHI.00405C780045D418 . A1 4CF14500 mov eax,dword ptr ds:[0x45F14C]0045D41D . 8B00 mov eax,dword ptr ds:[eax]0045D41F . E8 08DFFFFF call DELPHI.0045B32C0045D424 . 8B0D 40F24500 mov ecx,dword ptr ds:[0x45F240] 0045D42A . A1 4CF14500 mov eax,dword ptr ds:[0x45F14C]0045D42F . 8B00 mov eax,dword ptr ds:[eax]0045D431 . 8B15 CCC84500 mov edx,dword ptr ds:[0x45C8CC] 0045D437 . E8 08DFFFFF call DELPHI.0045B3440045D43C . A1 4CF14500 mov eax,dword ptr ds:[0x45F14C]0045D441 . 8B00 mov eax,dword ptr ds:[eax]0045D443 . E8 7CDFFFFF call DELPHI.0045B3C40045D448 . E8 2769FAFF call DELPHI.00403D740045D44D . 8D40 00 lea eax,dword ptr ds:[eax] 易语言123456789101112131415004464D1 &gt;/$ 55 push ebp004464D2 |. 8BEC mov ebp,esp004464D4 |. 6A FF push -0x1004464D6 |. 68 B0C14600 push 易语言.0046C1B0004464DB |. 68 DCAC4400 push 易语言.0044ACDC 004464E0 |. 64:A1 0000000&gt;mov eax,dword ptr fs:[0]004464E6 |. 50 push eax004464E7 |. 64:8925 00000&gt;mov dword ptr fs:[0],esp004464EE |. 83EC 58 sub esp,0x58004464F1 |. 53 push ebx004464F2 |. 56 push esi004464F3 |. 57 push edi ; ntdll.7C930228004464F4 |. 8965 E8 mov [local.6],esp004464F7 |. FF15 98514600 call dword ptr ds:[&lt;&amp;KERNEL32.GetVersion&gt;; kernel32.GetVersion004464FD |. 33D2 xor edx,edx vb1234567004013EC &gt; $ 68 A4244000 PUSH Crack.004024A4004013F1 . E8 F0FFFFFF CALL &lt;JMP.&amp;MSVBVM60.ThunRTMain&gt;004013F6 . 0000 ADD BYTE PTR DS:[EAX],AL004013F8 . 0000 ADD BYTE PTR DS:[EAX],AL004013FA . 0000 ADD BYTE PTR DS:[EAX],AL004013FC . 3000 XOR BYTE PTR DS:[EAX],AL004013FE . 0000 ADD BYTE PTR DS:[EAX],AL]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,world]]></title>
    <url>%2F2015%2F07%2F23%2FHello%2CWorld%2F</url>
    <content type="text"><![CDATA[One]]></content>
      <categories>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>Yu</tag>
      </tags>
  </entry>
</search>
