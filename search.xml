<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python面向对象]]></title>
    <url>%2F2016%2F06%2F03%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Python面向对象🤔 面向对象的编程类与对象是面向对象编程的两个主要方面。一个类能够创建一种新的类型 ，其中对象就是类的实例。可以这样来类比:你可以拥有类型 int 的变量，也就是说存储整数的变量是 int 类的实例。 即使是整数也会被视为对象。这不同于 C++ 与c#，在它们那儿整数是原始内置类型 在Python中，一切皆为对象。对象可以使用属于它的普通变量来存储数据。这种从属于对象或类的变量叫作字段 。对象还可以使用属于类的函数来实现某些功能，这种函数叫作类的方法 。这两个术语很重要，它有助于我们区分函数与变量，哪些是独立的，哪些又是属于类或对象的。总之，字段与方法通称类的属性。字段有两种类型——它们属于某一类的各个实例或对象，或是从属于某一类本身。它们被分别称作实例变量与类变量。 self类方法与普通函数只有一种特定的区别——前者必须有一个额外的名字，这个名字必须添加到参数列表的开头，但是你不用在你调用这个功能时为这个参数赋值，Python 会为它提供。 这种特定的变量引用的是对象本身，按照惯例，它被赋􏰀 self 这一名称。 Python 中的 self 相当于 C++ 中的指针以及 Java 与 C# 中的 this 指针。 类这是一个最简单的类：123class Person: pass # 空的代码块 p = Person() # 创建Person的对象p 方法一个简单的方法： 12345class Person: def sayHi(self): print(‘Hello, World’) p = Person() p.sayHi() 输出: Hello, World 唯一与函数不同的地方在于这里多了一个self 继承面向对象编程的一大优点是对代码的重用，重用的一种实现方法就是通过继承机制。继承指的是根据一个现有的类型，定义一个修改版本的新类的能力。继承最好是想象成在类之间实现类型与子类型关系的工具。123456789101112131415161718192021222324252627282930class SchoolMember: &apos;&apos;&apos;代表任何学校里的成员。&apos;&apos;&apos;def __init__(self, name, age): self.name = name self.age = age print(&apos;(Initialized SchoolMember: &#123;&#125;)&apos;.format(self.name))def tell(self):&apos;&apos;&apos;告诉我有关我的细节。&apos;&apos;&apos;print(&apos;Name:&quot;&#123;&#125;&quot; Age:&quot;&#123;&#125;&quot;&apos;.format(self.name, self.age), end=&quot; &quot;)class Teacher(SchoolMember): &apos;&apos;&apos;代表一位老师。&apos;&apos;&apos;def __init__(self, name, age, salary): SchoolMember.__init__(self, name, age) self.salary = salary print(&apos;(Initialized Teacher: &#123;&#125;)&apos;.format(self.name)) def tell(self): SchoolMember.tell(self) print(&apos;Salary: &quot;&#123;:d&#125;&quot;&apos;.format(self.salary))class Student(SchoolMember): &apos;&apos;&apos;代表一位学生。&apos;&apos;&apos;def __init__(self, name, age, marks): SchoolMember.__init__(self, name, age) self.marks = marks print(&apos;(Initialized Student: &#123;&#125;)&apos;.format(self.name)) def tell(self): SchoolMember.tell(self) print(&apos;Marks: &quot;&#123;:d&#125;&quot;&apos;.format(self.marks))t = Teacher(&apos;Mrs. Shrividya&apos;, 40, 30000)s = Student(&apos;Swaroop&apos;, 25, 75)# 打印一行空白行 print()members = [t, s]for member in members:# 对全体师生工作 member.tell() 有一些特征是他们都具有的，例如姓名、年龄和地址。另外一些特征是他们独有的，一如教师的薪水、课程与假期，学生的成绩和学费。你可以为每一种类型创建两个独立的类，并对它们进行处理。但增添一条共有特征就意味着将其添加进两个独立的类。这很快就会使程序变得笨重。一个更好的方法是创建一个公共类叫作 SchoolMember ，然后让教师和学生从这个类中继承 ，也就是说他们将成为这一类型(类)的子类型，而我们就可以向这些子类型中添加某些该类独有的特征。这种方法有诸多优点。如果我们增加或修改了 SchoolMember 的任何功能，它将自动反映在子类型中。举个例子，你可以通过简单地向 SchoolMember 类进行操作，来为所有老师与学生添加一条新的 ID 卡字段。不过，对某一子类型作出的改动并不会影响到其它子类型。另一大优点是你可以将某一老师或学生对象看作 SchoolMember 的对象并加以引用，这在某些情况下会大为有用，例如清点学校中的成员数量。这被称作多态性(Polymorphism)，在任何情 况下，如果父类型希望，子类型都可以被替换，也就是说，该对象可以被看作父类的实例。同时还需要注意的是我们重用父类的代码，但我们不需要再其它类中重复它们，当我们使用独立类型时才会必要地重复这些代码。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据结构]]></title>
    <url>%2F2016%2F06%2F01%2FPython%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Python数据结构🤔 字符串字符串是字符的序列，可以使用单引号、双引号及三引号来指定字符串123456name = &apos;etnly&apos; name = &quot;etnly&quot; # 两者工作机制完全相同 &apos;&apos;&apos;这是一个多行字符串 这是第二行 这位是第三行&apos;&apos;&apos; 在程序中使用的所有字符串都是str类下的对象，并且它也具有自己的方法，具体的方法清单可以查阅 help(str) 。 12345678910 # 返回字符串长度name = &apos;etnly&apos;len(name) # 遍历字符串name = &apos;etnly&apos;for i in name: print(i) # 字符串切片print(name[1:3]) # 输出 tn 列表列表是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序列。和字符串类似，在字符串中这些项目是字符，而列表中它可以是任何类型，列表中的值称为元素。 创建列表最简单的方式是使用 [] 方括号：123num = [1, 2, 3] name = [&apos;张三&apos;, &apos;李四&apos;] other = [[1, 2, 3], &apos;a&apos;, &apos;b&apos; 3.0] 字符串的值是不可变的，而列表的值是可变的。如：12num[1] = 3 print(num) 输出：[1, 3, 3] 列表对象也有自己的方法，具体可以查阅 help(list) 。 123456789101112 # 列表遍历num = [1, 2, 3]for i in num: print(i) # 列表拼接num2 = [2, 3, 4]num3 = num + num2 # 列表切片print(num3[1:3]) # 这里输出 [2, 3] # 添加元素num.append(4) 字典字典类似于列表，但更加通用，在列表中下表必须是整数，而字典中，下标基本可以是任意类型。 字典包含键（下标）和值。每一个键都关联一个值，这种方式称为键值对，字典体现了键到值的映射，所以可以说每一个键映射到一个值。 新建一个字典可以： d = {&#39;a&#39; : 1, &#39;b&#39; : 2, &#39;c&#39; : 3} d = dict() # 新建一个空字典 字典是通过散列表的方式实现的，意味着键必须是可散列的。散列是一个函数，接收值并返回一个整数，字典使用这些被称为散列值的整数来保存和查找键值对。 元组元组用于将多个对象保存到一起，其值可以是任何类型，并按照下标索引，元组和列表非常相似，其二者主要区别在于，元组是不可变的。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值。 元组语法上用逗号分隔一列值，可以用括号括起来： t = &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2 t = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2) 用括号括起来单独的值如 t = (‘a’) 并不是元组，如要新建元组可以使用内置函数tuple t = tuple() 严格的来说函数只能返回一个值，但如果返回的是元组，就可以达到类似返回多个值的效果。 元组、列表和字典列表和元组zip函数，接收两个或多个序列，并返回一个元组列表，每个元组包含来自每个序列的一个元素。 123a = &apos;abc&apos; b = [0, 1, 2] print(zip(a, b)) 结果返回 &lt;zip object at 0x10d5e1b08&gt; 这是一个zip对象，它知道如何遍历每个元素对，zip对象是一种迭代器，即用来迭代访问一个序列的对象 使用zip最常见的方法是在for循环中：12for i in zip(a, b): print(i) 输出：(&#39;a&#39;, 0) (&#39;b&#39;, 1) (&#39;c&#39;, 2) 如果需要使用列表的操作，可以利用zip对象制作一个列表： list(zip(a, b)) 字典和元组字典方法items可以返回一个元组序列，其中每个元组是一个键值对：123d = &#123;0 : &apos;a&apos;, 1 : &apos;b&apos;, 2 : &apos;c&apos;&#125; t = d.items() print(t) 输出： dict_items([(0, &#39;a&#39;), (1, &#39;b&#39;), (2, ‘c’)]) 反过来可以使用元组列表来初始化一个字典：12t = [(0, &apos;a&apos;), (1, &apos;b&apos;), (2, ‘c’)] d = dict(t) 我们可以通过dict和items得到一个简洁的创建新字典的方法：d = dict(zip(&#39;abc&#39;, range(3))) 序列列表、元组和字符串可以看作序列(Sequence)的某种表现形式，序列的主要功能是资格测试(也就是 in 与 not in 表达式)和索引操作，它们能够允许我们直接获取序列中的特定项目。 引用当你创建了一个对象并将其分配给某个变量时，变量只会查阅某个对象，并且它也 不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部分。这叫作将名称绑定给那一个对象。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础(2)]]></title>
    <url>%2F2016%2F05%2F30%2FPython%E5%9F%BA%E7%A1%80(2)%2F</url>
    <content type="text"><![CDATA[Python基础(2)🤔 函数函数是指可重复使用的程序片段。它们允许你为某个代码块赋􏰀名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用函数。 函数可以通过关键字 def 来定义：123def say(): print(&apos;Hello, World&apos;) say() 函数参数函数可以获取参数，这个参数的值由你所提供，借此，函数便可以利用这些值来做一些事情。这些参数与变量类似，这些变量的值在我们调用函数时已被定义，且在函数运行时均已赋值完成。在定义函数 时给定的名称称作“形参”，在调用函数时你所提供给函数的值称作“实参”。123456def reaArea(a, b): s = a * b return s x = 10 y = 5 print(reaArea(x, y)) 以上为计算机型面积的函数，调用reaArea函数时，我们以变量作为实参来调用函数，使得x的值赋给行参a、y的值赋给行参b，并返回两者的乘积。 函数参数可以设置默认参数值，如：def reaArea(a , b = 5): 有时可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通 过使用星号来实现 1234567def func(a = 7, *b, **c): print(&apos;a&apos;, a) for i in b: print(&apos;b&apos;, i) for key, value in c.items(): print(key, value) func(10, 9, 8, 7, 6, 5, x = 1, y = 2, z = 3) 输出：a 10 b 9 b 8 b 7 b 6 b 5 x 1 y 2 z 3 当声明一个如*a 星号参数时，从此处开始直到结束的所有位置参数都将被收集并汇集成一个元组。类似地，当声明一个诸如 **b 的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个字典。 局部变量在一个函数的定义中声明变量时，它们不会以任何方式与处于函数之外但具有相同名称的变量产生关系，也就是说，这些变量名只存在于函数这一局部。这被称为变量的作用域。所有变量的作用域是它们被定义的块，从定义它们的名字的定义点开始。1234567n = 7 def func(n): print(&quot;1:&quot;, n) n = 10 print(&quot;2:&quot;, n) func(n) print(&quot;3:&quot;, n) 输出：1: 7 2: 10 3: 7 第一次打印出存在于函数块第一行名为 n 的值时，使用的是在函数声明之上的主代码块中声明的这一参数的值。接着，将10赋值给n。n是我们这一函数的局部变量。因此，当改变函数中n的值的时候，主代码块中的n则不会受到影响。最后一句 print 语句，打印出主代码块中定义的n的值，由此确认它不受先前调用的函数中的局部变量的影响。 global语句如果想给一个在程序顶层的变量赋值(也就是说它不存在于任何作用域中，无论是函数还是类)，那么你必须告诉程序这一变量并非局部的，而是全局的。我们需要通过global语句来完成这件事。因为在不使用global语句的情况下，不可能为一个定义于函数之外的变量赋值。 12345678n = 7 def func(): global n print(&quot;1:&quot;, n) n = 10 print(&quot;2:&quot;, n) func() print(&quot;3:&quot;, n) 输出： 1: 7 2: 10 3: 10 global语句用以声明n是一个全局变量，因此，当我们在函数中为n进行赋值时，这一改动将影响到我们在主代码块中使用的n的值 return 语句 return 语句用于从函数中返回，也就是中断函数。我们也可以选择在中断函数时从函数中返回一个值。123456def reaArea(a, b): s = a * b return s x = 10 y = 5 print(reaArea(x, y)) 如果 return 语句没有搭配任何一个值则代表着返回 None 。 None 在 Python 中一个特殊的类型，代表空。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础(1)]]></title>
    <url>%2F2016%2F05%2F27%2FPython%E5%9F%BA%E7%A1%80(1)%2F</url>
    <content type="text"><![CDATA[Python基础(1)🤔 赋值赋值语句可以创建新的变量，并为其赋值：12say = &apos;Hello, World&apos;num = 7 第一个语句将字符串赋给“say”变量；第二个语句将17赋给num。 表达式表达式是变量、值、操作符的组合，单独的值与变量也被看作一个表达式 语句语句是一段可以产生效果的代码单元，如创建一个变量或显示一个值： 12say = &apos;Hello, World&apos;print(say) print语句显示say的值 注释Python中注释以“#”开头：123# 这里是注释 say = &apos;Hello, World&apos; print(say) # 输出say的值 如上所示，注释可以单独占一行，也可以加入到代码结尾。 控制流if语句if语句用以检查条件:如果 条件为真(True)，我们将运行一块语句(if 块)，否则 我们将运行另一块语句(else 块)。else 从句是可选 的。1234567num = 7 if num &gt; 0: print(&apos;num为正数&apos;) elif num == 0: print(&apos;num等于0&apos;) else: print(&apos;num为负数&apos;) 此处输出：num为正数 for语句for…in 语句是循环语句的一种，其特点是会在一系列对象上进行迭代，意即它会遍历序列中的每一个项目。1234for i in range(1, 10): print(i) else: print(&apos;循环结束&apos;) 此处输出：1 2 3 4 5 6 7 8 9 循环结束 for 循环就会在(1-9)这一范围内展开递归—— for i in range(1,10) 等价于 for i in [1，2，3， 4，5，6，7，8，9] ，这个操作将依次将队列里的每个数字(或是对象)分配给 i ，一次一个，然后以 每个 i 的值执行语句块else 部分是可选的。当循环中包含他时，它总会在 for 循环结束后开始执 行，除非程序遇到了 break 语句。 while语句while 语句能够让你在条件为真的前提下重复执行某块语句。 while 语句也是 一种循环语句。 while 语句同样可以拥有 else 子句作为可选选项。123456789num = 7 isRun = True while isRun: if num == 0: isRun = False else: num = num - 1 else: print(num) 此处输出：0 While会在循环开始前检查变量是否为true，之后再执行相应的 while 块，直到变量为false，循环结束。 break语句break 语句用以中断循环语句，也就是中止循环语句的执行，即使循环条件没有变更为 False ，或队列中的项目尚未完全迭代依旧如此。123456for i in range(1, 10): print(i) if i == 3: break else: print(&apos;循环结束&apos;) 此处输出：1 2 3 continue语句continue 语句用以告诉 Python 跳过当前循环块中的剩余语句，并继续该循环的下一次迭代。12345678while True: s = input(&apos;请输入名字&apos;) if s == &apos;yu&apos;: break if len(s) &lt; 2: print(&apos;请输入至少两个字符&apos;) continue print(&apos;名字为&apos;, s) 此处接收用户输入的内容，只有字符串长度大于等于2程序才会对其进行处理。如果其长度小 于 2，便通过使用 continue 语句跳过代码块中的其余语句。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,world]]></title>
    <url>%2F2015%2F07%2F23%2FHello%2CWorld%2F</url>
    <content type="text"><![CDATA[One]]></content>
      <categories>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
</search>
