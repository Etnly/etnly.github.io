<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac及应用介绍]]></title>
    <url>%2F2018%2F06%2F01%2FMacintroduce%2F</url>
    <content type="text"><![CDATA[🤔 从最初在我第二个东家接触MacMini以来，到之后因为太穷只买得起的MacBookAir，再到现在的MacBookPro和Imac，使用Mac已经五年有余。资深说不上，至少也是熟练掌握mac使用技巧😅😅。 之前逛知乎经常看到类似“Mac和Windows孰优孰劣”、“Mac上xxx的软件哪个好”或者是“Mac上有什么类似Windowsxxx的应用”以及“为什么要使用Mac做xxx”。 我是个懒人，算是知乎的重度用户，但基本没有回答过问题，可有时候看到自己熟悉的话题又总想写点什么，打了几个字后发现还有这么多字要打真麻烦，就关掉这个问题去看下一个。所以为了一劳永逸，顺便还能推广下我的博客，就有了今天这篇文章。 Mac 首先来介绍Mac的产品。 苹果现在的Mac系列产品线包括 MacBook、MacBookAir、MacBookPro、iMac、 iMacPro、MacPro、MacMini 如果说购买推荐，当然还是要依据使用场景来衡量。MacBook和MacBookAir适合移动办公。iMac是一台显示器逆天颜值逆天的一体机。iMacPro我是真的很推荐定制顶配的这款机器（同时拥有它也是我的梦想）。MacPro是一台性能超强大的专业台式机。Macmini算是性价比最高的mac，也是使用mac的公司和学校最偏爱的机型。最后是MacBookPro，它是mac系列的中坚力量，便于携带且性能强大，如果你想追求更强的性能、更好的体验、更清晰的画质，那我推荐购买最新版顶配的MacBook Pro。 Mac和Windows 再从“Mac和Windows孰优孰劣”说起。 在知乎上关于这个问题的答案，大致总结一下就是从审美、稳定度、生态、性能、开放程度和应用等方面来对比。但对于这个问题我并不想回答，唯一能让大家接受的回答也就只有“从系统而言两者互有优劣”，毕竟两者一个是一体化电脑，一个是操作系统，从性能、稳定程度、应用场景、兼容性这些方面本就不具备可比性，但如果有说windows跑在mac的硬件上会更加稳定流畅的，那你买个mac装windows好了。而单从系统方面而言，这真的就是一个见仁见智的问题。在这些对比中，最为突出的就是应用问题，在windows上有太多耳熟能详的软件，并且拥有着vs、office这些强大到不可替代的官方应用。而随着MacOS上AppStore日渐衰落，大多使用mac的一般用户很难找到windows软件的代替平或者更加好用的应用。所以在下面，我主要介绍一下mac上我常用到或了解过好用的应用。 Mac应用介绍开发： Xcode Mac上优秀的集成开发工具，几乎所有的mac app和ios app都是由此而生。如果使用mac做开发，那Xcode是你必不可少的工具之一。 JetBrains系列 产品线非常丰富且功能强大，几乎都是精品，Java、Python、Ruby、Php、Web一应俱全，而我常用的JetBrains系列有用于Python开发的Pycharm，用于Lua开发的Intellij+EmmyLua（在之前关于Lua教程的文章中有写到），用于Web开发的WebStorm。但是JetBrains系列收费都比较贵，虽然有破解版，但我还是提倡使用正版 VS For Mac 微软发布的Mac版vs，其实就是Xamarin Studio改了个名，和真正的vs差的太多，但是因为要写c#，而且最新的unity 中只支持vs，所以只能用它。 Sublime Text 神级代码编辑软件 Navicat Premium mac上非常优秀的一款数据库管理工具 dash 开发者必备API文档聚合,Dash是一个API文档浏览器，以及代码片段管理工具。它就只有这两个功能，但确实是程序员最为关心的特性，可以毫不夸张地说，Dash是它们之中做的最好的一个！非常实用。 效率： iWork Mac自带的办公套件（Pages、Numbers、Keynote）其中个人认为Keynote要优于PowerPointPages和Word各有千秋Numbers要差Excel很多 OmniGraffle 主要用于绘制 流程图、图表、组织结构图、UI界面设计等等，可以用于设计任何描述图形，简单易用，功能强大，非常的专业和优秀，如果你有任何绘制图表的需求，那么Mac上当首选OmniGraffle。我甚至会觉得它比vision更加好用。 XMind XMind 是一款国产的思维导图制作软件，在国际上也有一定的名气了，简单易用、美观、功能强大,拥有高效的可视化思维模式,具备可扩展、跨平台、稳定性和性能。 Axure Axure RP是一款专业的快速原型设计工具。 Bear 在之前我介绍过另一款markdown编辑器（ulysses），而bear是可以代替甚至可以说优于ulysses的一款markdown编辑器。如果有做笔记、写博客的需求，我非常推荐这一款应用。 Evernote 印象笔记，你可以使用任何一台设备打开Evernote，在这里捕捉点滴灵感、轻松收集资料、一键演示笔记、高效协作共享，笔记会自动在所有设备上同步。 工具： Alfred 3 快启工具，可以充当了一切程序的入口，并有高度的可配置性，Mac曾经的第一神器，但随着MacOS的Spotlight功能加强，Alfred已经不那么必要，但习惯使用Alfred后你会很难再离开它。 1Password 密码管理工具，MacOS自带的密码管理也十分好用，尤其是在苹果设备上十分便捷，但如果你需要转移到别的系统就需要一款通用型很强的工具，不过我更推荐lastpass。 Paste 十分好用的一款剪切板工具 BetterTouchTool 如果你使用macbook系列产品，那这款软件会非常有用，MacOS自带的触板及鼠标手势十分有限，而那么大的一块儿触板你怎么忍心荒废，这款应用有极高的自由度让你使用非常多的手势来操控你的mac。 Cheatsheet 这款应用你可以长按command，就能查看当前软件的所有快捷键。 istat menus 最好的系统状态监控软件 ipic 非常好用的图床软件 The Unarchiver + Keka 这两款非常好的解压、压缩软件，基本可以完成对任何格式文件的压缩和解压工作 CleanMyMac 3 一款使用人数较多的Mac清理工具 parallels desktop Mac上最好用的一款虚拟机软件 IINA Mac上第二好用的视频播放软件，为什么不用第一，因为第一好用的mpv配置非常麻烦，IINA基于mpv，拥有强大的性能和兼容性，可以支持流畅播放几乎所有主流视频格式，并且支持网络播放。 Folx 老牌儿下载工具，但是我更推荐迅雷，不过迅雷会和谐很多链接，被和谐的就可以使用Folx来下载 ShadowsocksX 科学上网的神器😉 Safari 在Mac上safari非常好用，如果要介绍safari可能需要再来一篇文章的篇幅，之后也许我会介绍很多非常好用的safari，让你的safari不亚于firefox和chrome，并且safari除了扩展，自身也有很多非常好用的功能，我们以后再谈 同时MacOS还自带了很多很好用的软件及功能，这就需要自己去研究和发现了]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链]]></title>
    <url>%2F2018%2F01%2F30%2FBlockchain%2F</url>
    <content type="text"><![CDATA[🤔 什么是区块链 区块链源起比特币，但并不局限在币圈。区块链技术是储存、验证和数据保护等问题的实际解决办法。区块链可被视为分散的、极度安全的数据库。更专业一点来说，区块链是分布式的点对点的基于密码学的共享账本，可以在金融服务、保险、医疗、政府等领域内被广泛应用。 理解区块链，首先需要明确的是，区块链是一套协议和规范，用英文表述就是 Protocol，不是具体的代码或者项目。理解了这套协议，你可以基于不同的语言和技术去实现它，这和我们平时定义了一套 API，然后基于不同的技术实现没有什么分别。 从字面上看：区块链是由一个个记录着各种信息的小区块链接起来组成的一个链条，类似于我们将一块块砖头叠起来，而且叠起来后是没办法拆掉的，每个砖头上面还写着各种信息，包括：谁叠的，什么时候叠的，砖头用了什么材质等等，这些信息你也没办法修改。 从计算机上看：区块链是一种比较特殊的分布式数据库。分布式数据库就是将数据信息单独放在每台计算机，且存储的信息的一致的，如果有一两台计算机坏掉了，信息也不会丢失，你还可以在其他计算机上查看到。区块链是一种分布式的，所以它是没有中心点的，信息存储在所有加入到区块链网络的节点当中，节点的数据是同步的。节点可以是一台服务器，笔记本电脑，手机等。你要知道的是这些节点的存储的数据都是一模一样。 区块链在不同领域的人眼里，可能是不同的东西。角度不同，我们得出的结论也不一样。金融领域的人会认为区块链是个分布式的账本，是一个分布式的去中心化的记账系统。搞安全和密码学的人会说区块链是基于密码学构建的对等网络。而我们程序员了解了区块链技术，会认为这不就是一个保证最终一致性的分布式数据库嘛。 记账系统对于普通人来说，记账系统最容易理解，我们从账本说起。比如大家一起做生意，总要有个账本，最初这个账本由账房先生管理。但一个人管，总会出现对账不平衡的情况（比如挪用），于是大家开始轮流管。这种方式也有问题，在某个人保管账本和记账期间，一旦发生了数据丢失或账本损坏的情况，也会搞不清真实原因。最后大家决定用一种新的记账方式，每个人一个自己的账本，任何人改动了自己的账本都要告诉其他所有人，其他人也会在自己的账本记上一笔。只要有人发现新的账目不对，可以拒绝接受。最后以大多数人一致的账目为准。这就是分布式的去中心化的记账系统。但这种做法时间长了还是会有问题，有人天天记，有人偷懒不记，会产生不公平。于是大家决定每天早上掷骰子，根据点数决定谁来记当天的账，其他人核对一下，没问题就复制过来。并且，当天的记账者会获得一点点奖励（这就是挖矿）。 去中心化的分布式数据库把上面的记账系统用软件技术实现了，就是去中心化的分布式数据库。什么是中心化，早期互联网大都采用 CS 架构，一个服务器 N 个客户端，Client 和 Server 之间进行通讯，系统可靠性严重依赖 Server，这叫中性化。随着业务复杂度的增加，服务器端也开始分拆，横向和纵向扩展，读写分离等等，这就是我们常用的分布式架构系统，系统可靠性依赖分布式系统的热备份和容灾恢复能力。这时候服务器虽然分布了，但依然是中性化的。大部分商业公司都采用类似的架构和模式。去中心化是怎么回事呢？就是数据库不属于任何机构和管理员。只要服务器端被某个机构或管理员控制，就存在宕机或数据篡改的风险。区块链和 P2P 的网络通信技术最终实现了去中心化。区块链的作用就是存储信息，可以认为是一个数据库，而任何人都可以通过 P2P 网络架设服务器，接入区块链网络，成为一个节点。这下人人平等了，大家都是 Server，也就没有了 Server，每个节点既是生产者也是消费者。你可以向任何一个节点读写数据，一旦写入就是历史，最后所有的节点都会同步数据，保证「账本」的一致性。区块链是没有管理员的，也不需要人工审核和干涉。那人人都能写数据，数据的可信度怎么保证呢？数据被篡改了咋办？别担心，P2P 网络只是进行信息通讯，保证数据安全的还有共识算法和加密算法。 共识算法关于共识算法、拜占庭将军问题，大家可以参考这一篇文章，很长，但容易看懂。分布式一致性与共识算法（https://draveness.me/consensus）简单来说，共识算法就是保证少数服从多数，也就是我在记账系统中写过的「最后以大多数人一致的账目为准」。大多数人认可的事情，就是事实。这种规则听起来挺吓人的，比如我们常常在文学作品和历史经验中知道，真理往往掌握在少数人手里。但是在 P2P 的网络里，有无数的节点，要想大部分节点一起作恶，除非这些节点都被某个组织控制了。这种可能性虽然不是没有，但几率非常小。总的来说，共识算法解决的是对某个提案（Proposal）达成一致意见的过程。提案的含义在分布式系统中十分宽泛，包括多个事件发生的顺序、某个键对应的值…等等，可以认为任何需要达成一致的信息都是一个提案。有了共识算法和相关的加密算法，就可以保证数据的安全性和一致性。 为什么会挖矿？谈到比特币，大家耳熟能详的就是挖矿和矿机这种事。那为什么会挖矿呢？挖矿其实是一种激励和竞争机制。在区块链系统中，总有些节点被选中进行数据整理、验证、打包，并把相关的改动广播出去，这个工作还是挺耗资源的，所以会有奖励机制。负责打包的节点会获得系统的奖励，类似积分，对于比特币系统来说，就是奖励比特币。有了奖励，很多节点都希望获得这样的奖励，于是有些区块链系统，比如比特币就会设计出一种竞争机制，让各个节点凭借自己的算力和资源去抢，能抢到这个数据打包的机会，就会获得奖励，也就是比特币。这个竞争的过程就是挖矿。什么是算力呢？就是计算机每秒产生 hash 碰撞的能力。也就是说，手里的矿机每秒能做多少次 hash 碰撞。算力越高，获得的奖励越多。 区块链的未来很多人觉得区块链的唯一应用就是发行虚拟货币，最近国内外市场也是烽烟四起，比如超过百年历史的伊士曼柯达公司宣布推出基于区块链技术的「柯达币」（KodakCoin）和 KodakOne 平台，让全球的摄影师能够更好的控制图片的版权和交易。然后股价就飙升了……了解了区块链的技术特点，我们就知道，区块链的能力远不止虚拟货币领域，未来的 金融服务、物流、保险、医疗、共享经济、智能合约领域，应该都会有区块链的身影。繁华落尽，洗尽铅华，所有的技术都将经历时间的洗礼。历经爆发期、衰退期并进入成熟期的技术，才是真正能具备生命力的技术。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity性能优化]]></title>
    <url>%2F2017%2F11%2F26%2FUnityPerformance%20Optimization%2F</url>
    <content type="text"><![CDATA[🤔 性能优化是游戏项目开发过程中一个永恒的话题。玩家和项目的需求在并且会一直增长，同屏人数、游戏特效和场景复杂度永远在向着“榨干”硬件的趋势逼近。所以，无论硬件设备发展到何种程度，无论研发团队有多么丰富的经验积累，性能优化永远是一个非常棘手而又无法绕开的问题。 对于Unity性能优化，官方有非常好的教程，（参见官方教程）。如果英文水平一般，可以参考官方教程翻译 同时我们也可以去看看腾讯是如何做Unity手游性能优化的 这里我说一些自己的经验，以及常用的优化方法 工具 首先从Unity性能优化工具说起 Unity ProfileUnity中最常用的官方性能分析工具，Unity Profiler能定量地找到C#的GC Alloc问题 XCode Capture GPU frame能高效且定量地定位到GPU中shader的消耗。苹果平台下图形调试最好的选择。 TimeProfilerInstruments的TimeProfiler能高效且定量地定位C#脚本的CPU占用，甚至包括部分Unity引擎代码的CPU占用函数消耗，而不必麻烦地添加BeginSample()、EndSample()。 方法 性能优化主要是围绕CPU、GPU和内存三大方面进行，所以我们可以从这三方面展开。 CPU优化 使用对象池优化游戏物体的创建与销毁； 使用对象池时，应当可以支持把物体移除屏幕，连续使用的物体可以只是移出屏幕，只有长时间不使用的物体才隐藏； 减少对粒子系统Play()的调用； 避免实例化对象时造成cpu峰值。比如某一个特定时间，集中创建很多对象，这里可以使用协程做一些间隔； 尽量删除脚本中为空或不需要的方法； 同一脚本中频繁使用的变量建议声明其为全局变量，脚本之间频繁调用的变量或方法建议声明为全局静态变量或方法； 不要去频繁获取组件，将其声明为全局变量； 处理Rigidbody时，使用FixedUpdate，设置Fixed timestep，减少物理计算次数； 如果可以，尽量不用MeshCollider，如果不能避免的话，尽量用减少Mesh的面片数，或用较少面片的代理体来代替； 减少GetComponent()的使用频率，GetComponent()会有一定的GC产生，有少量的CPU消耗； 使用内建数组如使用Vector3.zero而不是new Vector(0,0,0); GPU优化 保持材质的数目尽可能少； Mesh合并，可以在3dMax或其他建模软件上进行操作，也可在Unity中进行操作； 使用“全局光照+光照探头”代替实时局部光照； 避免使用实时阴影，如果必须使用实时阴影，可以在 Quality 质量设置中选择合适的阴影质量，在画面效果和渲染效率之间找到平衡点； LOD层级细节，根据距离的远近使用不同模型级别，这样就可以减少模型上面的顶点和面片数量从而提高性能； 使用纹理图集（一张大贴图里包含了很多子贴图）来代替一系列单独的小贴图； 使用遮挡剔除（Occlusion Culling）当场景中有大量模型需要渲染时，应用遮挡剔除可实现减少DrawCall提升性能的效果； Lightmapping光照贴图技术，首先将需要进行光照贴图的游戏物体设置为Lightmap Static，其次将用于光照贴图的所有光源设置为Baked模式，最后进行烘焙； 静态物体尽量将法线渲染到贴图。 使用静态批处理，静态批处理允许游戏引擎尽可能多的去降低绘制任意大小的物体所产生的DrawCall 内存优化 使用压缩纹理 及时释放资源 减少使用的库]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GameFramework]]></title>
    <url>%2F2017%2F10%2F09%2FGame%20Framework%20%2F</url>
    <content type="text"><![CDATA[🤔 持续更新 GameFramework 是一个基于 Unity 5.3+ 引擎的游戏框架，主要对游戏开发过程中常用模块进行了封装，很大程度地规范开发过程、加快开发速度并保证产品质量。QQ群：216332935 在最新的 Game Framework 版本中，包含以下 17 个内置模块 数据结点 (Data Node) – 将任意类型的数据以树状结构的形式进行保存，用于管理游戏运行时的各种数据。 数据表 (Data Table) – 可以将游戏数据以表格（如 Microsoft Excel）的形式进行配置后，使用此模块使用这些数据表。数据表的格式是可以自定义的。 调试器 (Debugger) – 当游戏在 Unity 编辑器中运行或者以 Development 方式发布运行时，将出现调试器窗口，便于查看运行时日志、调试信息等。用户还可以方便地将自己的功能注册到调试器窗口上并使用。 下载 (Download) – 提供下载文件的功能，支持断点续传，并可指定允许几个下载器进行同时下载。更新资源时会主动调用此模块。 实体 (Entity) – 将游戏场景中，动态创建的一切物体定义为实体。此模块提供管理实体和实体组的功能，如显示隐藏实体、挂接实体（如挂接武器、坐骑，或者抓起另一个实体）等。实体使用结束后可以不立刻销毁，从而等待下一次重新使用。 事件 (Event) – 游戏逻辑监听、抛出事件的机制。Game Framework 中的很多模块在完成操作后都会抛出内置事件，监听这些事件将大大解除游戏逻辑之间的耦合。用户也可以定义自己的游戏逻辑事件。 有限状态机 (FSM) – 提供创建、使用和销毁有限状态机的功能，一些适用于有限状态机机制的游戏逻辑，使用此模块将是一个不错的选择。 本地化 (Localization) – 提供本地化功能，也就是我们平时所说的多语言。Game Framework 在本地化方面，不但支持文本的本地化，还支持任意资源的本地化，比如游戏中释放烟花特效也可以做出几个多国语言的版本，使得中文版里是“新年好”字样的特效，而英文版里是“Happy New Year”字样的特效。 网络 (Network) – 提供使用 Socket 长连接的功能，当前支持 TCP 协议，同时兼容 IPv4 和 IPv6 两个版本。用户可以同时建立多个连接与多个服务器同时进行通信，比如除了连接常规的游戏服务器，还可以连接语音聊天服务器。如果想接入 ProtoBuf 之类的协议库，只要派生自 Packet 类并实现自己的消息包类即可使用。 对象池 (Object Pool) – 提供对象缓存池的功能，避免频繁地创建和销毁各种游戏对象，提高游戏性能。除了 Game Framework 自身使用了对象池，用户还可以很方便地创建和管理自己的对象池。 流程 (Procedure) – 是贯穿游戏运行时整个生命周期的有限状态机。通过流程，将不同的游戏状态进行解耦将是一个非常好的习惯。对于网络游戏，你可能需要如检查资源流程、更新资源流程、检查服务器列表流程、选择服务器流程、登录服务器流程、创建角色流程等流程，而对于单机游戏，你可能需要在游戏选择菜单流程和游戏实际玩法流程之间做切换。如果想增加流程，只要派生自 ProcedureBase 类并实现自己的流程类即可使用。 资源 (Resource) – 为了保证玩家的体验，我们不推荐再使用同步的方式加载资源，由于 Game Framework 自身使用了一套完整的异步加载资源体系，因此只提供了异步加载资源的接口。不论简单的数据表、本地化字典，还是复杂的实体、场景、界面，我们都将使用异步加载。同时，Game Framework 提供了默认的内存管理策略（当然，你也可以定义自己的内存管理策略）。多数情况下，在使用 GameObject 的过程中，你甚至可以不需要自行进行 Instantiate 或者是 Destroy 操作。 场景 (Scene) – 提供场景管理的功能，可以同时加载多个场景，也可以随时卸载任何一个场景，从而很容易地实现场景的分部加载。 配置 (Setting) – 以键值对的形式存储玩家数据，对 UnityEngine.PlayerPrefs 进行封装。 声音 (Sound) – 提供管理声音和声音组的功能，用户可以自定义一个声音的音量、是2D声音还是3D声音，甚至是直接绑定到某个实体上跟随实体移动。 界面 (UI) – 提供管理界面和界面组的功能，如显示隐藏界面、激活界面、改变界面层级等。不论是 Unity 内置的 uGUI 还是其它类型的 UI 插件（如 NGUI），只要派生自 UIFormLogic 类并实现自己的界面类即可使用。界面使用结束后可以不立刻销毁，从而等待下一次重新使用。 Web 请求 (Web Request) – 提供使用短连接的功能，可以用 Get 或者 Post 方法向服务器发送请求并获取响应数据，可指定允许几个 Web 请求器进行同时请求。 GameFrameworkEntry（框架入口）GameFrameworkEntry使用链表来维护所有的GameFrameworkModule（框架模块），并提供对GameFrameworkModule的各种相关操作以及框架版本号信息 只有在获取模块时，对应模块不存在才会创建模块 创建模块时，根据模块优先级决定新模块在链表中的位置 轮询模块时，根据优先级决定轮询顺序（即正向遍历链表调用OnUpdate）（在**UGF中，由BaseComponent**来调用轮询方法） 所有的**Manager类都需要继承GameFrameworkModule**，并实现对应的IManager接口 GameEntry（游戏入口）示例程序Start Force里包含两个**GameEntry**，一个是UGF的，一个是Start Force的。Start Force在场景GameFramework中有一个Game Framework物体，上面挂载了Start Force的GameEntry脚本作为游戏入口 UGF的GameEntry使用链表来维护所有的GameFrameworkComponent（框架组件），并提供各种相关操作。 所有GameFrameworkComponent在Awake中调用UGF的GameEntry的RegisterComponent(GameFrameworkComponen)，将自身添加到UGF的GameEntry中的链表里 Start Force的GameEntry脚本持有所有GameFrameworkComponent的引用，被分成了3个部分，分别负责调用Start方法，初始化内置GameFrameworkComponent，初始化自定义GameFrameworkComponent GameFramework物体下有预制体Builtin（由UGF框架提供，原名GameFramework），该预制体下的所有子物体分别挂载了所有的内置GameFrameworkComponent。所有内置**GameFrameworkComponent都持有一个对应IManager接口的引用（可以视作GF的Manager在UGF**中的代理或实现），在初始化时通过GameFrameworkEntry来获取实例 自定义的**GameFrameworkComponent**需要另外创建一个空物体作为GameFramework的子物体，然后将自定义组件各自挂载到空物体下，作为其子物体 FSM（有限状态机）与Procedure（流程）流程是贯穿游戏运行时整个生命周期的有限状态机。框架用流程来处理所有的事情，不同的流程负责不同的工作，流程的切换是用有限状态机来实现的 FSM模块主要由状态，状态机，状态机管理器三部分组成 状态FsmState维护一个事件码与事件处理方法的字典，并提供各种对应操作 状态机Fsm继承FsmBase并实现IFsm接口，维护该状态机的所有状态与状态机数据，并提供各种对应操作 状态机管理器FsmManager维护所有状态机，并提供各种对应操作 Procedure模块主要由流程基类和流程管理器两部分组成 流程基类ProcedureBase继承自FsmState，可以理解为一种特殊的状态 流程管理器ProcedureManager持有FsmManager与自身的Fsm的引用，并提供对流程的相关操作 在**UGF中的ProcedureComponent**，主要负责读取创建好的流程类，然后调用ProcedureManager来创建并开始状态机 Event（事件）Event是游戏逻辑监听、抛出事件的机制。 Event模块由事件参数，事件池，事件管理器三部分组成 事件参数基类BaseEventArgs继承GameFrameworkEventArgs（还有另一种事件参数类也继承GameFrameworkEventArgs，那种事件不受**Event**模块管理） 事件池EventPool主要维护事件结点（Event）（Event是对BaseEventArgs的封装）的队列（该队列处理线程安全的事件抛出）与一个事件码与事件处理方法的字典，并提供各种对应操作 事件管理器EventManager是对EventPool里各种操作的代理 任务（Task）Task功能主要负责管理Web请求、资源的下载或加载的任务的执行 Task功能主要由任务，任务代理，任务池三部分组成 任务（ITask）存储了任务执行需要的数据 任务代理（ITaskAgent）是对ITask的代理类，提供对任务的各种对应操作 任务池TaskPool负责维护三种容器（可用任务代理，工作中任务代理，等待任务），并提供各种对应操作 DataNode（数据结点）DataNode将任意类型的数据以树状结构的形式进行保存，用于管理游戏运行时的各种数据数据结点的使用非常灵活，有以下三种使用方式：使用数据结点组件，直接通过绝对路径获取或设置数据；使用数据结点组件，通过参照某个数据结点和相对路径获取或设置数据；使用数据结点组件获取数据结点后，通过数据结点的接口进行更多操作。 DataNode模块由数据结点和数据结点管理器两部分组成 数据结点（DataNode）存储数据以及父结点、子结点的相关信息 数据结点管理器（DataNodeManager）管理根结点，并提供数据结点的相关操作 ObjectPool（对象池）ObjectPool提供对象缓存池的功能，避免频繁地创建和销毁各种游戏对象，提高游戏性能。 ObjectPool模块主要由对象基类，内部对象，对象池，对象池管理器三部分组成 对象基类（ObjectBase）是所有需要由ObjectPool模块管理的对象的父类 内部对象（Object）存储ObjectBase相关数据，并提供获取与回收的方法 对象池（ObjectPool）使用链表维护池子里的所有Object，并提供各种相关操作 对象池管理器（ObjectPoolManager）使用字典维护所有ObjectPool，并提供各种相关操作]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuaFramework]]></title>
    <url>%2F2017%2F09%2F13%2FLuaFramework%2F</url>
    <content type="text"><![CDATA[🤔 持续更新 LuaFramework是基于UGUI+tolua的简单游戏框架tolua作者:蒙哥，LuaFramework作者:骏擎想了解更多tolua及luaframework相关，可以关注博客uLua/cstoluatolua技术群:286510803 , tolua技术讨论群:434341400(已满) 543826216此文更新于 2018/5/1 ，这里讲的部分方法是所对应的最新版本 LuaFramework热更新流程 Main脚本调用启动函数Startup； 游戏管理器GameManager生成； GameManager调用CheckExtractResource函数，检查“数据目录”是否存在； 若“数据目录”不存在，说明是初次运行游戏，将“游戏包资源目录”的内容解压缩到“数据目录”； 若“数据目录”存在，检查是否需要从服务器下载资源，GameManager调用OnUpdateResource函数下载“网络资源地址”上的files.txt，然后与“数据目录”中文件的md5码做对比，更新有变化的文件； 更新完成后，GameManager调用OnResourceInited函数，启动Lua状态机，游戏开始。 调试：在Main.lua加入调试语句，在LuaManager的StartMain访问热更新增的Lua脚本，生成新打包的Prefab AppConst类的UpdateMode设为true，则从指定服务器下载资源，否则从本地“数据目录”获取。LuaBundleMode设为true，则从AssetBundle解压Lua脚本，否则直接读取项目脚本。可以打开AssetsLuaFrameworkEditorCustomSettings.cs看到所有可以供lua调用的类 添加新的Lua脚本到AssetBundle包 将Lua脚本存放到 Assets/LuaFramework/Lua 目录,因为，当按下LuaFramework-Build XXX Resources的时候，框架会自动将Assets/LuaFramework/Lua下的所有内容打成AssetBundle包，放在StreamingAssets下，可以发现，StreamingAssets文件夹下会有个Lua文件夹，里面放的就是Assets/LuaFramework/Lua在打包之后的结果 主要注意以下几点 1：打开StreamingAssets/Lua，会发现，这个文件夹下大致分为两部分，3rd文件夹，和一堆资源包其中，资源包的命名特点是对应路径信息的，例如lua_3rd_cjson和lua_3rd_cjson.unity3d这一组资源包,他对应着的是LuaFramework/Lua/3rd/cjson里面的Lua文件，这组资源包就是这个文件夹下的lua文件打包出来的结果。 2：StreamingAssets/Lua文件夹下，除了资源包外，还有一个3rd文件夹，可以打开Assets/LuaFramework/Lua/3rd 目录，然后打开其中一个，例如cjson的文件夹，可以发现，这文件夹里除了一些lua文件，还有一些txt配置文件或说明文件，所以，这个StreamingAssets/Lua/3rd文件夹下，放的就是这些lua文件外的文件资源 3：综上所述，如果我们要打包一个自定义的Lua文件（不是框架提供的Main.lua文件）的话，那么我们完全可以先在Assets/LuaFramework/Lua这个文件夹下，自定义一个专门存放我们编写的Lua文件的文件夹，当打包出来后，会发现，StreamingAssets/Lua下会有一个自定义的文件夹名.unity3d的一组资源包。 4：更改Lua入口，不用框架提供给我们的Main.lua这个文件：找到LuaManger这个类，然后找到StartMain()这个方法，只需要把lua.DoFile里面的参数修改为你自定义的lua文件名，然后LuaFunction main=lua.GetFunction(“Main”)这一行的括号内的参数，修改为作为入口且存在于你自定义的lua文件中的lua方法即可。不管是不是自己定义lua入口文件，最好都放在Assets/LuaFramework/Lua下，不要再另外加文件夹，因为放在Assets/LuaFramework/Lua路径下的所有lua文件都会直接一同打包在lua.unity3d资源包中，而程序设置好就是去这个包里读取lua的入口文件，除非你会改动lua入口文件的读取路径。 5：可以读取多个lua文件: 创建新的AssetBundle包 LuaFramework/Build XXX Resources 的功能全都写在了Assets/LuaFramework/Editor/Packager.cs，这个类中，以及跟随打包生成的 StreamingAssets/files 这个MD5校验码文件是如何生成，也是写在这个Packager.cs 文件中，所以，如果想打包一些此框架没提供的平台资源，可以到这个Packager 模仿增加对应的打包方法 打包函数的主体代码是 Packager.cs 中的 BuildAssetResource ， HandleExampleBundle ， AddBuildMap ， HandleLuaBundle ， HandleLuaFile 这五个方法 BuildAssetResource进行资源文件夹刷新，并且根据AppConst类里静态布尔属性设置情况的不同，分别调用HandleExampleBundle ， HandleLuaBundle ， HandleLuaFile 函数 HandleExampleBundle 作用是告诉使用者如何打包美术素材，框架格式是什么，如果有打包的美术资源，可以根据这个格式自定义一个方法，来进行打包，AddBuildMap 方法里第一个参数：打包出来的资源名字，这个名字是用 AppConst.ExtName （值为 unity3D ）作为后缀名。第二个参数：要打包的资源原本的格式， *.XXX 代表所有这种格式的资源。第三个参数：次框架是对指定路径的文件夹进行整体打包操作的，所以，第三个参数是你要打包的资源位于项目哪个文件夹中 所以综上所述，如果你要打包美术资源，先在项目中创建一个专门存放你自己的美术资源的文件夹，然后在 Packager.cs 中新建一个函数，里面的代码复制HandleExampleBundle，然后修改 AddBuildMap 参数，在完成上述步骤后，因为你的项目打包出来之前会删掉框架提供的示例场景，所以要把 AppConst 中的 ExampleMode 设置为 false ，最后在 Packager.cs 加入如图else代码，调用你的自定义打包函数 HandleLuaBundle ， HandleLuaFile 这两个函数是告诉用户如何将 Lua 文件打包成 AssetBundle 的，通常状况下不建议修改，因为功能已经很齐全了，当然，如果你想将这种功能实现应用到如 Xlua 中，可以去查看这两个函数是如何写的。 热更新主要由三部分组成： C# 与 Lua 的互相调用机制 Lua 文件的打包 网络传输，校验XLua ， ToLua ， ULua… 只是提供了 C# 与 Lua 的互相调用机制，并没有提供其余两者的功能实现，所以如果自己想开发个基于如 Xlua 这样的热更新框架，可以参照这个基于 ToLua 的框架 使用框架对下载的资源进行加载 在此之前，你要明白为何这个框架可以让lua脚本访问到C#的类 当你按下Lua/Clear wrap Files 时，会有弹出框，按下确定框架就会自动生成一堆Wrap结尾的文件，这个自动生成的文件所对应的就是一个叫 AppConst 的类，而这个框架就是让 Lua 通过访问这些自动生成的 wrap 的类来达到访问 C#类的目的 接下来就是资源的加载与生成： 在ResourceManager类中，框架提供了三个重载LoadPrefab方法其参数分别是： 要加载的AssetBundle包的名字 需要加载此包中哪些美术素材 回调方法（这个方法的参数列表有一个UnityEngine.Object[]类型的变量的，这个数组变量存的就是你所加载的美术资源） Lua中调用：12345678910111213function Main() print(&quot;logic start&quot;) LuaHelper = LuaFramework.LuaHelper resMgr = LuaHelper.GetResManager resMgr: LoadPrefab(&quot;myprefabs.unity3d&quot;, &#123;&quot;Sphere&quot;, &quot;Cube&quot;&#125;, LoadAssetBundle)endfunction LoadAssetBundle(go) for i = 0, go.Length - 1, 1 do UnityEngine.GameObject.Instantiate(go[i]) --go是userdata类型，遍历的时候必须用Length去取得长度 endend]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A*算法]]></title>
    <url>%2F2017%2F07%2F17%2FAstar%2F</url>
    <content type="text"><![CDATA[🤔 A*算法概述 该算法综合了 Best-First Search 和 Dijkstra 算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径。 与贪婪算法不同，贪婪算法适合动态规划，寻找局部最优解，不保证最优解。A*是静态网格中求解最短路最有效的方法。也是耗时的算法，不宜寻路频繁的场合。一般来说适合需求精确的场合。 比如在魔兽争霸中，使用鼠标点击地图上的一个位置，人物会根据最短路径到达你指定的地点，途中会自动避开障碍物 A*算法详解搜索区域 假设，如下图，要从A点移动到B点，但是这两点之间被一堵墙隔开。我们把要搜寻的区域划分成了正方形的格子，这是寻路的第一步，简化搜索区域。这个特殊的方法把我们的搜索区域简化为了二维数组。数组的每一项代表一个格子，它的状态就是可走和不可走。通过计算出从A到B需要走过哪些方格，就找到了路径。一旦路径找到了，人物便从一个方格的中心移动到另一个方格的中心，直至到达目的地。方格的中心点我们称为节点。当然，我们有可能把搜索区域划为任意多边形而不必须是正方形，而节点可以放在多变形的中心，也可以放在多边形的边上。 开始搜索 当我们把搜寻区域简化为一组可以量化的节点后，下一步便是查找最短路径。我们从起点开始，检查其相邻的方格，然后向四周扩展，直至找到目标为止。 我们需要经过这几个步骤： 从起点A开始，并将其加入到一个由方格组成的open list(开放列表)中。现在open list里只有一项，就是起点A，后面会逐渐加入更多的项。Open list里的格子路径可能会是沿途经过的，也有可能不经过。基本上open list是一个待检查的方格列表。 查看与起点A相邻的方格(忽略其中非法地形占领的方格)，把其中可走的或可到达的方格也加入到open list中。把起点A设置为这些方格的父节点。当我们在追踪路径时，这些父节点的内容是很重要的。 把A从open list中移除，加入到close list(封闭列表)中，close list中的每个方格都是现在不需要再关注的。 如下图，绿色的方格为起点，它的外框是亮蓝色，表示该方格被加入到了close list。与它相邻的黑色方格是需要被检查的，他们的外框是亮绿色。每个黑方格都有一个灰色的指针指向他们的父节点，这里是起点A。 之后，我们就需要从open list中选择一个与起点A相邻的方格。 路径选择 计算出组成路径方格的关键是这个等式：F = G + H其中， G = 从起点A移动到指定方格的移动代价，沿着到达该方格而生成的路径。 H = 从指定的方格移动到终点B的估算成本。这个通常被称为试探法，因为这仅是猜测。直到找到了路径我们才会知道真正的距离，因为途中有各种各样的障碍。最终路径产生的方式就是反复遍历open list，选择F值最小的方格。 G值 如上所述，G是从起点Ａ移动到指定方格的移动代价。在本例中，横向和纵向的移动代价为10，对角线的移动代价为14。（之所以使用这些数据，是因为对角移动距离是2的平方根，或者是近似的1.414倍的横向或纵向移动代价。使用10和14就是为了简单起见。）我们是沿着到达指定方格的路径来计算G值，那么计算出该方格G值的方法就是找出其父亲的G值，然后按父亲是直线方向还是斜线方向加上10或14。 H值 有很多方法可以估算H值。这里我们使用Manhattan方法，计算从当前方格横向或纵向移动到达目标所经过的方格数，忽略对角移动，然后把总数乘以10。之所以叫做Manhattan方法，是因为这很像统计从一个地点到另一个地点所穿过的街区数，而你不能斜向穿过街区。重要的是，计算H是，要忽略路径中的障碍物。这是对剩余距离的估算值，而不是实际值，因此才称为试探法。 把G和H相加便得到F。我们第一步的结果如下图所示。每个方格都标上了F，G，H的值，就像起点右边的方格那样，左上角是F，左下角是G，右下角是H。G = 10。是因为水平方向从起点到这个位置只有一个方格的距离。与起点直接相邻的上方，下方，左方的方格的G值都是10，对角线的方格G值都是14。 H值通过估算起点到终点(红色方格)的Manhattan距离得到，仅作横向和纵向移动，并忽略沿途墙壁。使用这种方式，起点右边的方格到终点有3个方格的距离，因此H = 30。这个方格上方的方格到终点有4个方格的距离(注意只计算横向和纵向距离)，因此H = 40。对于其他的方格，你可以用同样的方法知道H值是如何得来的。 每个方格的F值，就是把H与G相加 继续搜索 我们接着之上的步骤继续搜索，在上边搜索中，我们已经把把A从open list中移除，加入到close list(封闭列表)中，接下来我们从open list选择F值最小的节点然后继续如下操作 将其从open list里取出，放到close list中。 检查所有与其相邻的方格，忽略其中在close list中或是不可走的地形，如果方格不在open lsit中，则把它们加入到open list中，并把当前选定的方格作为新加入的方格的父节点。 如果某个相邻的方格已经在open list中，检查如果用新的路径（就是经过 C 的路径）到达它的话，G 值是否会更低一些，如果新的 G 值更低，那就把它的父方格改为目前选中的方格 C，然后重新计算它的 F 值和 G 值（H 值不需要重新计算，因为对于每个方块，H 值是不变的）。如果新的 G 值比较高，就说明经过 C 在到达 D 不是最优解，这时我们什么也不做。这里可能需要解释一下：首先参考下图 在我们最初的9个方格中，还有8个在open list中，起点被放入了close list中。在这些方格中，起点右边的格子(C)的F值40最小，因此我们选择这个方格作为下一个要处理的方格。它的外框用蓝线打亮。首先，我们把它从open list移到close list中。然后我们检查与它相邻的方格。它右边是墙壁，我们忽略。它左边的方格是起点，在close list中，我们也忽略。其他4个相邻的方格均在open list中，我们需要使用G值来判定经由这个方格到达那里的路径是否更好。先看方格D。它现在的G值为14。如果我们经由当前方格到达那里，G值将会为20(其中10为到达当前方格的G值，此外还要加上从当前方格纵向移动到上面方格的G值10)。显然20比14大，因此这不是最优的路径。看图就会明白。直接从起点沿对角线移动到那个方格比先横向移动再纵向移动要好。当把4个已经在open list中的相邻方格都检查后，没有发现经由当前方格的更好路径，因此我们不做任何改变。现在我们已经检查了当前方格的所有相邻的方格，并也对他们作了处理，是时候选择下一个待处理的方格了。 再次遍历我们的open list，现在它只有7个方格了，我们需要选择F值最小的那个。这次有两个方格的F值都54，从速度上考虑，选择最后加入open list的方格更快。这导致了在寻路过程中，当靠近目标时，优先使用新找到的方格的偏好。我们选择D方格 接下来我们再次检查相邻的方格，右边是墙，忽略。上边和左上都是close list，也忽略。而右下，也就是墙的下边，因为如果不穿越墙角的话，你不能直接从当前方格移动到那个方格，所以也忽略。这样还剩下三个方格，当前方格下面的两个方格还没有加入open list，所以把它们加入，同时把当前方格设为它们的父方格，并计算 F,H,G 值，而当前方格左边的方格，我们检查经由当前方格到达那里是否具有更小的G值。没有，所以不做任何处理。D被加入到关闭列表中，我们准备从open list中选择下一个待处理的方格。 依此循环，如果有方格重新计算后 G 值更小的，需要改变 G 值，且改变父节点。当发现open list中出现红色方块也就是终点的时候，结束循环。上图可以观察到，在起点下面两格的方格的父亲已经与前面不同了。之前它的G值是28并且指向它右上方的方格。现在它的G值为20，并且指向它正上方的方格。这在寻路过程中的某处发生，使用新路径时G值经过检查并且变得更低，因此父节点被重新设置，G和F值被重新计算。在这个例子中，这些改变并没有什么影响，但在其他一些场合中，这种改变会导致结果的很大变化。 最后就是如何确定实际路径。从终点开始，按着箭头向父节点移动，这样就被带回到了起点，这也就是你的路径。如下图所示。从起点A移动到终点B就是简单从路径上的一个方格的中心移动到另一个方格的中心，直至目标。 A*算法实例 上面我解释了整个A算法的流程，这里我通过一个简单的例子，演示一下A算法的使用 Point.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Point &#123; public Point Parent &#123; get; set; &#125; public float F &#123; get; set; &#125; public float G &#123; get; set; &#125; public float H &#123; get; set; &#125; public int X &#123; get; set; &#125; public int Y &#123; get; set; &#125; *//表示是否是障碍物* public bool isWall &#123; get; set; &#125; public Point (int x, int y, Point parent = null)&#123; this.X = x; this.Y = y; this.Parent = parent; isWall = false; &#125; public void UpdateParent(Point parent, float g)&#123; this.Parent = parent; this.G = g; F = G + H; &#125;&#125; Astar.cs12345678910111213141516171819202122public class Astar : MonoBehaviour &#123; private int mapWidth = 8; private int mapHeight = 6; private Point[,] map = new Point[8,6]; void Start () &#123; InitMap (); &#125; //初始化地图 private void InitMap()&#123; for (int x = 0; x &lt; mapWidth; x++) &#123; for (int y = 0; y &lt; mapHeight; y++) &#123; map [x, y] = new Point (x, y); &#125; &#125; map [4, 2].isWall = true; map [4, 3].isWall = true; map [4, 4].isWall = true; &#125;&#125; 下边是核心算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136private void FindPath(Point start, Point end)&#123; //核心算法 List&lt;Point&gt; openList = new List&lt;Point&gt;(); List&lt;Point&gt; closeList = new List&lt;Point&gt; (); openList.Add (start); while (openList.Count &gt; 0) &#123; Point point = FindMinFOfPoint (openList); openList.Remove (point); closeList.Add (point); List&lt;Point&gt; surroundPoints = GetSurroundPoints (point); PointsFilter (surroundPoints, closeList); foreach (Point surroundPoint in surroundPoints) &#123; if (openList.IndexOf (surroundPoint) &gt; -1) &#123; float nowG = CalcG (surroundPoint, point); if (nowG &lt; surroundPoint.G) &#123; surroundPoint.UpdateParent (point, nowG); &#125; &#125; else &#123; surroundPoint.Parent = point; CalcF (surroundPoint, end); openList.Add (surroundPoint); &#125; &#125; //判断 end 是否在“开启列表”中 if(openList.IndexOf(end) &gt; -1)&#123; break; &#125; &#125; &#125; //对集合进行过滤，因为添加到“关闭列表”中的点不需要被“开启列表”考虑 private void PointsFilter(List&lt;Point&gt; src, List&lt;Point&gt; closeList)&#123; foreach (Point p in closeList) &#123; if (src.IndexOf (p) &gt; -1) &#123; src.Remove (p); &#125; &#125; &#125; //得到周围的点 private List&lt;Point&gt; GetSurroundPoints(Point point)&#123; Point up = null, down = null, left = null, right = null; Point lu = null, ru = null, ld = null, rd = null; //添加上下左右四个点 if (point.Y &lt; mapHeight - 1)&#123; up = map [point.X, point.Y + 1]; &#125; if (point.Y &gt; 0) &#123; down = map [point.X, point.Y - 1]; &#125; if (point.X &gt; 0) &#123; left = map [point.X - 1, point.Y]; &#125; if (point.X &lt; mapWidth - 1) &#123; right = map [point.X + 1, point.Y]; &#125; //添加四个左上，左下，右上，右下四个点 if(up != null &amp;&amp; left != null)&#123; lu = map [point.X - 1, point.Y + 1]; &#125; if(up != null &amp;&amp; right != null)&#123; ru = map [point.X + 1, point.Y + 1]; &#125; if(down != null &amp;&amp; left != null)&#123; ld = map [point.X - 1, point.Y - 1]; &#125; if(down != null &amp;&amp; right != null)&#123; rd = map [point.X + 1, point.Y - 1]; &#125; List&lt;Point&gt; list = new List&lt;Point&gt; (); if (down != null &amp;&amp; down.isWall == false) &#123; list.Add (down); &#125; if (up != null &amp;&amp; up.isWall == false) &#123; list.Add (up); &#125; if (left != null &amp;&amp; left.isWall == false) &#123; list.Add (left); &#125; if (right != null &amp;&amp; right.isWall == false) &#123; list.Add (right); &#125; if (lu != null &amp;&amp; lu.isWall == false &amp;&amp; left.isWall == false &amp;&amp; up.isWall == false) &#123; list.Add (lu); &#125; if (ld != null &amp;&amp; ld.isWall == false &amp;&amp; left.isWall == false &amp;&amp; down.isWall == false) &#123; list.Add (ld); &#125; if (ru != null &amp;&amp; ru.isWall == false &amp;&amp; right.isWall == false &amp;&amp; up.isWall == false) &#123; list.Add (ru); &#125; if (rd != null &amp;&amp; rd.isWall == false &amp;&amp; right.isWall == false &amp;&amp; down.isWall == false) &#123; list.Add (rd); &#125; return list; &#125; //从“开启列表”中查找 F 值最小的 private Point FindMinFOfPoint(List&lt;Point&gt; openList)&#123; float f = float.MaxValue; Point temp = null; foreach (Point p in openList) &#123; if (p.F &lt; f) &#123; temp = p; f = p.F; &#125; &#125; return temp; &#125; private float CalcG(Point now, Point parent)&#123; return Vector2.Distance (new Vector2 (now.X, now.Y), new Vector2 (parent.X, parent.Y)) + parent.G; &#125; //计算 F 值 private void CalcF(Point now, Point end)&#123; //F = G + H float h = Mathf.Abs(end.X - now.X) + Mathf.Abs(end.Y - now.Y); float g = 0; //没有父节点，只有开始节点没有父节点 if (now.Parent == null) &#123; g = 0; &#125; else &#123; g = Vector2.Distance (new Vector2 (now.X, now.Y), new Vector2 (now.Parent.X, now.Parent.Y)) + now.Parent.G; &#125; float f = g + h; now.F = f; now.G = g; now.H = h; &#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ulysses]]></title>
    <url>%2F2017%2F05%2F13%2FUlysses%2F</url>
    <content type="text"><![CDATA[🤔 Markdown编辑器 Markdown是一种轻量级的「标记语言」，是由约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）创建的。它允许人们使用纯文本格式编写文档，然后根据其中的标记转换成有效的XHTML（常用的就是HTML）文档。 Ulysses的好处1.Write Anywhere at Anytime！ Ulysses 提供了苹果设备的全平台支持，基于 iCloud 和 Hand Off，你可以随时在 Mac、iPhone 和 iPad 上写作。 2.文档的集中管理 它把所有的文件都存放在了自己设计的文件系统里，你可以在 iCloud 里建立多个分组，每个分组下可以再建立子分组，也可以直接创建文章。 3.多文档输出 支持Markdown格式的文本、RTF、PDF文档输出 4.搜索功能 可以在应用内实现单篇文章搜索，组内搜索和全局搜索，当然，替换也是基本功能。 5.沉浸式写作 Ulysses 的 UI 做得美轮美奂，精良无匹。你能想到的各种模式主题，尤利西斯都提供了，打字机、突出显示当前行、黑暗主题、分页模式，等等。再一次，它在每个设备上的表现都如此出色，让人写不释手。 6.其他 Ulysses 还提供了一些有趣的特性，比如目标。当你为一篇文章设置了目标（字数）之后，文章的左上角就会出现一个进度圆环，随着文字的增加，当这个圆环充满的时候，你的文章差不多也写完了。 7.没有第七了 事实上 Ulysses 的功能比我说的要丰富的多，他们的 Blog 也写得十分有趣，有兴趣可以去读读。http://ulyssesapp.com/blog Ulysses与同类产品的对比Byword Byword没有Ulysses的多功能，没有分栏即时预览，不能导入外部 CSS 也不能更改输出样式。你能做的就是挑个喜欢的字体，找个喜欢的界面风格。Ulysses拥有Byword和iA Writer 优秀的专注模式————打字机滚动、突出显示当前行、显示段落号 iA Writer iA Writer 的写作体验依然是非常优秀的,其定制功能同样不逊于Ulysses,比较遗憾的是，iA Writer 的属性更像是一个写字板，而非是一个工作台。它的文档管理功能可以说是聊胜于无，在写完一篇文档之后，我都需要纠结一下这份文档需要放在电脑的哪个位置比较合适。Ulysses也支持Byword、iA Write所提倡的无干扰写作模式 Ulysses的缺点我个人认为Ulysses最大的缺点是，并没有实时预览功能，但如果加入实时预览就必然会抛弃无干扰写作模式，这一点见仁见智 Ulysses在诸多写作软件中，并未有很大的亮点和创新，但能在这些软件中脱颖而出的主要原因是其包含了，亦可认作是整合了其他「具有个性的」Markdown 编辑器的特色功能总之，Ulysses 足够优雅和简洁。它将写作之外的一切事物包揽，而你需要做的，只剩下创作]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC]]></title>
    <url>%2F2017%2F03%2F22%2FMVC%2F</url>
    <content type="text"><![CDATA[🤔 MVC概述 MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。 根据名称定义在MVC中可以分为三层，也就是Model 层，View 层，Controller 控制层 Model(模型) :“数据模型”（Model）用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。模型有对数据直接访问的权力，例如对数据库的访问。模型不依赖视图和控制器，也就是说，模型不关心它会被如何显示或是如何被操作。但是模型中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此模型的视图必须事先在此模型上注册，从而，视图可以了解在数据模型上发生的改变。 View(视图) :视图层能够实现数据有目的的显示（理论上，这不是必需的）。在视图中一般没有程序上的逻辑。为了实现视图上的刷新功能，视图需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。 Controller(控制器) :控制器起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。事件包括用户的行为和数据模型上的改变 下图展现了MVC不同层的类型和功能： Unity中的MVC 在unity中常见并在大型项目中常用到的的ui框架有基于MVVM的uFrame、基于MVC的PureMVC和基于MVCS的StrangeIoC，三者各有优劣。关于这三个框架及MVVM和MVCS的结构我们之后再说，这里通过代码来了解一下在Unity中的MVC： mvc核心控制类:MVC.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118using UnityEngine;using System;using System.Collections.Generic;/// &lt;summary&gt;/// puremvc核心控制器/// &lt;/summary&gt;public class MVC : MonoBehaviour&#123; private static Dictionary&lt;string, Model&gt; Models = new Dictionary&lt;string, Model&gt;(); private static Dictionary&lt;string, View&gt; Views = new Dictionary&lt;string, View&gt;(); private static Dictionary&lt;string, Type&gt; Commands = new Dictionary&lt;string, Type&gt;(); #region Model Method /// &lt;summary&gt; /// 注册model /// &lt;/summary&gt; /// &lt;param name=&quot;model&quot;&gt;Model.&lt;/param&gt; public static void RegisterModel(Model model) &#123; if (!Models.ContainsKey(model.Name)) &#123; Models.Add(model.Name, model); &#125; &#125; public static void UnRegisterModel(Model model) &#123; if (Models.ContainsKey(model.Name)) &#123; Models.Remove(model.Name); &#125; &#125; public static T GetModel&lt;T&gt;(string name) where T : Model &#123; foreach (string n in Models.Keys) &#123; if (n == name) &#123; return Models[name] as T; &#125; &#125; return null; &#125; #endregion #region View Method /// &lt;summary&gt; /// 注册view /// &lt;/summary&gt; /// &lt;param name=&quot;view&quot;&gt;View.&lt;/param&gt; public static void RegisterView(View view) &#123; if (!Views.ContainsKey(view.Name)) &#123; Views.Add(view.Name, view); &#125; &#125; public static void UnRegisterView(View view) &#123; if (Views.ContainsKey(view.Name)) &#123; Views.Remove(view.Name); view.RegisterNotification(); &#125; &#125; public static T GetView&lt;T&gt;(string name) where T : View &#123; foreach (string n in Views.Keys) &#123; if (n == name) &#123; return Views[name] as T; &#125; &#125; return null; &#125; #endregion #region Command Method /// &lt;summary&gt; /// 注册controller /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;Name.&lt;/param&gt; /// &lt;param name=&quot;type&quot;&gt;Type.&lt;/param&gt; public static void RegisterCommand(string name, Type type)&#123; if (!Commands.ContainsKey(name))&#123; Commands.Add(name, type); &#125; &#125; public static void UnRegisterCommand(string name, Type type)&#123; if(Commands.ContainsKey(name))&#123; Commands.Remove(name); &#125; &#125; public static void HandleNotifition(string name, object data = null)&#123; //判断事件是否存在，如果存在则实例化对象并执行事件 if(Commands.ContainsKey(name))&#123; Controller command = Activator.CreateInstance(Commands[name]) as Controller; command.Execute(data); &#125; //判断视图是否关注该事件，如果关注则执行事件 foreach(View view in Views.Values)&#123; if (view.ContainsNotification(name))&#123; view.HandleNotification(name, data); &#125; &#125; &#125; #endregion&#125; Model基类Model.cs:123456789101112131415161718192021using UnityEngine;/// &lt;summary&gt;/// mvc中的Model基类/// &lt;/summary&gt;public abstract class Model&#123; /// &lt;summary&gt; /// model的名字 /// &lt;/summary&gt; /// &lt;value&gt;The name.&lt;/value&gt; public abstract string Name &#123; get; &#125; /// &lt;summary&gt; /// 发送通知 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;事件名称&lt;/param&gt; /// &lt;param name=&quot;data&quot;&gt;事件执行参数&lt;/param&gt; public virtual void SendNotification(string name, object data = null)&#123; MVC.HandleNotifition(name, data); &#125; &#125; View基类View.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using UnityEngine;using System.Collections.Generic;/// &lt;summary&gt;/// mvc中的View基类/// &lt;/summary&gt;public abstract class View&#123; /// &lt;summary&gt; /// View的名字 /// &lt;/summary&gt; /// &lt;value&gt;The name.&lt;/value&gt; public abstract string Name &#123; get; &#125; /// &lt;summary&gt; /// 发送通知 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;事件名称&lt;/param&gt; /// &lt;param name=&quot;data&quot;&gt;事件执行参数&lt;/param&gt; public virtual void SendNotification(string name, object data = null)&#123; MVC.HandleNotifition(name, data); &#125; /// &lt;summary&gt; /// 获取模型model /// &lt;/summary&gt; /// &lt;returns&gt;The model.&lt;/returns&gt; /// &lt;param name=&quot;name&quot;&gt;model名称&lt;/param&gt; /// &lt;typeparam name=&quot;T&quot;&gt;The 1st type parameter.&lt;/typeparam&gt; public T GetModel&lt;T&gt;(string name) where T : Model&#123; return MVC.GetModel&lt;T&gt;(name) as T; &#125; /// &lt;summary&gt; /// 保存通知 /// &lt;/summary&gt; private List&lt;string&gt; InterestNotification = new List&lt;string&gt;(); public virtual void RegisterNotification()&#123; &#125; public bool ContainsNotification(string name)&#123; return InterestNotification.Contains(name); &#125; /// &lt;summary&gt; /// 处理事件 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;事件名称&lt;/param&gt; /// &lt;param name=&quot;data&quot;&gt;事件参数&lt;/param&gt; public virtual void HandleNotification(string name, object data = null)&#123; &#125;&#125; Controller基类Controller.cs12345678910111213141516171819202122232425262728293031323334353637383940414243using UnityEngine;using System;/// &lt;summary&gt;/// mvc中的Controller基类/// &lt;/summary&gt;public abstract class Controller&#123; /// &lt;summary&gt; /// Controller的名字 /// &lt;/summary&gt; /// &lt;value&gt;The name.&lt;/value&gt; public abstract string Name &#123; get; &#125; public T GetModel&lt;T&gt;(string name) where T : Model &#123; return MVC.GetModel&lt;T&gt;(name); &#125; public T GetView&lt;T&gt;(string name) where T : View &#123; return MVC.GetView&lt;T&gt;(name); &#125; public void RegisterView(View view) &#123; MVC.RegisterView(view); &#125; public void RegisterModel(Model model) &#123; MVC.RegisterModel(model); &#125; public void RegisterCommand(string name, Type type) &#123; MVC.UnRegisterCommand(name, type); &#125; /// &lt;summary&gt; /// 发送通知 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;事件执行参数&lt;/param&gt; public abstract void Execute(object data = null);&#125; 写在最后 这里介绍了unity中MVC的简单使用，于我看来，在游戏项目中MVC框架并不完全适用，MVC是ui专用的模式，游戏不同于web前端，不同类型的游戏其架构相差非常之大（比如棋牌类游戏，rpg游戏，moba类游戏，跑酷类游戏之间的差别） ，所以游戏中MVC不同的模块很难有非常清晰的定义。并不是说MVC在游戏项目中完全没用，但只有它还远远不够。游戏项目最合理的方式是由主程根据项目需求制定一套新的结构和各部分的依赖关系，并事先想好各部分的扩展和通信方式。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产品经理基础手册]]></title>
    <url>%2F2016%2F12%2F08%2FProduct%20Manager%2F</url>
    <content type="text"><![CDATA[🤔 什么是产品经理产品经理（Product Manager）是 企业中专门负责产品管理的职位，产品经理负责市场调查并根据用户的需求，确定开发何种产品，选择何种技术、商业模式等。并推动相应产品的开发组织，他还要根据产品的生命周期，协调 研发、运营、营销等，确定和组织实施相应的产品策略，以及其他一系列相关的产品管理活动。（来源：产品经理_百度百科） 产品部门在公司中的组织结构 完整的产品案例 产品经理发展线 产品经理职责 从兴趣爱好聊出痛点发现用户需求 找到目标用户找到有该需求的其他用户 开始需求调研进行需求调研，输出需求调研问卷，记录用户调研明细，输出访谈结果汇总 提炼用户画像把用户访谈结果抽象成三类用户画像，方便研发理解需求的直接使用对象 写竞品分析撰写竞品分析，了解满足当前需求的竞品情况，看看是否有，以及有的话，如何借鉴和超越 用思维导图梳理功能结构化梳理满足需求功能的更为细分的子功能，并找老大做需求优先级排期 绘制流程图梳理满足用户需求方案的整个流程，细化业务逻辑 画产品原型结合自己的前期的准备和产品知识储备，输出符合要求的产品原型 写需求文档撰写用于研发、测试、UI等同事开展后续工作的需求说明文档 需求评审发会议邮件，约项目组相关人一起进行需求宣讲 项目管理对子项目功能(大功能)进行排期，找相关同事进行确认。 提测、验收和上线确人设计稿，解决在开发过程中遇到的问题，提测后，进行验收功能是否正确，UI还原是否正确，确认完成后，准备上线的物料，提App包到各大应用商店 版本迭代关注数据和用户反馈，收集整理下个版本的需求，列出优先级，准备下一版本的需求 以上是产品经理的基本介绍，在之后我会抽时间通过一个我之前做的完整的案例以详细介绍产品经理的职责和技能。]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>PM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GameManager]]></title>
    <url>%2F2016%2F10%2F18%2FGameManager%2F</url>
    <content type="text"><![CDATA[🤔 这片文章主要介绍之前的项目中使用过的各类管理器 组建单例模版类1234567891011121314151617181920212223using UnityEngine;/// &lt;summary&gt;/// 组建单例模版/// &lt;/summary&gt;public class AD_MonoSingleten&lt;T&gt; : MonoBehaviour where T : MonoBehaviour&#123; private static T instance; public static T Instance&#123; get&#123; if (instance == null)&#123; GameObject go = new GameObject(typeof(T).Name); instance = go.AddComponent&lt;T&gt;(); &#125; return instance; &#125; set &#123; instance = value; &#125; &#125; protected virtual void Awake()&#123; Instance = this as T; &#125;&#125; 预制体管理器1234567891011121314151617181920212223242526272829303132333435363738394041424344using UnityEngine;/// &lt;summary&gt;/// 文件名：AD_PrefabManager/// 功能说明：预制体管理器/// &lt;/summary&gt;public class AD_PrefabManager : AD_Singleton&lt;AD_PrefabManager&gt; &#123; /// &lt;summary&gt; /// 实例化预制体 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public GameObject Spawn(AD_PrefabType type, string name, Vector3 pos, Quaternion rotation, Transform parent) &#123; string path = AD_ResourcesPath.GetPath(type, name); GameObject obj = AD_ResourceFactory.Instance.Load&lt;GameObject&gt;(path); if(obj != null) &#123; obj = GameObject.Instantiate(obj) as GameObject; obj.transform.SetParent(parent); obj.transform.localPosition = pos; obj.transform.localRotation = rotation; &#125; else &#123; Debug.LogError(&quot;perfab not find !&quot;); &#125; return obj; &#125; public GameObject Spawn(AD_PrefabType type, string name) &#123; return Spawn(type, name, Vector3.zero, Quaternion.identity, null); &#125; public GameObject Spawn(AD_PrefabType type, string name, Transform parent) &#123; return Spawn(type, name, Vector3.zero, Quaternion.identity, parent); &#125;&#125; 音效管理器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using UnityEngine;/// &lt;summary&gt;/// 文件名:AD_AudioManager/// 功能说明:音效管理器/// &lt;/summary&gt;[RequireComponent(typeof(AudioSource))]public class AD_AudioManager : AD_MonoSingleton&lt;AD_AudioManager&gt; &#123; private AudioSource mAudioSource; protected override void Awake() &#123; base.Awake(); mAudioSource = GetComponent&lt;AudioSource&gt;(); // 跨场景不销毁 DontDestroyOnLoad(gameObject); &#125; /// &lt;summary&gt; /// 播放背景音乐 /// &lt;/summary&gt; /// &lt;param name=&quot;audioName&quot;&gt;&lt;/param&gt; public void PlayBGAudio(string audioName) &#123; // 加载背景音乐 AudioClip bg = AD_ResourceFactory.Instance.Load&lt;AudioClip&gt;(AD_ResourcesPath.Audio_Environment + audioName); // 设置背景音乐 mAudioSource.clip = bg; // 循环播放 mAudioSource.loop = true; // 播放 mAudioSource.Play(); &#125; /// &lt;summary&gt; /// 播放指定音乐 /// &lt;/summary&gt; /// &lt;param name=&quot;audioName&quot;&gt;&lt;/param&gt; public void PlayAudio(AD_AudioType type, string audioName) &#123; string path = AD_ResourcesPath.GetPath(type, audioName); AudioClip clip = AD_ResourceFactory.Instance.Load&lt;AudioClip&gt;(path); AudioSource.PlayClipAtPoint(clip, transform.position); &#125;&#125; 场景加载管理器12345678910111213141516171819using System.Collections;using System.Collections.Generic;/// &lt;summary&gt;/// 文件名：AD_Singleton/// 功能说明：场景单例/// &lt;/summary&gt;public class AD_Singleton&lt;T&gt; where T : new() &#123; /// &lt;summary&gt; /// 场景单例 /// &lt;/summary&gt; private static readonly T instance = new T(); public static T Instance &#123; get&#123; return instance; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System.Collections;using UnityEngine;using UnityEngine.SceneManagement;/// &lt;summary&gt;/// 文件名:AD_ScenesManager/// 功能说明:场景加载管理器/// &lt;/summary&gt;public class AD_ScenesManager : AD_Singleton&lt;AD_ScenesManager&gt; &#123; private string sceneName; // 切换场景名 private AsyncOperation asyncOper; private float progress; // 进度 public float Progress&#123; get&#123; return progress; &#125; &#125; /// &lt;summary&gt; /// 场景切换 /// &lt;/summary&gt; /// &lt;param name=&quot;sceneName&quot;&gt;Scene name.&lt;/param&gt; public void LoadScene(string sceneName)&#123; this.sceneName = sceneName; SceneManager.LoadScene (ScenesName.SceneLoading); &#125; /// &lt;summary&gt; /// 异步加载场景 /// &lt;/summary&gt; /// &lt;returns&gt;The scene async.&lt;/returns&gt; public IEnumerator LoadSceneAsync()&#123; asyncOper = SceneManager.LoadSceneAsync (sceneName); //阻止场景自动跳转 AudioManager.Instance.PlayBG(&quot;Sound_SceneLoding&quot;); asyncOper.allowSceneActivation = false; //场景过度进度 while(asyncOper.progress &lt; 0.9f)&#123; progress += 0.005f; yield return 0; &#125; while (progress &lt; 1) &#123; progress += 0.005f; yield return 0; &#125; AudioManager.Instance.PlayBG (&quot;Sound_Background&quot;); asyncOper.allowSceneActivation = true; yield return 0; &#125;&#125; 有限状态机管理器，对象池管理器 在之前有写过]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>应用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shader入门]]></title>
    <url>%2F2016%2F09%2F07%2FShaderBasics%2F</url>
    <content type="text"><![CDATA[🤔 渲染流水线流水线 在了解什么是渲染流水线前先看一下现实生活中的流水线。 流水线是一种工业上的生产方式，每一个生产单位只专注处理一个片段的工作。比如一个制造手机的工厂，一台手机的制造流程可以分为四个步骤，第一步，制作外壳；第二步，制作屏幕模组；第三步，制作主板；第四步组装手机并进行产品包装。在没有流水线时，只有在每台手机四个工序完成后才能开始制作下一台，这是非常耗时的。如果我们加入流水线，虽然制作一台手机任需要四个步骤，但不需要从头到尾完成全部步骤，而是每个步骤由专人来完成，所有步骤并行进行。使用流水线的好处在于可以提高单位时间的生产量。 渲染流水线 流水线的概念同样可以用于计算机的图像渲染中。计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以观察到的图像。这个工作通常有CPU和GPU共同完成 渲染流水线通常分为三个阶段：应用阶段 ———&gt; 几何阶段 ————&gt; 光栅化阶段 应用阶段： 这个阶段有应用主导，通常由CPU负责实现。这一阶段开发者有三个主要任务，首先，需要准备好场景数据（摄相机位置、视锥体、模型和光源等）。其次，为了提高渲染性能，需要做粗粒度的剔除工作。最后，需要设置好每个模型的渲染状态（使用的材质、使用的纹理、使用的Shader等）这一阶段最重要的输出是渲染所需的几何信息，即渲染图元。 几何阶段：几何阶段主要用于处理所有和我们绘制的几何相关的事情。几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作。这个阶段可以进一步分成更小的流水线阶段。几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。 光栅化阶段： 这一阶段会使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。 CPU和GPU之间的通信渲染流水线的起点是CPU，即应用阶段。大致可分为三个阶段： 把数据加载到显存中：所有渲染所需的数据都需要从硬盘中加载到系统内存，然后，网格和纹理等数据又被加载到显存。 设置渲染状态：这些状态定义了场景中的网格如何被渲染。 调用Draw Call：Draw Call实际上就是一个命令，它的发起方是CPU,接收方是GPU，这个命令仅仅会指向一个需要被渲染的图元列表，而不会再包含任何材质信息。 当给定一个Draw Call时，GPU就会根据渲染状态和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的像素。 GPU流水线 当GPU从CPU得到渲染命令后，就会进行一系列的流水线操作，最终把图元渲染到屏幕上（就是上边的调用Draw Call） 对于渲染流水线中的后两个阶段（几何阶段和光栅化阶段）开发者无法拥有绝对的控制权，其实现的载体是GPU。GPU通过实现流水线化，大大加快了渲染速度，虽然我们无法完全控制这两个阶段的实现细节，但其向开发者开放了很多控制权。下图展示了不同流水线阶段以及它们的可配执性和可编程性： 顶点着色器 顶点着色器是流水线的第一个阶段，它的输入来自于CPU。顶点着色器的处理单位是顶点,输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或销毁任何顶点，并无法得到顶点与顶点之间的关系 顶点着色器是完全可编程的，它通常用于实现顶点的坐标变换和逐顶点光照。 坐标变换：就是对顶点的坐标进行某种变换—把顶点坐标从模型空间转换到齐次裁剪空间。我们可以通过坐标变换来模拟水面、面料等。 曲面细分着色器 是一个可选的着色器，主要用于细分图元。 几何着色器 是一个可选的着色器，可用于执行逐图元的着色操作，或者被用于产生更多的图元。 裁剪 这一阶段是可配置的。目的是把那些不在视野内的顶点裁剪掉，并剔除某些三角形图元的面片。 一个图元与摄像机视野的关系有3种：完全在视野内、部分在视野内、完全在视野外。 完全在视野内的图元会继续传递给下一个流水线阶段 完全在视野外的图元不会继续向下传递 部分在视野内的图元需要做裁剪处理 和顶点着色器不同的是，这一步是不可编程的。我们无法通过编程来控制裁剪的过程，而是硬件上的固定操作。 屏幕映射 这一阶段是不可配置和编程的，负责把每个图元的坐标转换成屏幕坐标。 这一步输入的坐标仍然是三维坐标系下的坐标。屏幕映射的任务是把每个图元的x和y坐标转换到屏幕坐标系下。 屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素的距离。 一个需要注意的地方，屏幕坐标系在OpenGL和DirectX中，OpenGL把屏幕左下角当作最小的窗口坐标值，DirectX则在屏幕左上角为最小窗口坐标值。 三角形设置 由这一步开始进入光栅化阶段。 上一阶段输出的信息是屏幕坐标系下的顶点位置以及和它们相关的其他信息，如深度值、法线方向、视角方向等。 光栅化阶段的目标：1.计算每个图元覆盖了哪些像素 2.为这些像素计算它们的颜色 三角形设置作为光栅化的第一个阶段，会计算出光栅化一个三角网格所需要的信息。上一阶段的输出是三角网格的顶点，如果想得到整个三角网格的覆盖情况，就必须计算每条边上的像素坐标，为了计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个得到三角形边界表示方式的过程就是三角形设置。 它的输出是为下一个阶段做准备 三角形遍历 三角形遍历阶段将会检查每个像素是否被一个三角网格所覆盖。如果被覆盖，就会生成一个片元。而这样一个找到哪些像素被三角网格覆盖的过程，就是三角形遍历，这个阶段也被称为扫描变换。 三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角网格覆盖了哪些像素，并使用三角网格三个顶点的顶点信息对整个覆盖区域的像素进行插值。 这一步的输出就是得到一个片元序列。 一个片元并不是真正意义上的像素，而是包含了很多状态的几何，这些状态用于计算每个像素的最终颜色 片元着色器 片元着色器是另一个非常重要的可编程着色器阶段，在DirectX中，片元着色器被称为像素着色器。 片元着色器的输入就是上一阶段对顶点信息插值得到的结果，更具体点说，是根据从顶点着色器中输出的数据插值得到的。而其的输出是一个或者多个颜色值。 这一阶段可以完成很多重要的渲染技术，如纹理采样，但是它的局限在于，它仅可以影响单个片元。 逐片元操作 这是渲染流水线的最后一步，这一步骤的目的是：合并 这一阶段有几个主要任务： 决定每个片元的可见性。这涉及了深度测试、模板测试等 如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说是混合。 这一阶段是高度可配置性的 这个阶段首先需要解决每个片元的可见性问题。这需要进行一系列的测试。 片元 ——&gt; 模版测试 ——&gt; 深度测试 ——&gt; 混合 ——&gt; 颜色缓冲区 深度测试和模版测试的简化流程图： 模板测试：如果开启了模板测试，GPU会首先读取模板缓冲区中该片元位置的模板值，然后将该值和读取到的参考值（可以开发者自己指定）进行比较，开发者可以设定成小于时舍弃或者大于等于时舍弃该片元。模板测试通常用于限制渲染的区域，另外模板测试还有别的高级用法，如渲染阴影，轮廓渲染。 深度测试：如果一个片元幸运的通过了模板测试，那么就会进行深度测试，如果开启了深度深度，GPU就会把该片的深度值和已经存在于深度缓冲区中的深度值进行比较，这个比较函数也是由开发者设定的，可以选择大于此值时舍弃也可以选择小于等于此值时舍弃。但通常这个比较函数是小于等于的关系，这是因为我们我们总想只显示出离摄像机最近的物体，而那些被其他物体遮挡的片元就不需要出现在屏幕上。和模板测试不同的是，如果一个片元没有通过深度测试，他就没有权利修改深度缓冲区中的值。而如果通过了测试，开发者可以通开启/关闭深度写入来决定是否要利用这个片元的深度值覆盖缓冲区中的值。 合并：我们所讨论的渲染过程是一个物体接着一个物体渲染到屏幕上，而每个像素的颜色信息被存储在一个名为颜色缓冲的地方，因此当我们执行这次渲染时，颜色缓冲中往往已经有了上次渲染的颜色结果，那么我们是使用这次渲染得到的颜色完全覆盖掉之前的结果，还是进行其他处理，这就是合并需要解决的问题。对于不透明物体，开发者可以关闭混合操作，这样片元着色器计算得到的颜色值就会直接覆盖掉颜色缓冲区中的像素值。但对于半透明的物体，我们就需要开启混合操作来让这个物体看起来是半透明的。混合操作是高度可配置的，开发者可以选择开启/关闭混合功能。如果开启了，GPU会取出源颜色和目标颜色，将两种颜色进行混合。源颜色是指片元着色器得到的颜色值，而目标颜色则是已经存在于颜色缓冲区中的颜色值。 总结真正实现渲染流水线的过程远比描述的要复杂，但Unity为我们封装了很多功能，我们只需要在一个Unity Shader设置一些输入、编写顶点着色器和片元着色器、设置一些状态，就可以实现大部分屏幕效果。在最新的unity中还集成了Shader蓝图工具供开发者使用。]]></content>
      <categories>
        <category>Shader</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-近邻算法]]></title>
    <url>%2F2016%2F09%2F02%2FKNN%2F</url>
    <content type="text"><![CDATA[🤔 K-近邻算法概述 简单的说，K-近邻算法采用测量不同特征值之间的距离方法进行分类。 优点：精度高，对异常值不敏感，无数据输入假定。 缺点：计算复杂度高，空间复杂度高。 适用范围：数值型和标称型。 K-近邻算法工作原理存在一个样本数据集合，可以称之为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最邻近数据的分类标签。一般来说我们只选择样本数据集中前k个最相似的数据，这就是K-近邻算法中k的由来，通常k是不大于20的整数。最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类。 下边是K-近邻算法的一个示例： 收集数据：提供文本文件。 准备数据：使用python解析文件。 分析数据：使用Matplotlib画二维扩散图 训练算法： 测试算法：以文件部分数据作为测试样本 使用算法：可以输入特征数据以判断是否正确 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&apos;&apos;&apos;在文件datingTest中存放着某约会网站的样本数据，每个样本占据一行，共1000行。其中主要包括： 每年飞行里程数， 玩游戏所耗时间比， 每周消费的冰淇淋数。&apos;&apos;&apos;from numpy import *import osimport operatorimport matplotlibimport matplotlib.pyplot as pltfrom os import listdirdef file2matrix(filename): &apos;&apos;&apos; 处理输入格式 :param filename: :return: &apos;&apos;&apos; fr = open(filename) numberOfLines = len(fr.readlines()) #得到文件行数 returnMat = zeros((numberOfLines,3)) #创建返回的NumPy矩阵 classLabelVector = [] fr = open(filename) index = 0 for line in fr.readlines(): #解析文件数据到列表 line = line.strip() listFromLine = line.split(&apos;\t&apos;) returnMat[index,:] = listFromLine[0:3] classLabelVector.append(int(listFromLine[-1])) index += 1 return returnMat,classLabelVectordef autoNorm(dataSet): &apos;&apos;&apos; 将每列的最小值放在变量minVals中，最大值放在maxVals中， 其中dataSet.min（0）中的参数0使得函数可以从列中取最小值，而不是选取当前行最小值。 然后函数计算可能的取之范围，并创建新的矩阵返回 :param dataSet: :return: &apos;&apos;&apos; minVals = dataSet.min(0) maxVals = dataSet.max(0) ranges = maxVals - minVals normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] normDataSet = dataSet - tile(minVals, (m, 1)) normDataSet = normDataSet / tile(ranges, (m, 1)) #特征值相除 return normDataSet, ranges, minValsdef classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] #距离计算 diffMat = tile(inX, (dataSetSize,1)) - dataSet sqDiffMat = diffMat**2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 sortedDistIndicies = distances.argsort() classCount=&#123;&#125; for i in range(k): #选择距离最小的k个点 voteIlabel = labels[sortedDistIndicies[i]] classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 #排序 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]def datingClassTest(): &apos;&apos;&apos; 使用file2matrix和autoNorm函数从文件中读取数据并转换为归一化特征值 接着计算测试向量的数量，决定normMat向量中哪些数据用于测试，哪些用于训练样本 然后将两部分数据输入到原始分类起函数classify0， 最后计算错误率并返回 :return: &apos;&apos;&apos; hoRatio = 0.10 datingDataMat, datingLabels = file2matrix(&apos;datingTestSet.txt&apos;) normMat, range, minvals = autoNorm(datingDataMat) m = normMat.shape[0] numTestVecs = int(m*hoRatio) errorCount = 0.0 for i in range(numTestVecs): classifierResult = classify0(normMat[i,:], normMat[numTestVecs:m, :], datingLabels[numTestVecs:m], 3) print(&quot;the classifier came back with : %d, the real answer is : %d&quot; %(classifierResult, datingLabels[i])) if(classifierResult != datingLabels[i]): errorCount += 1.0 print(&quot;the total error rate is : %f&quot; %(errorCount/float(numTestVecs)))datingClassTest()datingDataMat, datingLabels = file2matrix(&apos;datingTestSet2.txt&apos;)fig = plt.figure()ax = fig.add_subplot(111)ax.scatter(datingDataMat[:,1], datingDataMat[:,2])ax.scatter(datingDataMat[:, 1], datingDataMat[:, 2], 15.0*array(datingLabels), 15.0*array(datingLabels))plt.show()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2016%2F08%2F19%2FObserver%2F</url>
    <content type="text"><![CDATA[🤔 观察者模式概述 观察者模式也被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 观察者模式用处 将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。 观察者模式角色 抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。 具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。 抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。 具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。 以下是观察者模式的类图： 观察者模式实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/// &lt;summary&gt; /// 抽象主题类 /// &lt;/summary&gt; public abstract class Subject &#123; private List&lt;Observer&gt; observers = new List&lt;Observer&gt;(); /// &lt;summary&gt; /// 增加观察者 /// &lt;/summary&gt; /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt; public void Attach(Observer observer) &#123; observers.Add(observer); &#125; /// &lt;summary&gt; /// 移除观察者 /// &lt;/summary&gt; /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt; public void Detach(Observer observer) &#123; observers.Remove(observer); &#125; /// &lt;summary&gt; /// 向观察者（们）发出通知 /// &lt;/summary&gt; public void Notify() &#123; foreach (Observer o in observers) &#123; o.Update(); &#125; &#125; &#125; /// &lt;summary&gt; /// 抽象观察者类，为所有具体观察者定义一个接口，在得到通知时更新自己 /// &lt;/summary&gt; public abstract class Observer &#123; public abstract void Update(); &#125; /// &lt;summary&gt; /// 具体观察者或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。 /// &lt;/summary&gt; public class ConcreteSubject : Subject &#123; private string subjectState; /// &lt;summary&gt; /// 具体观察者的状态 /// &lt;/summary&gt; public string SubjectState &#123; get &#123; return subjectState; &#125; set &#123; subjectState = value; &#125; &#125; &#125; /// &lt;summary&gt; /// 具体观察者，实现抽象观察者角色所要求的更新接口，已是本身状态与主题状态相协调 /// &lt;/summary&gt; public class ConcreteObserver : Observer &#123; private string observerState; private string name; private ConcreteSubject subject; /// &lt;summary&gt; /// 具体观察者用一个具体主题来实现 /// &lt;/summary&gt; public ConcreteSubject Subject &#123; get &#123; return subject; &#125; set &#123; subject = value; &#125; &#125; public ConcreteObserver(ConcreteSubject subject, string name) &#123; this.subject = subject; this.name = name; &#125; /// &lt;summary&gt; /// 实现抽象观察者中的更新操作 /// &lt;/summary&gt; public override void Update() &#123; observerState = subject.SubjectState; Console.WriteLine(&quot;The observer&apos;s state of &#123;0&#125; is &#123;1&#125;&quot;, name, observerState); &#125; &#125; 观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。但此例中依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者在c#中的可以使用事件委托来彻底解除通知者和观察者之间的耦合。委托：委托是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法有相同的行为。委托方法可以像其它任何方法一样，具有参数和返回值。委托可以看作是对函数（方法）的的抽象，是函数的“类”，委托的实例代表一个（或多个）具体的函数，它可以是多播的。事件：事件基于委托，为委托提供了一种发布/订阅机制。事件的订阅与取消与我们刚才讲的观察者模式中的订阅与取消类似，只是表现形式有所不同。在观察者模式中，订阅使用方法Attach（）来进行；在事件的订阅中使用“+=”。类似地，取消订阅在观察者模式中用Dettach（），而事件的取消用“-=”。 Unity中的观察者模式 在unity游戏开发中，最常用到的设计模式就是单例模式和观察者模式，在之上已经介绍了观察者模式，以下通过代码来直观的了解在unity中，观察者模式的简单使用。 RPG游戏中我们拥有自己的角色，角色通常拥有名称和等级，以下程序中通过观察者模式实现点击鼠标左键增加角色等级。 ShowPlayer.cs12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 观察者/// &lt;/summary&gt;public class ShowPlayer : MonoBehaviour &#123; public PlayerData mHero; //设置通知者 public void SetData(PlayerData player)&#123; mHero = player; //事件绑定 mHero.Register(Show); Show(); &#125; private void Show()&#123; print(&quot;Hero&apos;s name &quot; + mHero.name); print(&quot;Hero&apos;s rank &quot; + mHero.Rank); &#125;&#125; PlayerData.cs123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 数据类/// 通知者/// &lt;/summary&gt;public class PlayerData : SubjestBase &#123; public string name; private string rank; public string Rank&#123; get&#123; return rank; &#125; set&#123; rank = value; Notified(); &#125; &#125;&#125; SubjestBase.cs123456789101112131415161718192021222324using System;/// &lt;summary&gt;/// 通知者基类/// &lt;/summary&gt;public class SubjestBase &#123; private event Action eventHander; //注册事件 public void Register(Action func)&#123; eventHander += func; &#125; //删除事件 public void UnRegister(Action func)&#123; eventHander -= func; &#125; //发送通知 public void Notified()&#123; if(eventHander != null)&#123; eventHander(); &#125; &#125;&#125; PlayerSelectCtrl.cs1234567891011121314151617181920212223242526using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 控制器/// &lt;/summary&gt;public class PlayerSelectCtrl : MonoBehaviour &#123; private ShowPlayer showPlayer; private PlayerData player; void Start () &#123; showPlayer = GetComponentInChildren&lt;ShowPlayer&gt;(); player = User.GetPlayer(); showPlayer.SetData(player); &#125; //数据更新 void Update () &#123; if(Input.GetMouseButtonDown(0))&#123; player.Rank = (int.Parse(player.Rank) + 1).ToString(); &#125; &#125;&#125; User.cs12345678910111213using System.Collections;using System.Collections.Generic;using UnityEngine;public class User&#123; public static PlayerData GetPlayer()&#123; PlayerData player = new PlayerData(); player.name = &quot;Yu&quot;; player.Rank = &quot;7&quot;; return player; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FSM状态机]]></title>
    <url>%2F2016%2F08%2F15%2FFSM%2F</url>
    <content type="text"><![CDATA[🤔 有限状态机，FSM，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的模型。 在unity中我们经常会判断一个人物（或怪物）的运动状态，如巡逻、追逐、攻击、死亡等，然后作出相应的操作，这些时候我们可以使用有限状态机来集中管理这些状态。 为了解决上述问题，我们经常会使用fsm有限状态机、分层有限状态机以及行为树，这里我们主要了解fsm有限状态机 FSM在unity中算是一个比较重要的技巧 以下是我写的一个简单的FSM状态机的例子：FSMState.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106using System.Collections;using System.Collections.Generic;using UnityEngine.SceneManagement;using UnityEngine;public abstract class FSMState &#123; //字典，字典中每一项都记录了一个“转换-状态”对 的信息 protected Dictionary&lt;Transition, FSMStateID&gt; map = new Dictionary&lt;Transition, FSMStateID&gt;(); //状态编号ID protected FSMStateID stateID; public FSMStateID ID &#123; get &#123; return stateID; &#125; &#125; //目标点位置 protected Vector3 destPos; //巡逻点数组 protected Transform[] waypoints; //旋转速度 protected float curRotSpeed; //移动速度 protected float curSpeed; //发现对面的距离 public float chaseDistance&#123; get &#123; if (SceneManager.GetActiveScene ().name == &quot;PTMainScenes&quot;) return 10f; else return 1f;&#125;&#125; //攻击距离 public float SRAttackDistance&#123; get &#123; if (SceneManager.GetActiveScene ().name == &quot;PTMainScenes&quot;) return 1f; else return 0.1f;&#125;&#125; //目标点距离 protected float arriveDistance&#123; get &#123; if (SceneManager.GetActiveScene ().name == &quot;PTMainScenes&quot;) return 2f; else return 0.2f;&#125;&#125; /// &lt;summary&gt; /// 向字典添加项，每项是一个&quot;转换--状态&quot;对 /// &lt;/summary&gt; /// &lt;param name=&quot;transition&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt; public void AddTransition(Transition transition, FSMStateID id) &#123; if (map.ContainsKey(transition)) &#123; return; &#125; map.Add(transition, id); &#125; /// &lt;summary&gt; /// 从字典中删除项 /// &lt;/summary&gt; /// &lt;param name=&quot;trans&quot;&gt;&lt;/param&gt; public void DeleteTransition(Transition trans) &#123; if (map.ContainsKey(trans)) &#123; map.Remove(trans); return; &#125; &#125; /// &lt;summary&gt; /// 通过查询字典，确定在当前状态下，发生trans转换时，应该转换到新的状态编号并返回 /// &lt;/summary&gt; /// &lt;param name=&quot;trans&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public FSMStateID GetOutputState(Transition trans) &#123; return map[trans]; &#125; /// &lt;summary&gt; /// 用来确定是否需要转换到其他状态，应该发生哪个转换 /// &lt;/summary&gt; /// &lt;param name=&quot;player&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;npc&quot;&gt;&lt;/param&gt; public abstract void Reason(Transform hero, Transform monster); /// &lt;summary&gt; /// 定义了在本状态的角色行为，移动，动画等 /// &lt;/summary&gt; /// &lt;param name=&quot;player&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;npc&quot;&gt;&lt;/param&gt; public abstract void Act(Transform hero, Transform monster); public virtual void Enter (Transform hero, Transform monster)&#123; &#125; /// &lt;summary&gt; /// 选择随机逻辑点 /// &lt;/summary&gt; public void FindNextPoint()&#123; int rndIndex = Random.Range (0, waypoints.Length); Vector3 rndPosition = Vector3.zero; destPos = waypoints [rndIndex].position + rndPosition; &#125;&#125; FSM.cs123456789101112131415161718192021222324252627282930313233343536using UnityEngine;using System.Collections;public class FSM : MonoBehaviour&#123; // 玩家位置 protected Transform playerTranform; // 下一个巡逻点 protected Vector3 destPos; // 巡逻点表单 protected GameObject[] pointList; // protected float elapsedTime; protected virtual void Initialize()&#123;&#125; protected virtual void FSMUpdate()&#123;&#125; protected virtual void FSMFixedUpdate()&#123;&#125; // 初始化 void Start()&#123; Initialize (); &#125; //循环执行 void Update()&#123; FSMUpdate (); &#125; void FixedUpdate()&#123; FSMFixedUpdate (); &#125;&#125; AdvancedFSM.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103using System.Collections;using System.Collections.Generic;using UnityEngine;public enum Transition&#123; SawPlayer = 0, //是否看到玩家 ReachPlayer, //接近玩家 LostPlayer, //玩家离开视线 NoHealth, //死亡&#125;public enum FSMStateID&#123; Patrolling = 0, // 巡逻编号 Chasing, // 追踪编号 Attacking, Dead, // 死亡编号&#125;public class AdvancedFSM : FSM&#123; //FSM中的所有状态组成的列表 private List&lt;FSMState&gt; fsmStates; //当前状态的编号 private FSMStateID currentStateID; public FSMStateID CurrentStateID &#123; get &#123; return currentStateID; &#125; &#125; //当前状态 private FSMState currentState; public FSMState CurrentState &#123; get &#123; return currentState; &#125; &#125; public AdvancedFSM() &#123; //新建一个空的状态列表 fsmStates = new List&lt;FSMState&gt;(); &#125; /// &lt;summary&gt; ///向状态列表中加入一个新的状态 /// &lt;/summary&gt; public void AddFSMState(FSMState fsmState) &#123; if (fsmState == null) &#123; Debug.LogError(&quot;状态为空&quot;); return; &#125; if (fsmStates.Count == 0) &#123; fsmStates.Add(fsmState); currentState = fsmState; currentStateID = fsmState.ID; return; &#125; foreach (FSMState state in fsmStates) &#123; if (state.ID == fsmState.ID) &#123; Debug.LogError(&quot;状态已存在&quot;); return; &#125; &#125; //如果要加入的状态不在列表中，将它加入列表 fsmStates.Add(fsmState); &#125; //从状态中删除一个状态 public void DeleteState(FSMStateID fsmState) &#123; // 搜索整个状态列表，如果要删除的状态在列表中，那么将它移除，否则报错 foreach (FSMState state in fsmStates) &#123; if (state.ID == fsmState) &#123; fsmStates.Remove(state); return; &#125; &#125; Debug.LogError(&quot;要删除的状态不在列表中&quot;); &#125; /// &lt;summary&gt; /// 根据当前状态，和参数中传递的转换，转换到新状态 /// &lt;/summary&gt; public void PerformTransition(Transition trans) &#123; FSMStateID id = currentState.GetOutputState(trans); currentStateID = id; foreach (FSMState state in fsmStates) &#123; if (state.ID == currentStateID) &#123; currentState = state; break; &#125; &#125; &#125;&#125; AttackState.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System.Collections;using UnityEngine;public class AttackState : FSMState &#123; Animator monsterAnimator; AnimatorStateInfo stateInfo; public AttackState(Transform[] wp)&#123; waypoints = wp; stateID = FSMStateID.Attacking; curRotSpeed = 12; curSpeed = 100; FindNextPoint (); &#125; public override void Enter (Transform hero, Transform monster) &#123; monsterAnimator = monster.GetComponent&lt;Animator&gt;(); &#125; public override void Reason(Transform hero, Transform monster)&#123; if (hero != null) &#123; stateInfo = monsterAnimator.GetCurrentAnimatorStateInfo (0); float dist = Vector3.Distance (monster.position, hero.position); if (dist &gt;= SRAttackDistance &amp;&amp; dist &lt; chaseDistance) &#123; if (stateInfo.IsName (&quot;skill&quot;) &amp;&amp; stateInfo.normalizedTime % 1 &gt; 0.9f) monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.SawPlayer); &#125; else if (dist &gt;= chaseDistance) &#123; if (stateInfo.IsName (&quot;skill&quot;) &amp;&amp; stateInfo.normalizedTime % 1 &gt; 0.9f) monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer); &#125; &#125;else&#123; monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer); &#125; &#125; public override void Act(Transform hero, Transform monster)&#123; destPos = hero.position; Quaternion targetRotation = Quaternion.LookRotation (destPos - monster.position); monster.rotation = Quaternion.Slerp (monster.rotation, targetRotation, Time.deltaTime * curRotSpeed);// CharacterController controller = monster.GetComponent&lt;CharacterController&gt; ();// controller.SimpleMove (monster.transform.forward * Time.deltaTime * curSpeed); //播放攻击动画// Animator monsterAnimator = monster.GetComponent&lt;Animator&gt;(); monsterAnimator.SetBool (&quot;isRun&quot;,false); monsterAnimator.SetBool (&quot;isAttack&quot;, true); monsterAnimator.SetBool (&quot;isWalk&quot;, false); monsterAnimator.SetBool (&quot;isDead&quot;, false); &#125;&#125; ChaseState.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using System.Collections;using System.Collections.Generic;using UnityEngine.AI;using UnityEngine;using UnityEngine.SceneManagement;public class ChaseState : FSMState &#123; NavMeshAgent monsterAgent; Animator monsterAnimator; public ChaseState(Transform[] wp)&#123; waypoints = wp; stateID = FSMStateID.Chasing; curRotSpeed = 7; curSpeed = 300; FindNextPoint (); &#125; public override void Enter (Transform hero, Transform monster) &#123; monsterAnimator = monster.GetComponent&lt;Animator&gt;(); monsterAgent = monster.GetComponent&lt;NavMeshAgent&gt; (); &#125; public override void Reason(Transform hero, Transform monster)&#123; if (hero != null) &#123; destPos = hero.position; float dist = Vector3.Distance (monster.position, destPos); if (dist &lt;= SRAttackDistance) &#123; AudioManager.Instance.PlayFXAudio (&quot;Sound_MonsterPatrolPlayer&quot;, monster.transform.position); monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.ReachPlayer); &#125; else if (dist &gt;= chaseDistance) &#123; monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer); &#125; &#125;else&#123; monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.LostPlayer); &#125; &#125; public override void Act(Transform hero, Transform monster)&#123; destPos = hero.position; Quaternion targetRotation = Quaternion.LookRotation (destPos - monster.position); monster.rotation = Quaternion.Slerp (monster.rotation, targetRotation, Time.deltaTime * curRotSpeed); monsterAgent.SetDestination (destPos); if(SceneManager.GetActiveScene().name == &quot;PTMainScenes&quot;) monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 2; if (SceneManager.GetActiveScene ().name == &quot;ARMainScenes&quot;) monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 0.2f; //播放奔跑动画 monsterAnimator.SetBool (&quot;isRun&quot;,true); monsterAnimator.SetBool (&quot;isAttack&quot;, false); monsterAnimator.SetBool (&quot;isWalk&quot;, false); monsterAnimator.SetBool (&quot;isDead&quot;, false); &#125;&#125; PatrolState.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using System.Collections;using System.Collections.Generic;using UnityEngine.AI;using UnityEngine;using UnityEngine.SceneManagement;public class PatrolState : FSMState&#123; Animator monsterAnimator; NavMeshAgent monsterAgent; public PatrolState(Transform[] wp)&#123; waypoints = wp; stateID = FSMStateID.Patrolling; curRotSpeed = 6; curSpeed = 200; FindNextPoint (); &#125; public override void Enter (Transform hero, Transform monster) &#123; &#125; public override void Reason(Transform hero, Transform monster)&#123; if (hero != null) &#123; if (Vector3.Distance (monster.position, hero.position) &lt;= chaseDistance) &#123; AudioManager.Instance.PlayFXAudio (&quot;Sound_MonsterSawPlayer&quot;, monster.transform.position); monster.GetComponent&lt;MonsterAIController&gt; ().SetTransition (Transition.SawPlayer); &#125; &#125; &#125; public override void Act(Transform hero, Transform monster)&#123; monsterAgent = monster.GetComponent&lt;NavMeshAgent&gt; (); if (!(monsterAgent.pathPending || monsterAgent.remainingDistance &gt; (monsterAgent.stoppingDistance + 0.5f) || monsterAgent.velocity != Vector3.zero)) &#123; FindNextPoint (); &#125;// Physics.SphereCastAll ();// Quaternion targetRotation = Quaternion.LookRotation (destPos - monster.position);// monster.rotation = Quaternion.Slerp (monster.rotation, targetRotation, Time.deltaTime * curRotSpeed); monsterAgent.SetDestination (destPos); if(SceneManager.GetActiveScene().name == &quot;PTMainScenes&quot;) monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 1; if (SceneManager.GetActiveScene ().name == &quot;ARMainScenes&quot;) monster.GetComponent&lt;NavMeshAgent&gt; ().speed = 0.1f; //播放行走动画 monsterAnimator = monster.GetComponent&lt;Animator&gt; (); monsterAnimator.SetBool (&quot;isRun&quot;,false); monsterAnimator.SetBool (&quot;isAttack&quot;, false); monsterAnimator.SetBool (&quot;isWalk&quot;, true); monsterAnimator.SetBool (&quot;isDead&quot;, false); &#125;&#125; DeadState.cs12345678910111213141516171819202122232425262728293031323334using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class DeadState : FSMState &#123; public DeadState()&#123; stateID = FSMStateID.Dead; &#125; public override void Enter (Transform hero, Transform monster) &#123; monster.GetComponent&lt;NavMeshAgent&gt; ().enabled = false; monster.GetComponent&lt;Collider&gt; ().enabled = false; GameManager.Instance.AddScore (); &#125; public override void Reason(Transform hero, Transform monster)&#123; &#125; public override void Act (Transform hero, Transform monster)&#123; //播放死亡动画 Animator monsterAnimator = monster.GetComponent&lt;Animator&gt;(); monsterAnimator.SetBool (&quot;isRun&quot;,false); monsterAnimator.SetBool (&quot;isAttack&quot;, false); monsterAnimator.SetBool (&quot;isWalk&quot;, false); monsterAnimator.SetBool (&quot;isDead&quot;, true); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity对象池]]></title>
    <url>%2F2016%2F08%2F10%2FunityObject%20pool%2F</url>
    <content type="text"><![CDATA[🤔 对象池的含义很简单，我们将对象储存在一个“池”中，当需要它时可以重复使用，而不是创建一个新的对象，尽可能的复用内存中已经驻留的资源来减少频繁的IO耗时操作。有经验的开发者在程序设计时就会做一个规范，其中包含了角色池，怪物池，特效池，经验池等。 以下代码中是一个简单的对象池示例，具体的说明在代码注释中呈现： Singleton.cs12345678910111213using UnityEngine;/// &lt;summary&gt;/// 单例模版类/// &lt;/summary&gt;public class Singleton&lt;T&gt; where T : new() &#123; private static readonly T instance = new T(); public static T Instance&#123; get&#123; return instance; &#125; &#125;&#125; MonoSingleton.cs1234567891011121314151617181920212223using UnityEngine;/// &lt;summary&gt;/// 组建单例模版/// &lt;/summary&gt;public class MonoSingleten&lt;T&gt; : MonoBehaviour where T : MonoBehaviour&#123; private static T instance; public static T Instance&#123; get&#123; if (instance == null)&#123; GameObject go = new GameObject(typeof(T).Name); instance = go.AddComponent&lt;T&gt;(); &#125; return instance; &#125; set &#123; instance = value; &#125; &#125; protected virtual void Awake()&#123; Instance = this as T; &#125;&#125; IReusable.cs12345678910using UnityEngine;/// &lt;summary&gt;/// 对象池接口/// &lt;/summary&gt;public interface IReusable&#123; //对象从对象池实例化的回调 void OnSpawned(); //对象返回对象池后的回调 void OnUnSpawned();&#125; PrefabType.cs12345public enum PrefabType&#123; None = 0, Effects = 1, Roles = 2,&#125; ResourcesPath.cs123456789101112131415161718192021using UnityEngine;/// &lt;summary&gt;/// 资源路径/// &lt;/summary&gt;public class ResourcesPath &#123; public const string prefabRoles = &quot;Prefabs/Roles/&quot;; public const string prefabEffects = &quot;Prefabs/Effects/&quot;; public static string GetPath(PrefabType type, string name)&#123; string path = string.Empty; switch(type)&#123; case PrefabType.Effects: path = ResourcesPath.prefabEffects + name; break; case PrefabType.Roles: path = ResourcesPath.prefabRoles + name; break; &#125; return path; &#125;&#125; ResourceFactory.cs12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 资源工厂/// &lt;/summary&gt;public class ResourceFactory : Singleton&lt;ResourceFactory&gt; &#123; /// &lt;summary&gt; /// 加载资源 /// &lt;/summary&gt; /// &lt;returns&gt;The load.&lt;/returns&gt; /// &lt;param name=&quot;path&quot;&gt;Path.&lt;/param&gt; /// &lt;typeparam name=&quot;T&quot;&gt;The 1st type parameter.&lt;/typeparam&gt; public T Load&lt;T&gt;(string path) where T : Object&#123; T res = Resources.Load&lt;T&gt;(path); return res; &#125;&#125; ObjectPoolMananger.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 对象池管理器/// &lt;/summary&gt;public class ObjectPoolMananger : MonoSingleten&lt;ObjectPoolMananger&gt; &#123; private Dictionary&lt;string, ObjectPool&gt; mPools = new Dictionary&lt;string, ObjectPool&gt;(); //从对象池取出对象 public GameObject Spawn(PrefabType type, string name, Vector3 pos = default(Vector3), Quaternion rotation = default(Quaternion), Transform parent = null)&#123; ObjectPool pool = null; if (!mPools.ContainsKey(name))&#123; //创建对象池 RegisterPoll(type, name); &#125; pool = mPools[name]; //从对象池中取出一个物体 GameObject obj = pool.Spawn(); obj.transform.SetParent(parent); obj.transform.localPosition = pos; obj.transform.localRotation = rotation; return obj; &#125; /// &lt;summary&gt; /// 对象池回收物体 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;Object.&lt;/param&gt; public void UnSpawn(GameObject obj)&#123; foreach(ObjectPool pool in mPools.Values)&#123; if (pool.Contains(obj))&#123; pool.UnSpawn(obj); return ; &#125; &#125; Destroy(obj); &#125; /// &lt;summary&gt; /// 回收所有物体 /// &lt;/summary&gt; public void UnSpwanAll()&#123; foreach(ObjectPool pool in mPools.Values)&#123; pool.UnSpawnAll(); &#125; &#125; private void RegisterPoll(PrefabType type, string name)&#123; string path = ResourcesPath.GetPath(type, name); GameObject prefab = ResourceFactory.Instance.Load&lt;GameObject&gt;(path); ObjectPool pool = new ObjectPool(prefab); mPools.Add(name, pool); &#125;&#125; ObjectPool.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 对象池类/// &lt;/summary&gt;public class ObjectPool&#123; //预制体 private GameObject mPrefab; //对象池 private List&lt;GameObject&gt; objectlist = new List&lt;GameObject&gt;(); //构造方法 public ObjectPool(GameObject prefab)&#123; this.mPrefab = prefab; &#125; /// &lt;summary&gt; /// 取出物体 /// &lt;/summary&gt; /// &lt;returns&gt;The spawn.&lt;/returns&gt; public GameObject Spawn()&#123; GameObject obj = null; for (int i = 0; i &lt; objectlist.Count; i++)&#123; if (!objectlist[i].activeSelf)&#123;//如果有物体隐藏 obj = objectlist[i]; break; &#125; &#125; if (obj == null)&#123; obj = GameObject.Instantiate(mPrefab); objectlist.Add(obj); &#125; obj.SetActive(true); //获取对象池接口 IReusable reusable = obj.GetComponent&lt;IReusable&gt;(); if (reusable != null)&#123; reusable.OnSpawned(); &#125; return obj; &#125; /// &lt;summary&gt; /// 回收物体 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;Object.&lt;/param&gt; public void UnSpawn(GameObject obj)&#123; obj.SetActive(false); IReusable reusable = obj.GetComponent&lt;IReusable&gt;(); if (reusable != null)&#123; reusable.OnUnSpawned(); &#125; &#125; public void UnSpawnAll() &#123; foreach (GameObject obj in objectlist)&#123; obj.SetActive(false); IReusable reusable = obj.GetComponent&lt;IReusable&gt;(); if (reusable != null)&#123; reusable.OnUnSpawned(); &#125; &#125; &#125; /// &lt;summary&gt; /// 判断物体是否存在 /// &lt;/summary&gt; /// &lt;returns&gt;The contains.&lt;/returns&gt; /// &lt;param name=&quot;obj&quot;&gt;Object.&lt;/param&gt; public bool Contains(GameObject obj)&#123; return objectlist.Contains(obj); &#125;&#125; DestoryObjectPool.cs1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 对象池销毁/// &lt;/summary&gt;public class DestoryObjectPool : MonoBehaviour, IReusable &#123; public float mDestoryTime = 0.1f; public void OnSpawned() &#123; Invoke(&quot;UnSpawn&quot;, mDestoryTime); &#125; public void OnUnSpawned() &#123; &#125; private void UnSpawn()&#123; ObjectPoolMananger.Instance.UnSpawn(gameObject); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity单例]]></title>
    <url>%2F2016%2F08%2F07%2FUnitySingleton%2F</url>
    <content type="text"><![CDATA[🤔 什么是单例 单例模式是开发中运用最广泛的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 其中要注意： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 为什么要使用单例 在我们的整个游戏生命周期当中，有很多对象从始至终有且只有一个。这个唯一的实例只需要生成一次，并且直到游戏结束才需要销毁。 单例模式一般应用于管理器类，或者是一些需要持久化存在的对象。 单例的实现 c#单例的实现(如果在unity中不需要使用monobeheviour，也可以这样来创建单例)：1234567891011121314151617181920public sealed class Singleton &#123; private static volatile Singleton instance; private static object syncRoot = new Object(); public static Singleton Instance &#123; get &#123; if (instance == null) &#123; lock (syncRoot) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125; &#125; &#125; unity需要使用monobeheviour的单例实现：1234567891011121314151617181920212223242526272829public sealed class SingletonMoBehaviour: MonoBehaviour&#123; private static volatile SingletonBehaviour instance; private static object syncRoot = new Object(); public static SingletonBehaviour Instance &#123; get &#123; if (instance == null) &#123; lock (syncRoot) &#123; if (instance == null) &#123; SingletonBehaviour[] instances = FindObjectsOfType&lt;SingletonBehaviour&gt;(); if (instances != null)&#123; for (var i = 0; i &lt; instances.Length; i++) &#123; Destroy(instances[i].gameObject); &#125; &#125; GameObject go = new GameObject(&quot;_SingletonBehaviour&quot;); instance = go.AddComponent&lt;SingletonBehaviour&gt;(); DontDestroyOnLoad(go); &#125; &#125; &#125; return instance; &#125; &#125; &#125; 其中主要区别在于monobeheviour不能使用构造函数进行实例化，只能挂载到GameObject上，而切换场景时当前场景的GameObject都会被销毁，所以单例也会被销毁，这里我们就需要DontDestroyOnLoad处理，同时为了保持场景当中只有一个实例，我们要对当前场景中的单例进行判断，如果存在其他的实例，则应该将其全部删除。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫基础]]></title>
    <url>%2F2016%2F07%2F20%2Fpythonweb%20crawler%2F</url>
    <content type="text"><![CDATA[🤔 爬虫介绍 爬虫是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本（来自于百度百科）。 爬虫的目的 爬取数据，进行市场调研和商业分析。 作为机器学习、数据挖掘的原始数据 爬取优质的资源 爬虫实现过程 大部分爬虫都是按“发送请求——获得页面——解析页面——抽取并储存内容”这样的流程来进行，这其实也是模拟了我们使用浏览器获取网页信息的过程。 python中的相关包 在python中有很多爬虫可用的包，如：urllib、requests、bs4、scrapy、pyspider 等 简单的爬虫实例 以下是一个简单的python爬虫，爬取前程无忧上成都unity3d的人才需求：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193import osfrom pprint import pprintimport csvfrom collections import Counterfrom bs4 import BeautifulSoupimport requestsimport matplotlib.pyplot as pltimport jiebafrom wordcloud import WordCloudclass JobSpider: def __init__(self): self.company = [] self.text = &quot;&quot; self.headers = &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;,&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos; &#125; def job_spider(self): &quot;&quot;&quot; 爬虫入口 &quot;&quot;&quot; #要抓取的页面 url = &quot;https://search.51job.com/list/090200,000000,0000,00,9,99,Unity3d,2,1.html?lang=c&amp;stype=&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;providesalary=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=&quot; urls = [url.format(p) for p in range(1, 100)] for url in urls: #请求网页 r = requests.get(url, headers=self.headers).content #解析 bs = BeautifulSoup(r, &apos;lxml&apos;).find(&quot;div&quot;, class_=&quot;dw_table&quot;).find_all(&quot;div&quot;, class_=&quot;el&quot;) for b in bs: try: href, post = b.find(&apos;a&apos;)[&apos;href&apos;], b.find(&apos;a&apos;)[&apos;title&apos;] locate = b.find(&apos;span&apos;, class_=&apos;t3&apos;).text salary = b.find(&apos;span&apos;, class_=&apos;t4&apos;).text d = &#123; &apos;href&apos;: href, &apos;post&apos;: post, &apos;locate&apos;: locate, &apos;salary&apos;: salary &#125; self.company.append(d) except Exception: pass def post_require(self): &quot;&quot;&quot; 爬取职位描述 &quot;&quot;&quot; for c in self.company: r = requests.get( c.get(&apos;href&apos;), headers=self.headers).content.decode(&apos;gbk&apos;) bs = BeautifulSoup(r, &apos;lxml&apos;).find( &apos;div&apos;, class_=&quot;bmsg job_msg inbox&quot;).text s = bs.replace(&quot;举报&quot;, &quot;&quot;).replace(&quot;分享&quot;, &quot;&quot;).replace(&quot;\t&quot;, &quot;&quot;).strip() self.text += s print(self.text) with open(os.path.join(&quot;data&quot;, &quot;post_require.txt&quot;), &quot;w+&quot;) as f: f.write(self.text) @staticmethod def post_desc_counter(): &quot;&quot;&quot; 职位描述统计 &quot;&quot;&quot; post = open(os.path.join(&quot;data&quot;, &quot;post_require.txt&quot;), &quot;r&quot;).read() # 使用 jieba 分词 file_path = os.path.join(&quot;data&quot;, &quot;user_dict.txt&quot;) jieba.load_userdict(file_path) seg_list = jieba.cut(post, cut_all=False) counter = dict() for seg in seg_list: counter[seg] = counter.get(seg, 1) + 1 counter_sort = sorted( counter.items(), key=lambda value: value[1], reverse=True) pprint(counter_sort) with open(os.path.join(&quot;data&quot;, &quot;post_pre_desc_counter.csv&quot;), &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.writer(f) f_csv.writerows(counter_sort) def post_counter(self): &quot;&quot;&quot; 职位统计 &quot;&quot;&quot; lst = [c.get(&apos;post&apos;) for c in self.company] counter = Counter(lst) counter_most = counter.most_common() pprint(counter_most) with open(os.path.join(&quot;data&quot;, &quot;post_pre_counter.csv&quot;), &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.writer(f) f_csv.writerows(counter_most) def post_salary_locate(self): &quot;&quot;&quot; 招聘大概信息，职位，薪酬以及工作地点 &quot;&quot;&quot; lst = [] for c in self.company: lst.append((c.get(&apos;salary&apos;), c.get(&apos;post&apos;),c.get(&apos;title&apos;), c.get(&apos;href&apos;), c.get(&apos;locate&apos;))) pprint(lst) file_path = os.path.join(&quot;data&quot;, &quot;post_salary_locate.csv&quot;) with open(file_path, &quot;w+&quot;) as f: f_csv = csv.writer(f) f_csv.writerows(lst) @staticmethod def post_salary(): &quot;&quot;&quot; 薪酬统一处理 &quot;&quot;&quot; mouth = [] year = [] thousand = [] with open(os.path.join(&quot;data&quot;, &quot;post_salary_locate.csv&quot;), &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.reader(f) for row in f_csv: if &quot;万/月&quot; in row[0]: mouth.append((row[0][:-3], row[2], row[1])) elif &quot;万/年&quot; in row[0]: year.append((row[0][:-3], row[2], row[1])) elif &quot;千/月&quot; in row[0]: thousand.append((row[0][:-3], row[2], row[1])) # pprint(mouth) calc = [] for m in mouth: s = m[0].split(&quot;-&quot;) calc.append( (round( (float(s[1]) - float(s[0])) * 0.4 + float(s[0]), 1), m[1], m[2])) for y in year: s = y[0].split(&quot;-&quot;) calc.append( (round( ((float(s[1]) - float(s[0])) * 0.4 + float(s[0])) / 12, 1), y[1], y[2])) for t in thousand: s = t[0].split(&quot;-&quot;) calc.append( (round( ((float(s[1]) - float(s[0])) * 0.4 + float(s[0])) / 10, 1), t[1], t[2])) pprint(calc) with open(os.path.join(&quot;data&quot;, &quot;post_salary.csv&quot;), &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.writer(f) f_csv.writerows(calc) @staticmethod def post_salary_counter(): # 薪酬统计 with open(os.path.join(&quot;data&quot;, &quot;post_salary.csv&quot;), &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.reader(f) lst = [row[0] for row in f_csv] counter = Counter(lst).most_common() pprint(counter) with open(os.path.join(&quot;data&quot;, &quot;post_salary_counter1.csv&quot;), &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.writer(f) f_csv.writerows(counter) @staticmethod def world_cloud(): &quot;&quot;&quot; 生成词云 &quot;&quot;&quot; counter = &#123;&#125; with open(os.path.join(&quot;data&quot;, &quot;post_pre_desc_counter.csv&quot;), &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: f_csv = csv.reader(f) for row in f_csv: counter[row[0]] = counter.get(row[0], int(row[1])) pprint(counter) file_path = os.path.join(&quot;font&quot;, &quot;msyh.ttf&quot;) wc = WordCloud(font_path=file_path, max_words=100, height=600, width=1200) wc.generate_from_frequencies(counter) plt.imshow(wc) plt.axis(&apos;off&apos;) plt.show() wc.to_file(os.path.join(&quot;images&quot;, &quot;wc.jpg&quot;))if __name__ == &quot;__main__&quot;: spider = JobSpider() spider.job_spider() spider.post_salary_locate() spider.post_salary() spider.post_salary_counter() spider.post_counter() spider.world_cloud()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua面向对象]]></title>
    <url>%2F2016%2F07%2F14%2FLua%20OOP%2F</url>
    <content type="text"><![CDATA[🤔 面向对象的特征 1） 封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。 2） 继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。 3） 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。 4）抽象：抽象是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。 Lua面向对象Lua中最基本的结构是table，所以需要用table来描述对象的属性。Lua中的function可以用来表示方法。那么Lua中的类可以通过table + function模拟出来。同时在Lua中，table就是一种对象。首先table与对象一样可以拥有状态。其次，table与对象一样拥有一个独立于其值的标识（self）。最后table与对象一样具有独立于创建者和创建地的生命周期。对象有其自己的操作，在table中：1234Account = &#123;balance = 0&#125;function Account.withdraw(v) Account.balance = Account.balance - vend 以上代码，创建了一个新函数，并将该函数存入Account对象的withdraw字段中，可以进行以下调用：Account.withdraw(100.00)这种函数就是所谓的“方法”。不过在函数中使用全局名称 Account是一个不好的变成习惯。因为这个函数只能针对特定对象工作，并且这个特定对象还必须存储在特定的全局。如果改变了对象的名称，withdraw就不能继续工作：123a = AccountAccount = nila.withdraw(100.0) --这里会报错 这种做法违反了之前所说对象的特性，即对象拥有独立的生命周期。我们有一种灵活的方式，即置顶一项操作所做用的“接受者”，因此需要一个额外的参数来表示该接受者。这个参数通常为self或this：1234567function Account.withdraw(self, v) self.balance = self.balance - venda1 = AccountAccount = nila1.withdraw(a1, 7) 使用self参数是所有面向对象语言的一个核心，大多数面向对象语言都能对程序员隐藏部分self参数，从而使的程序员不必显式的申明这个参数。在Lua中，只需要使用冒号，则能隐藏该参数。123456function Account:withdraw(v) self.balance = self.balance - venda = Accounta:withdraw(10) Lua中的类类可以看作一个创建对象的模具。大多面向对象的语言都提供了类的概念，在这些语言中，每个对象都是某个特定类的实例。Lua中没有类的概念，每个对象只能自定义行为和形态。不过在Lua中可以模拟类，可以参数一些基于原型的语言，例如newtonscript。在这些语言中对象没有类型，而是每个对象都有一个原型，原型也是一种常规的对象，当其他对象遇到一个未知操作时，原型会先查找它。在这种语言中要表示一个类，只需要创建一个专用作其他对象的原型。Lua中实现原型很简单，如果有两个对象，a和b，要让b作为a的一个原型，只需要如下操作：setmetatable(a, {__index = b})之后，a就会在b中查找所有它没有的操作，可以将b称为对象a的类。 在之前的例子中，为了创建更多的Account，可以让这些新的对象可以从Account行为中继承这些操作，具体的做法就是使用__index元方法。可以应用一些优化，无需创建一个额外的table作为元表，而是使用Account table自身作为元表：12345678function Account:new(o) o = o or &#123;&#125; --如果没有提供table，则创建一个 setmetatable(o, self) self.__index = self return oenda = Account:new&#123;balance = 0&#125;a : withdraw(7) 下面提供一个完整的实例：1234567891011121314151617Shape = &#123;area = 0&#125;-- 基础类方法 newfunction Shape:new (o,side) o = o or &#123;&#125; setmetatable(o, self) self.__index = self side = side or 0 self.area = side*side; return oend-- 基础类方法 printAreafunction Shape:printArea () print(&quot;面积为 &quot;,self.area)end-- 创建对象myshape = Shape:new(nil,10)myshape:printArea() Lua继承继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。以下演示了一个简单的继承实例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Shape = &#123;area = 0&#125;-- 基础类方法 newfunction Shape:new (o,side) o = o or &#123;&#125; setmetatable(o, self) self.__index = self side = side or 0 self.area = side*side; return oend-- 基础类方法 printAreafunction Shape:printArea () print(&quot;面积为 &quot;,self.area)end-- 创建对象myshape = Shape:new(nil,10)myshape:printArea()Square = Shape:new()-- 派生类方法 newfunction Square:new (o,side) o = o or Shape:new(o,side) setmetatable(o, self) self.__index = self return oend-- 派生类方法 printAreafunction Square:printArea () print(&quot;正方形面积为 &quot;,self.area)end-- 创建对象mysquare = Square:new(nil,10)mysquare:printArea()Rectangle = Shape:new()-- 派生类方法 newfunction Rectangle:new (o,length,breadth) o = o or Shape:new(o) setmetatable(o, self) self.__index = self self.area = length * breadth return oend-- 派生类方法 printAreafunction Rectangle:printArea () print(&quot;矩形面积为 &quot;,self.area)end-- 创建对象myrectangle = Rectangle:new(nil,10,20)myrectangle:printArea()]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua进阶]]></title>
    <url>%2F2016%2F07%2F09%2FLuaAdvanced%2F</url>
    <content type="text"><![CDATA[🤔 Lua协程 协程类似于线程，是一条执行序列，拥有自己独立的栈、局部变量和指令指针，同时与其他协程共享全局变量等。 线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。就是说，一个具有多个协程的程序在任意时刻只能运行一个协程，并且正在运行的协程只有在其显式的要求挂起时，他的执行才会暂停。 Lua将所有协程相关的函数放在一个名为“coroutine”的table中，其中主要方法有： 方法 描述 create() 用于创建新的协程，返回一个协程类型的值，参数是一个函数 resume() 用于启动或重启一个协程 yield() 挂起一个协程 wrap() 创建一个新协程，返回一个函数，调用函数时开启协程 status() 查看协程状态 通过status可以查看到一个协程可以处于4种不同的状态，分别是挂起（suspended）、运行（running）、死亡（dead）、正常（normal），当创建一个协程时，它处于挂起状态:1234567co = coroutine.create( function () print(&apos;Hello, World&apos;) end)print(coroutine.status(co)) 输出：suspended --协程处于挂起状态 通过resume启动这个协程：12coroutine.resume(co)print(coroutine.status(co)) 输出：12Hello, Worlddead -- 处于死亡状态 协程真正强大之处在于yield函数，该函数可以使一个运行中的协程处于挂起，而后再恢复他的运行：123456789co = coroutine.create( function () for i = 1, 10 do print(i) coroutine.yield() end end)coroutine.resume(co) 输出：121suspended --处于挂起状态 在这里，当唤醒协程时它开始执行，直到遇到yield，协程会被挂起，此时的活动都发生在yield调用中，当恢复协程执行，对于yield的调用才会最终返回，然后写成继续执行，直到下一个yield或执行结束：123for i = 1, 10 do coroutine.resume(co)end 输出：2 3 4 5 6 7 8 9 10再最后一次调用时，协程的内容已经执行完毕，并已经返回。因此这是的协程处于死亡状态，没有输出，如果试图再次执行它，resume将返回false及一条错误信息：print(coroutine.resume(co))输出：false cannot resume dead coroutine 下面是一个综合的实例：123456789101112131415161718192021222324function foo (a) print(&quot;foo 函数输出&quot;, a) return coroutine.yield(2 * a) -- 返回 2*a 的值end co = coroutine.create(function (a , b) print(&quot;第一次协同程序执行输出&quot;, a, b) -- co-body 1 10 local r = foo(a + 1) print(&quot;第二次协同程序执行输出&quot;, r) local r, s = coroutine.yield(a + b, a - b) -- a，b的值为第一次调用协同程序时传入 print(&quot;第三次协同程序执行输出&quot;, r, s) return b, &quot;结束协同程序&quot; -- b的值为第二次调用协同程序时传入end) print(&quot;main&quot;, coroutine.resume(co, 1, 10)) -- true, 4print(&quot;--分割线----&quot;)print(&quot;main&quot;, coroutine.resume(co, &quot;r&quot;)) -- true 11 -9print(&quot;---分割线---&quot;)print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- true 10 endprint(&quot;---分割线---&quot;)print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- cannot resume dead coroutineprint(&quot;---分割线---&quot;) 输出:123456789101112第一次协同程序执行输出 1 10foo 函数输出 2main true 4--分割线----第二次协同程序执行输出 rmain true 11 -9---分割线---第三次协同程序执行输出 x ymain true 10 结束协同程序---分割线---main false cannot resume dead coroutine---分割线--- Lua元表和元方法 通常Lua中的每个值都有一套预定义的操作集合。例如数字四则运算，字符串链接，增加table的键值对等。但无法将两个table相加,无法对函数做比较，也无法调用字符串。 我们可以通过元表来修改一个值的行为，使其在面对一个非预定义的操作时执行一个指定的操作。如上所诉，可以通过元表让两个table相加。当Lua试图将两个table相加时，会先检测两者之一是否有元表，然后检测该元表中是否有__add字段，若找到该字段，就调用该字段对应的值。这个值也就是所谓的元方法（通常是一个函数或者table），这个函数会用于计算两个table的和。 Lua中的每一个值都有一个元表，table和userdata可以有各自独立的元表，其他类型则共享其类型所属的单一元表。Lua在创建新的table时不会创建元表。 Lua中有两个重要的函数处理元表: setmetatable(table, metatable): 对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。 getmetatable(table): 返回对象的元表(metatable)。 123t = &#123;&#125;t1 = &#123;&#125;setmetatable(t, t1) 上面的代码可以简化为一行：t = setmetatable({}, {}) 任何table都可以作为任何值的元表，而一组相关的table也可以共享一个通用的元表，此元表描述了他们的共同行为。一个table甚至可以作为其自己的元表，用于描述其特有的行为。 在Lua代码中只能设置table的元表，若要设置其他类型值的元表，则必须通过c代码来完成。 __index元方法 当访问一个table不存在的字段时，会返回nil。这些访问会促使解释器去查找一个叫做__index的元方法，如果没有这个方法，那么访问结果就会为nil，否则就由这个元方法来提供结果。 假设要创建一个窗口的table，table中需要有位置、大小、背景等参数，所有参数都有默认值，因此希望在创建窗口对象时可以仅指定除了默认值的其他参数，这里我们可以这样实现：123456789101112131415window = &#123;&#125; --命名空间window.prototype = &#123;x = 0, y = 0, width = 70, height = 70&#125; --原型窗口window.mt = &#123;&#125; --创建元表function window.new(o) --声明构造函数 setmetatable(o, window.mt) return oendwindow.mt.__index = function(table, key) --定义元方法 return window.prototype[key]endw = window.new&#123;x = 10, y = 20&#125; -- 创建一个新窗口print(w.width)--查询它没有的字段--这里输出 70 __newindex元方法 newindex元方法和index类似，不同之处在于前者用于table更新，而后者用于在table中查询，当对一个table中不存在的索引赋值时，解释器就会查找这个元方法，如果有，解释器就调用它，而不是执行赋值。如果这个元方法是一个table，解释器就在这个table中赋值，而不是对原来的table。例： 12345678910t1 = &#123;&#125;t = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123; __newindex = t1 &#125;)print(t.key1)t.newkey = &quot;新值2&quot;print(t.newkey,t1.newkey)t.key1 = &quot;新值1&quot;print(t.key1,t1.key1) 输出：123value1nil 新值2新值1 nil 算数类元方法 Lua中每种算数操作符都有对应的字段名，如下所示： 字段名 描述 __add 对应运算符”+” __sub 对应运算符”-” __mul 对应运算符”*” __div 对应运算符”/” __unm 对应运算符”-” __concat 对应运算符”..” __eq 对应运算符”==” __mod 对应运算符”%” __pow 对应运算符”^” __lt 对应运算符”&lt;” __tostring元方法 函数print总是调用tostring来格式化输出。当格式化任意值时，tosrting会检查该值是否有__tostring元方法，如果有，tostring就会用该值作为参数来调用这个元方法。 12345678910t = setmetatable(&#123; 10, 20, 30 &#125;, &#123; __tostring = function(t) sum = 0 for k, v in pairs(t) do sum = sum + v end return &quot;表所有元素的和为 &quot; .. sum end&#125;)print(t) 输出：表所有元素的和为 60]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua基础]]></title>
    <url>%2F2016%2F07%2F04%2FLuaBasics%2F</url>
    <content type="text"><![CDATA[🤔 Lua IDEMac端Lua IDE推荐使用Intellij+EmmyLua。这也是我使用过最好的Lua IDE下载地址：IntelliJ IDEAEmmyLua安装方法：Preferences ——&gt;Plugins ——&gt;搜索EmmyLua 在使用EmmyLua时出现bug，或对此插件有什么建议，可以加群：29860775进行反馈 Lua 数据类型Lua是一种动态类型的语言。在语言中没有类型定义的语法，每个值都携带了它自身的类型信息。在Lua中有8种基础类型，分别是nil、boolean、number、string、userdata、function、thread和table 名称 数据类型 描述 示例 nil 空类型 表示一个无效值 a boolean 布尔 包含两个值：false和true a = true number 数字 双精度类型的实浮点数 a = 7 string 字符串 由一对双引号或单引号来表示 a = ‘yu’ userdata 自定义类型 任意存储在变量中的C数据结构 标准i/o库 function 函数 由 C 或 Lua 编写的函数 见下文 thread 协程 表示执行的独立线路，用于执行协同程序 table 表 Lua 中的表其实是一个”关联数组” a = {} 字符串 Lua中的字符串通常表示“一个字符序列”。 Lua完全采用8位编码，Lua字符串中的字符可以具有任何数值编码，包括数值0。 也就是说，可以将任意二进制数据存储到一个字符串中。 Lua的字符串是不可变的值。 Lua的字符串和其他Lua对象一样，都是自动内存管理机制所管理的对象 Lua字符串可以用以下方式来表示：s = &#39;Hello, World&#39;s = &quot;Hello, World&quot; Lua 提供了很多的方法来支持字符串的操作，可以查阅Lua 字符串来了解更多 变量 Lua 变量有两种类型：全局变量、局部变量。 Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声 明为局部变量。 局部变量的作用域为从声明位置开始到所在语句块结束。 变量的默认值均为 nil。local i = 1 --局部变量 Lua 流程控制 lua提供了一组传统的流程控制，if-else if语句先测试条件，然后根据结果执行then部分或else部分，其中else部分是可选的：123456789a = 0if a &gt; 0 then print(&apos;a &gt; 0&apos;)elseif a &lt; 0 then print(&apos;a&lt; 0&apos;)else print(&apos;a = 0&apos;)end Lua 循环 Lua 语言提供了以下几种循环: while for repeat…until 同时Lua 支持 break语句 while 与其他语言一样，Lua中的while循环先测试条件，如果条件为真，就执行循环体，否则结束循环：12345a = 0while a &lt; 10 do print(a) a = a + 1end repeat Lua中repeat-until语句会重复执行循环体至条件为真时结束：12345a = 0repeat print(a) a = a + 1until a &gt; 10 for Lua的for循环有两种形式： 数字型for 泛型for 数字型：123for i = 1, 10, 2 do print(i)end 含义为，i从1变化到10，每次变化以2作为步长递增并执行循环体。 其中步长是可选的，若不指定，则步长默认为1 泛型：1234days = &#123;&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;&#125;for i,v in ipairs(days) do print(i, v) end 泛型for循环通过一个迭代器函数来遍历所有的值，在Lua中，提供了ipairs这个用于便利数组的迭代器函数。每次循环，i会被赋予一个索引值，v会被赋予一个对应该索引值的数组元素值。泛型for循环的功能非常强大，可以通过不同的迭代器来遍历所有东西。如：迭代文件中的每行（io.lines）、迭代table元素（pairs）、迭代数组元素（ipairs）、迭代字符串中的字符（string.gmatch）等。当然，还可以自己编写迭代器。 break break语句用于结束一个循环，它只会跳出包含它的内部循环，而不会改变外部循环。例：123456789a = 0while a &lt; 10 do a = a + 1 if a &gt; 5 then break end print(a)end function 在Lua中，函数作为“一等对象”。这表示函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。这种特性使语言具有极大的灵活性。 Lua对函数式编程也提供了良好的支持。 Lua既可以调用自身的Lua编写的函数，也可以调用c编写的函数。 函数的定义如下：12345function SumTowNum(num1 , num2) return num1 + num2endprint(SumTowNum(10, 11)) 输出：21 Lua函数可以返回多个结果值，比如：12345678910111213function maximum (a) local mi = 1 -- 最大值索引 local m = a[mi] -- 最大值 for i,val in ipairs(a) do if val &gt; m then mi = i m = val end end return m, miendprint(maximum(&#123;8,10,23,12,5&#125;)) 输出:23 3 Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 …表示函数有可变的参数。 table表 Lua table 实现了关联数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。 Lua table 是不固定大小的，你可以根据自己需要进行扩容。 table是Lua中主要的（事实上也是仅有的）数据结构机制，具有强大的功能，基于table，可以以一种简单、统一和高效的方式来表示普通数组、符号表、集合、记录、队列及其他数据结构。同时Lua也是通过table来表示模块、包和对象的 可以将table想象成一种动态分配的对象，程序仅持有一个对它的引用（或指针）。 table的创建是通过构造表达式完成的： 1234--创建tablea = &#123;&#125;b = &apos;x&apos;a.b = 10 -- key = &apos;x&apos;. value = 10 tabel永远是匿名的，一个持有table的变量和table自身之间没有固定的关联性。]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua简介]]></title>
    <url>%2F2016%2F07%2F03%2FLuaintroduce%2F</url>
    <content type="text"><![CDATA[🤔 Lua是可扩展的轻量级编程语言，它是用C语言编写的，并于1993年开始作为一个内部项目开始诞生。Lua代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。一个完整的Lua解释器不过200k，在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。它从一开始就设计为可以与用C语言编写等常规语言的代码集成软件。这种整合带来了很多好处。它不会尝试做C已经可以做东西，但旨在提供那些C是不好的：从测试和调试的硬件，动态结构，没有冗余，松藕合。对于这一点，lua有一个安全的环境，自动内存管理，以及处理字符串和其他类型的动态尺寸数据良好的设计。 特点Lua提供了一组独特的功能，使得它与其他语言不同。这些包括： 扩展 简单 高效 便携 免费和开源 示例代码:print(&quot;Hello World!&quot;) Lua如何实现Lua中包括的部件为Lua解释部分和运行软件系统。该软件系统功能是一个实际的计算机应用程序，它可以解释写在Lua的编程语言程序。 Lua解释是用ANSI C编写，因此它是非常便携，可以从高端网络服务器，以及小型设备设备上运行。Lua语言解释器非常成熟，体积小，速度快。它已经从其他编程语言和上层软件的标准演变而来的。作为小型程序可以在低内存小的设备上运行。 Lua相关用途 游戏编程 脚本中的独立应用程序 网页脚本 扩展和插件像MySQL代理和MySQL数据库的工作台 安全系统，如入侵检测系统]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python装饰器]]></title>
    <url>%2F2016%2F06%2F25%2FpythonDecorator%20Pattern%2F</url>
    <content type="text"><![CDATA[🤔 装饰器介绍 Python装饰器是程序开发中经常使用到的功能，熟练掌握装饰器会让你的编程思路更加广阔 要理解装饰器，首先要先理解： 在 Python 中“函数是一等对象” 。即函数是一种特殊类型的变量，可以和其余变量一样，可以作为参数传递给函数，也可以作为返回值返回。Python 中的整数、字符串和字典等都是一等对象。 函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。 装饰器实现装饰器本质上是python函数，它可以使其他函数在不需要做代码变动的情况下增加新的功能，装饰器返回值也是一个函数对象。 以下是一个简单的例子：假设现在有一个函数sayHi，用来输出一句话 1234def sayHi(): print(&apos;Hello, World&apos;)s = sayHis() 输出：Hello, World 我想希望在不修改sayHi函数的情况下在其之前再输出一句话,这种在代码运行期间动态增加功能的方式，称之为“装饰器”。本质上，装饰器就是一个返回函数的高阶函数 我们可以这么写： 12345678910def sayName(func): def inner(): print(&quot;I&apos;m Yu&quot;) return func return inner()def sayHi(): print(&apos;Hello, World&apos;)s = sayName(sayHi)s() 输出：12I&apos;m YuHello, World 但代码美中不足的是，我们每次给sayHi增加功能都需要用到类似s = sayName(sayHi)这句话。python为了简化这种情况，提供了一个语法糖“@”。 简化上边的代码: 1234567891011def sayName(func): def inner(): print(&quot;I&apos;m Yu&quot;) return func() return inner@sayNamedef sayHi(): print(&apos;Hello, World&apos;)sayHi() 输出：12I&apos;m YuHello, World 装饰器原理以上代码中，首先，在装饰器函数sayName中，sayName需要接受一个参数func，在其内部又定义了一个inner函数，在inner函数中增加一句输出，并返回func对象，然后sayName函数返回内部函数inner，其实就是一个闭包函数。接下来在sayHi上边增加一个@sayName，其意义就是在python解释器之行到此处时，会调用装饰器函数（sayName），并把被装饰得函数（sayHi）作为参数传入。此时的sayHi已经不是未加装饰时的函数了，而是指向sayName.inner函数地址。在接下来调用sayHi()时，其实就是调用sayName.inner。 有参函数装饰之前的例子是对无参函数的装饰，如果装饰带参数的函数该如何处理？1234567891011def sayName(func): def inner(name): print(&quot;I&apos;m Yu&quot;) return func(name) return inner@sayNamedef sayHi(name): print(&apos;Hi,&apos; + name)sayHi(&apos;siri&apos;) 输出：12I&apos;m YuHi,siri 两个装饰器装饰函数这里测试两个装饰器装饰一个函数的结果：1234567891011121314151617181920def sayName(func): print(&apos;name&apos;) def inner(): print(&quot;I&apos;m Yu&quot;) return func() return innerdef sayAge(func): print(&apos;age&apos;) def inner(): print(&quot;i&apos;m 30&quot;) return func() return inner@sayName@sayAgedef sayHi(): print(&apos;Hello, World&apos;)sayHi() 输出:12345agenameI&apos;m Yui&apos;m 30Hello, World 接下来分析输出这个结果的原因：首先，python解释器执行到第一个装饰器@sayName，在接下来发现装饰器下边不是一个函数而是另一个装饰器，解释器会执行第二个的装饰器@sayAge，然后把sayHi函数传入装饰器，所以首先输出了“age”，当@sayAge装饰完成，此时的sayHi函数地址指向了sayAge.inner的地址，解释器会返回去执行@sayName装饰器来装饰新的sayHi，从而输出了“name”，接着函数当前指向sayName.inner会先输出“I’m Yu”，在这里返回的func()其实就是返回的sayAge.inner，所以在下面输出i’m 30，最后输出原本sayHi的“Hello, World” 有参装饰器下边是装饰器带参数：1234567891011121314def now(time): def sayName(func): def inner(name): print(&apos;现在是: %s&apos; % time) print(&quot;I&apos;m Yu&quot;) return func(name) return inner return sayName@now(&apos;2016/10/30&apos;)def sayHi(name): print(&apos;Hello,&apos; + name)sayHi(&apos;siri&apos;) 输出：123现在是: 2016/10/30I&apos;m YuHello,siri 以上就是python装饰器的相关介绍]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数式编程]]></title>
    <url>%2F2016%2F06%2F17%2Fpython%20Functional%2F</url>
    <content type="text"><![CDATA[🤔 函数式编程函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。 函数式编程Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。函数式编程就是一种抽象程度很高的编程范式。在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言 函数式编程的优点 逻辑可证 这是一个学术上的优点：没有”边界效应”使得更容易从逻辑上证明程序是正确的。 边界效应是指在进行程序设计时，我们的编程思想、算法以及分析测试的数据有可能会接近我们所没有注意的边界。所有的操作设计都会有一个边界，例如整形数据的内存，很多情况下在进行程序设计时，往往会被我们所忽略 模块化 函数式编程推崇简单原则，一个函数只做一件事情，将大的功能拆分成尽可能小的模块。小的函数更易于阅读和检查错误。 组件化 小的函数更容易加以组合形成新的功能。 易于调试 细化的、定义清晰的函数使得调试更加简单。当程序不正常运行时，每一个函数都是检查数据是否正确的接口，能更快速地排除没有问题的代码，定位到出现问题的地方。 易于测试 不依赖于系统状态的函数无须在测试前构造测试桩，使得编写单元测试更加容易。 更高的生产率 函数式编程产生的代码比其他技术更少（往往是其他技术的一半左右），并且更容易阅读和维护。 函数式编程的特征在支持函数式编程的语言中，大量使用如下特征的代码即可被认为是函数式： 函数是一等公民 函数能作为参数传递，或者是作为返回值返回。 匿名函数(lambda) lambda提供了快速编写简单函数的能力 闭包 闭包引用了外层函数的变量，然后返回内层函数 内置的不可变数据结构 如python中的元组 内置模板函数::见下文中的高阶函数:: 递归 匿名函数(lambda)当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。例：12p = lambda x: x+xprint(p(10) 其等价于：1234def test(x): return x+xp = test(10)print(p) 这里我建议尽量避免使用lambda。lambda功能十分有限，只能有一个表达式，返回值就是该表达式的结果。最主要是语句过于复杂，lambda表达式会很难阅读 高阶函数 能接收函数做参数的函数: 变量可以指向函数 函数的参数可以接收变量 一个函数可以接收另一个函数作为参数如：python内置函数，map()函数、reduce()函数、filter()函数等 Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数 例： 1234def test(x, y, z): return z(x, y)print(test(2, 3, pow)) 这里x，y是两个数值，z是一个函数 偏函数Python的functools模块提供了很多有用的功能，偏函数是其中之一，偏函数把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。如int()函数，其提供了base参数，默认值为10。如果传入base参数，就可以做进制的转换int(&#39;101010&#39;, base=2)如果经常需要做二进制转换我们就可以自己定义一个int2()函数12def int2(x, base=2): return int(x, base) 这里如果我们使用functools.partial，就可以非常方便的直接创建一个int2()12from functools import partialint2 = partial(int, base=2)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Functional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity背包]]></title>
    <url>%2F2016%2F05%2F22%2FUnityBackPack%2F</url>
    <content type="text"><![CDATA[🤔 背包是大多类型游戏的必要功能之一，也是游戏设计中比较重要的一个元素。 这里是一个简单的背包代码演示，不多介绍背包的具体设计及用户体验。 该背包使用ugui搭建，结构如下图 添加背包物品类AddEquip.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class AddEquip : MonoBehaviour &#123; public GameObject equipPrefab; Transform kanpsack; public GameObject itemPrefab; void Awake() &#123; kanpsack = GameObject.Find(&quot;Knapsack&quot;).transform; &#125; void Start () &#123; Sprite[] allSprs = Resources.LoadAll&lt;Sprite&gt; (&quot;&quot;); //循环添加物品 for (int i = 0; i &lt; allSprs.Length; i++) &#123; //Sprite sp = Resources.Load&lt;Sprite&gt;(i.ToString()); GameObject g = Instantiate&lt;GameObject&gt;(equipPrefab, transform); g.GetComponent&lt;Image&gt;().sprite = allSprs[i]; int indx = i; g.GetComponent&lt;Button&gt;().onClick.AddListener(delegate() &#123; AddEquips(allSprs[indx]); &#125; ); &#125; &#125; //物品选择 void AddEquips(Sprite sp) &#123; for (int i = 0; i &lt; kanpsack.childCount; i++) &#123; Transform cell = kanpsack.GetChild(i); //上面有物品, if (cell.childCount &gt; 0) &#123; //判断所选的物品是否重复,重复就数量++ if (cell.GetChild(0).GetComponent&lt;Image&gt;().sprite.name == sp.name) &#123; Text text = cell.GetChild(0).GetComponentInChildren&lt;Text&gt;(); if(text.text == &quot;&quot;)&#123; text.text = &quot;1&quot;; &#125; int count = int.Parse(text.text); count++; text.text = count.ToString(); return; &#125; &#125; &#125; //到了这步说明，所选的物品之前没有选取过 for (int i = 0; i &lt; kanpsack.childCount; i++) &#123; Transform cell = kanpsack.GetChild(i); if (cell.childCount ==0) &#123; GameObject go = Instantiate&lt;GameObject&gt;(itemPrefab, cell); go.transform.localPosition = Vector3.zero; go.GetComponent&lt;Image&gt;().sprite = sp; go.transform.GetChild(0).gameObject.SetActive(true); return; &#125; &#125; &#125;&#125; 背包物品移动类ChangeEquipScript.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;//强制添加组件[RequireComponent(typeof(CanvasGroup))]public class ChangeEquipScript : MonoBehaviour,IBeginDragHandler,IEndDragHandler,IDragHandler &#123; Transform canvas;//Canvas private Transform originalParent;//拖拽物品的原父物体 private CanvasGroup canvasGroup; Vector3 dis;//鼠标位置到拖拽物品的距离 void Awake() &#123; canvas = GameObject.Find(&quot;Canvas&quot;).transform; &#125; void Start() &#123; canvasGroup = GetComponent&lt;CanvasGroup&gt;(); &#125; //开始拖拽 public void OnBeginDrag(PointerEventData eventData) &#123; originalParent = transform.parent; //使拖拽的物品位于其它UI之上 transform.SetParent(canvas); dis = transform.position - Input.mousePosition; //不阻止射线透过当前拖拽的物品，检测下方的UI canvasGroup.blocksRaycasts = false; &#125; //拖拽中 public void OnDrag(PointerEventData eventData) &#123; transform.position = Input.mousePosition + dis; &#125; //结束拖拽 public void OnEndDrag(PointerEventData eventData) &#123; //获取鼠标进入的游戏物体 Transform obj; //判断鼠标是否进入UI外 if (eventData.pointerEnter == null) &#123; transform.SetParent(originalParent); transform.localPosition = Vector3.zero; canvasGroup.blocksRaycasts = true; return; &#125; else &#123; obj = eventData.pointerEnter.transform; &#125; switch (obj.tag) &#123; case &quot;item&quot;: &#123; //交换两个游戏物品 Transform t = obj.parent; obj.SetParent(originalParent); transform.SetParent(t); obj.localPosition = Vector3.zero; &#125; break; case &quot;cell&quot;: &#123; //判断Cell上是否有物品 if (obj.childCount == 1) &#123; //有装备 Transform child = obj.GetChild(0); child.SetParent(originalParent); transform.SetParent(obj); child.localPosition = Vector3.zero; &#125; else &#123; //无装备 //直接将拖拽的物品放置在cell上 transform.SetParent(obj); &#125; &#125; break; default: &#123; //移除范围后，重置 transform.SetParent(originalParent); &#125; break; &#125; transform.localPosition = Vector3.zero; canvasGroup.blocksRaycasts = true; &#125; &#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>应用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2016%2F05%2F09%2FBinary%20Tree%2F</url>
    <content type="text"><![CDATA[🤔 二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2个子结点。然而，没有足够的信息来区分左结点和右结点。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林。 下面我们通过python来实现二叉树及其遍历 构建二叉树12345class Node: def __init__(self, value = None, left = None, right = None): self.value = value self.left = left self.right = right 遍历二叉树1234567891011121314151617181920212223242526272829303132333435def PreTraverse(root): &apos;&apos;&apos; 前序遍历 :param root: :return: &apos;&apos;&apos; if root == None: return print(root.value) PreTraverse(root.left) PreTraverse(root.right)def MidTraverse(root): &apos;&apos;&apos; 中序遍历 :param root: :return: &apos;&apos;&apos; if root == None: return MidTraverse(root.left) print(root.value) MidTraverse(root.right)def AfterTraverse(root): &apos;&apos;&apos; 后序遍历 :param root: :return: &apos;&apos;&apos; if root == None: return AfterTraverse(root.left) AfterTraverse(root.right) print(root.value)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#结构导图]]></title>
    <url>%2F2016%2F05%2F01%2FCsharpconstruction(al)drawing%2F</url>
    <content type="text"><![CDATA[🤔]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#简介]]></title>
    <url>%2F2016%2F05%2F01%2FCsharpintroduce%2F</url>
    <content type="text"><![CDATA[🤔 C# 是一种面向对象的语言。不仅如此，C# 还进一步支持面向组件的编程。 当代软件设计越来越依赖采用自描述的独立功能包形式的软件组件。 此类组件的关键特征包括：为编程模型提供属性、方法和事件；包含提供组件声明性信息的特性；包含自己的文档。 C# 提供了语言构造来直接支持这些概念，让 C# 成为一种非常自然的语言，可用于创建和使用软件组件。 多项 C# 功能有助于构造可靠耐用的应用程序：垃圾回收可自动回收无法访问的未使用对象占用的内存；异常处理提供了一种结构化的可扩展方法来执行错误检测和恢复；C# 语言的类型安全设计禁止读取未初始化的变量、为范围之外的数组编制索引或执行未检查的类型转换。 C# 采用统一的类型系统。 所有 C# 类型（包括 int 和 double 等基元类型）均继承自一个根 object 类型。 因此，所有类型共用一组通用运算，任何类型的值都可以一致地进行存储、传输和处理。 此外，C# 还支持用户定义的引用类型和值类型，从而支持对象动态分配以及轻量级结构的内嵌式存储。为了确保 C# 程序和库能够随着时间的推移以兼容的方式发展，C# 设计更强调版本控制。 许多编程语言很少关注这个问题，因此，当引入新版依赖库时，用这些语言编写的程序会出现更多不必要的中断现象。 由于更强调版本控制，直接受影响的 C# 设计方面包括单独的 virtual 和 override 修饰符、关于方法重载决策的规则，以及对显式接口成员声明的支持。 C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。下面列出了 C# 成为一种广泛应用的专业语言的原因：现代的、通用的编程语言。面向对象。面向组件。容易学习。结构化语言。它产生高效率的程序。它可以在多种计算机平台上编译。.Net 框架的一部分。C# 强大的编程功能虽然 C# 的构想十分接近于传统高级语言 C 和 C++，是一门面向对象的编程语言，但是它与 Java 非常相似，有许多强大的编程功能，因此得到广大程序员的青睐。下面列出 C# 一些重要的功能：布尔条件（Boolean Conditions）自动垃圾回收（Automatic Garbage Collection）标准库（Standard Library）组件版本（Assembly Versioning）属性（Properties）和事件（Events）委托（Delegates）和事件管理（Events Management）易于使用的泛型（Generics）索引器（Indexers）条件编译（Conditional Compilation）简单的多线程（Multithreading）LINQ 和 Lambda 表达式集成 Windows详细指南可参考msdn，.net官方指南]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web渗透测试]]></title>
    <url>%2F2016%2F04%2F20%2FWebpenetration%20test%2F</url>
    <content type="text"><![CDATA[🤔 渗透测试流程 渗透测试执行标准 具体技术点 渗透的艺术]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2016%2F04%2F14%2Fgreedy%20algorithm%2F</url>
    <content type="text"><![CDATA[🤔 概念 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的 算法 。比如在 旅行推销员问题 中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。 贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。 贪心算法与 动态规划 的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。贪心法可以解决一些 最优化 问题，如：求中的 最小生成树 、求 哈夫曼编码 ……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。 思路 建立数学模型来描述问题。 把求解的问题分成若干个子问题。 对每一子问题求解，得到子问题的局部最优解。 把子问题的解局部最优解合成原来解问题的一个解。 实现该算法的过程：从问题的某一初始解出发；while 能朝给定总目标前进一步 do ,求出可行解的一个解元素；最后，由所有解元素组合成问题的一个可行解。 案例 这是《算法导论》上的例子，也是一个非常经典的问题。有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。该问题就是要安排这些活动使得尽量多的活动能不冲突的举行。可以用数学归纳法证明，我们的贪心策略应该是每次选取结束时间最早的活动。直观上也很好理解，按这种方法选择相容活动为未安排活动留下尽可能多的时间。这也是把各项活动按照结束时间单调递增排序的原因 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748include&lt;cstdio&gt;#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int N;struct Act&#123; int start; int end;&#125;act[100010];bool cmp(Act a,Act b) &#123; return a.end&lt;b.end; &#125; int greedy_activity_selector() &#123; int num=1,i=1; for(int j=2;j&lt;=N;j++) &#123; if(act[j].start&gt;=act[i].end) &#123; i=j; num++; &#125; &#125; return num;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf(&quot;%lld %lld&quot;,&amp;act[i].start,&amp;act[i].end); &#125; act[0].start=-1; act[0].end=-1; sort(act+1,act+N+1,cmp); int res=greedy_activity_selector(); cout&lt;&lt;res&lt;&lt;endl; &#125;&#125; 钱币找零问题这个问题在我们的日常生活中就更加普遍了。假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=7; int Count[N]=&#123;3,0,2,1,0,3,5&#125;;int Value[N]=&#123;1,2,5,10,20,50,100&#125;; int solve(int money) &#123; int num=0; for(int i=N-1;i&gt;=0;i--) &#123; int c=min(money/Value[i],Count[i]); money=money-c*Value[i]; num+=c; &#125; if(money&gt;0) num=-1; return num;&#125; int main() &#123; int money; cin&gt;&gt;money; int res=solve(money); if(res!=-1) cout&lt;&lt;res&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; 背包问题有一个背包，背包容量是M。有n个重量和价值分别为Wi和Vi的物品，物品可以分割成任意大小，要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt; using namespace std; const int N=4; void knapsack(float M,float v[],float w[],float x[]); int main() &#123; float M=50; //背包所能容纳的重量 float w[]=&#123;0,10,30,20,5&#125;; //每种物品的重量 float v[]=&#123;0,200,400,100,10&#125;; //每种物品的价值 float x[N+1]=&#123;0&#125;; //记录结果的数组 knapsack(M,v,w,x); cout&lt;&lt;&quot;选择装下的物品比例：&quot;&lt;&lt;endl; for(int i=1;i&lt;=N;i++) cout&lt;&lt;&quot;[&quot;&lt;&lt;i&lt;&lt;&quot;]:&quot;&lt;&lt;x[i]&lt;&lt;endl; &#125; void knapsack(float M,float v[],float w[],float x[]) &#123; int i; //物品整件被装下 for(i=1;i&lt;=N;i++) &#123; if(w[i]&gt;M) break; x[i]=1; M-=w[i]; &#125; //物品部分被装下 if(i&lt;=N) x[i]=M/w[i]; &#125; 多机调度问题N个作业组成的作业集，可由m台相同机器加工处理。要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。作业不能拆分成更小的子作业；每个作业均可在任何一台机器上加工处理。这个问题是NP完全问题，还没有有效的解法(求最优解)，但是可以用贪心选择策略设计出较好的近似算法(求次优解)。当n&lt;=m时，只要将作业时间区间分配给作业即可；当n&gt;m时，首先将n个作业从大到小排序，然后依此顺序将作业分配给空闲的处理机。也就是说从剩下的作业中，选择需要处理时间最长的，然后依次选择处理时间次长的，直到所有的作业全部处理完毕，或者机器不能再处理其他作业为止。如果我们每次是将需要处理时间最短的作业分配给空闲的机器，那么可能就会出现其它所有作业都处理完了只剩所需时间最长的作业在处理的情况，这样势必效率较低。在下面的代码中没有讨论n和m的大小关系，把这两种情况合二为一了。 12345678910111213141516171819202122232425#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int speed[10010]; int mintime[110]; bool cmp( const int &amp;x,const int &amp;y) &#123; return x&gt;y; &#125; int main() &#123; int n,m; memset(speed,0,sizeof(speed)); memset(mintime,0,sizeof(mintime)); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;++i) cin&gt;&gt;speed[i]; sort(speed,speed+n,cmp); for(int i=0;i&lt;n;++i) &#123; *min_element(mintime,mintime+m)+=speed[i]; &#125; cout&lt;&lt;*max_element(mintime,mintime+m)&lt;&lt;endl; &#125; 小船过河问题POJ1700是一道经典的贪心算法例题。题目大意是只有一艘船，能乘2人，船的运行速度为2人中较慢一人的速度，过去后还需一个人把船划回来，问把n个人运到对岸，最少需要多久。先将所有人过河所需的时间按照升序排序，我们考虑把单独过河所需要时间最多的两个旅行者送到对岸去，有两种方式：1.最快的和次快的过河，然后最快的将船划回来；次慢的和最慢的过河，然后次快的将船划回来，所需时间为：t[0]+2t[1]+t[n-1]；2.最快的和最慢的过河，然后最快的将船划回来，最快的和次慢的过河，然后最快的将船划回来，所需时间为：2t[0]+t[n-2]+t[n-1]。算一下就知道，除此之外的其它情况用的时间一定更多。每次都运送耗时最长的两人而不影响其它人，问题具有贪心子结构的性质。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[1000],t,n,sum; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); sum=0; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); while(n&gt;3) &#123; sum=min(sum+a[1]+a[0]+a[n-1]+a[1],sum+a[n-1]+a[0]+a[n-2]+a[0]); n-=2; &#125; if(n==3) sum+=a[0]+a[1]+a[2]; else if(n==2) sum+=a[1]; else sum+=a[0]; printf(&quot;%d\n&quot;,sum); &#125;&#125; 区间覆盖问题POJ1328是一道经典的贪心算法例题。题目大意是假设海岸线是一条无限延伸的直线。陆地在海岸线的一侧，而海洋在另一侧。每一个小的岛屿是海洋上的一个点。雷达坐落于海岸线上，只能覆盖d距离，所以如果小岛能够被覆盖到的话，它们之间的距离最多为d。题目要求计算出能够覆盖给出的所有岛屿的最少雷达数目。对于每个小岛，我们可以计算出一个雷达所在位置的区间。问题转化为如何用尽可能少的点覆盖这些区间。先将所有区间按照左端点大小排序，初始时需要一个点。如果两个区间相交而不重合，我们什么都不需要做；如果一个区间完全包含于另外一个区间，我们需要更新区间的右端点；如果两个区间不相交，我们需要增加点并更新右端点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct Point&#123; double x; double y;&#125;point[1000];int cmp(const void *a, const void *b)&#123; return (*(Point *)a).x&gt;(*(Point *)b).x?1:-1;&#125;int main()&#123; int n,d; int num=1; while(cin&gt;&gt;n&gt;&gt;d) &#123; int counting=1; if(n==0&amp;&amp;d==0) break; for(int i=0;i&lt;n;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; if(y&gt;d) &#123; counting=-1; &#125; double t=sqrt(d*d-y*y); //转化为最少区间的问题 point[i].x=x-t; //区间左端点 point[i].y=x+t; //区间右端点 &#125; if(counting!=-1) &#123; qsort(point,n,sizeof(point[0]),cmp); //按区间左端点排序 double s=point[0].y; //区间右端点 for(int i=1;i&lt;n;i++) &#123; if(point[i].x&gt;s) //如果两个区间没有重合,增加雷达数目并更新右端点 &#123; counting++; s=point[i].y; &#125; else if(point[i].y&lt;s) //如果第二个区间被完全包含于第一个区间,更新右端点 &#123; s=point[i].y; &#125; &#125; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;num&lt;&lt;&apos;:&apos;&lt;&lt;&apos; &apos;&lt;&lt;counting&lt;&lt;endl; num++; &#125;&#125; Huffman编码这同样是《算法导论》上的例子。Huffman编码是广泛用于数据文件压缩的十分有效的编码方法。我们可以有多种方式表示文件中的信息，如果用01串表示字符，采用定长编码表示，则需要3位表示一个字符，整个文件编码需要300000位；采用变长编码表示，给频率高的字符较短的编码，频率低的字符较长的编码，达到整体编码减少的目的，则整个文件编码需要(45×1+13×3+12×3+16×3+9×4+5×4)×1000=224000位，由此可见，变长码比定长码方案好，总码长减小约25%。对每一个字符规定一个01串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀，这种编码称为前缀码。可能无前缀码是一个更好的名字，但是前缀码是一致认可的标准术语。编码的前缀性质可以使译码非常简单：例如001011101可以唯一的分解为0,0,101,1101，因而其译码为aabe。译码过程需要方便的取出编码的前缀，为此可以用二叉树作为前缀码的数据结构：树叶表示给定字符；从树根到树叶的路径当作该字符的前缀码；代码中每一位的0或1分别作为指示某节点到左儿子或右儿子的路标。从上图可以看出，最优前缀编码码的二叉树总是一棵完全二叉树，而定长编码的二叉树不是一棵完全二叉树。 给定编码字符集C及频率分布f，C的一个前缀码编码方案对应于一棵二叉树T。字符c在树T中的深度记为dT(c)，dT(c)也是字符c的前缀码长。则平均码长定义为：使平均码长达到最小的前缀码编码方案称为C的最优前缀码。Huffman编码的构造方法：先合并最小频率的2个字符对应的子树，计算合并后的子树的频率；重新排序各个子树；对上述排序后的子树序列进行合并；重复上述过程，将全部结点合并成1棵完整的二叉树；对二叉树中的边赋予0、1，得到各字符的变长编码。POJ3253一道就是利用这一思想的典型例题。题目大意是有把一块无限长的木板锯成几块给定长度的小木板，每次锯都需要一定费用，费用就是当前锯的木板的长度。给定各个要求的小木板的长度以及小木板的个数，求最小的费用。以要求3块长度分别为5,8,5的木板为例：先从无限长的木板上锯下长度为21的木板，花费21；再从长度为21的木板上锯下长度为5的木板，花费5；再从长度为16的木板上锯下长度为8的木板，花费8；总花费=21+5+8=34。利用Huffman思想，要使总费用最小，那么每次只选取最小长度的两块木板相加，再把这些和累加到总费用中即可。为了提高效率，使用优先队列优化，并且还要注意使用long long int保存结果。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; long long int sum; int i,n,t,a,b; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;t); q.push(t); &#125; sum=0; if(q.size()==1) &#123; a=q.top(); sum+=a; q.pop(); &#125; while(q.size()&gt;1) &#123; a=q.top(); q.pop(); b=q.top(); q.pop(); t=a+b; sum+=t; q.push(t); &#125; printf(&quot;%lld\n&quot;,sum); &#125;&#125;]]></content>
      <categories>
        <category>C、C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据结构]]></title>
    <url>%2F2016%2F04%2F01%2FPythondata%20structure%2F</url>
    <content type="text"><![CDATA[🤔 字符串字符串是字符的序列，可以使用单引号、双引号及三引号来指定字符串123456name = &apos;etnly&apos; name = &quot;etnly&quot; # 两者工作机制完全相同 &apos;&apos;&apos;这是一个多行字符串 这是第二行 这位是第三行&apos;&apos;&apos; 在程序中使用的所有字符串都是str类下的对象，并且它也具有自己的方法，具体的方法清单可以查阅 help(str) 。 12345678910 # 返回字符串长度name = &apos;etnly&apos;len(name) # 遍历字符串name = &apos;etnly&apos;for i in name: print(i) # 字符串切片print(name[1:3]) # 输出 tn 列表列表是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序列。和字符串类似，在字符串中这些项目是字符，而列表中它可以是任何类型，列表中的值称为元素。 创建列表最简单的方式是使用 [] 方括号： 123num = [1, 2, 3] name = [&apos;张三&apos;, &apos;李四&apos;] other = [[1, 2, 3], &apos;a&apos;, &apos;b&apos; 3.0] 字符串的值是不可变的，而列表的值是可变的。如： 12num[1] = 3 print(num) 输出：[1, 3, 3] 列表对象也有自己的方法，具体可以查阅 help(list) 。 123456789101112 # 列表遍历num = [1, 2, 3]for i in num: print(i) # 列表拼接num2 = [2, 3, 4]num3 = num + num2 # 列表切片print(num3[1:3]) # 这里输出 [2, 3] # 添加元素num.append(4) 字典字典类似于列表，但更加通用，在列表中下表必须是整数，而字典中，下标基本可以是任意类型。 字典包含键（下标）和值。每一个键都关联一个值，这种方式称为键值对，字典体现了键到值的映射，所以可以说每一个键映射到一个值。 新建一个字典可以： d = {&#39;a&#39; : 1, &#39;b&#39; : 2, &#39;c&#39; : 3} d = dict() # 新建一个空字典 字典是通过散列表的方式实现的，意味着键必须是可散列的。散列是一个函数，接收值并返回一个整数，字典使用这些被称为散列值的整数来保存和查找键值对。 元组元组用于将多个对象保存到一起，其值可以是任何类型，并按照下标索引，元组和列表非常相似，其二者主要区别在于，元组是不可变的。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值。 元组语法上用逗号分隔一列值，可以用括号括起来： t = &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2 t = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2) 用括号括起来单独的值如 t = (‘a’) 并不是元组，如要新建元组可以使用内置函数tuple t = tuple() 严格的来说函数只能返回一个值，但如果返回的是元组，就可以达到类似返回多个值的效果。 元组、列表和字典列表和元组zip函数，接收两个或多个序列，并返回一个元组列表，每个元组包含来自每个序列的一个元素。 123a = &apos;abc&apos; b = [0, 1, 2] print(zip(a, b)) 结果返回 &lt;zip object at 0x10d5e1b08&gt; 这是一个zip对象，它知道如何遍历每个元素对，zip对象是一种迭代器，即用来迭代访问一个序列的对象 使用zip最常见的方法是在for循环中：12for i in zip(a, b): print(i) 输出：(&#39;a&#39;, 0) (&#39;b&#39;, 1) (&#39;c&#39;, 2) 如果需要使用列表的操作，可以利用zip对象制作一个列表： list(zip(a, b)) 字典和元组字典方法items可以返回一个元组序列，其中每个元组是一个键值对：123d = &#123;0 : &apos;a&apos;, 1 : &apos;b&apos;, 2 : &apos;c&apos;&#125; t = d.items() print(t) 输出： dict_items([(0, &#39;a&#39;), (1, &#39;b&#39;), (2, ‘c’)]) 反过来可以使用元组列表来初始化一个字典：12t = [(0, &apos;a&apos;), (1, &apos;b&apos;), (2, ‘c’)] d = dict(t) 我们可以通过dict和items得到一个简洁的创建新字典的方法： d = dict(zip(&#39;abc&#39;, range(3))) 序列列表、元组和字符串可以看作序列(Sequence)的某种表现形式，序列的主要功能是资格测试(也就是 in 与 not in 表达式)和索引操作，它们能够允许我们直接获取序列中的特定项目。 引用当你创建了一个对象并将其分配给某个变量时，变量只会查阅某个对象，并且它也 不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部分。这叫作将名称绑定给那一个对象。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象]]></title>
    <url>%2F2016%2F04%2F01%2FPythonOOP%2F</url>
    <content type="text"><![CDATA[🤔 面向对象的编程类与对象是面向对象编程的两个主要方面。一个类能够创建一种新的类型 ，其中对象就是类的实例。可以这样来类比:你可以拥有类型 int 的变量，也就是说存储整数的变量是 int 类的实例。 即使是整数也会被视为对象。这不同于 C++ 与c#，在它们那儿整数是原始内置类型 在Python中，一切皆为对象。 对象可以使用属于它的普通变量来存储数据。这种从属于对象或类的变量叫作字段 。对象还可以使用属于类的函数来实现某些功能，这种函数叫作类的方法 。这两个术语很重要，它有助于我们区分函数与变量，哪些是独立的，哪些又是属于类或对象的。总之，字段与方法通称类的属性。字段有两种类型——它们属于某一类的各个实例或对象，或是从属于某一类本身。它们被分别称作实例变量与类变量。 self类方法与普通函数只有一种特定的区别——前者必须有一个额外的名字，这个名字必须添加到参数列表的开头，但是你不用在你调用这个功能时为这个参数赋值，Python 会为它提供。 这种特定的变量引用的是对象本身，按照惯例，它被赋􏰀 self 这一名称。 Python 中的 self 相当于 C++ 中的指针以及 Java 与 C# 中的 this 指针。 类这是一个最简单的类：123class Person: pass # 空的代码块 p = Person() # 创建Person的对象p 方法一个简单的方法： 12345class Person: def sayHi(self): print(‘Hello, World’) p = Person() p.sayHi() 输出: Hello, World 唯一与函数不同的地方在于这里多了一个self 继承面向对象编程的一大优点是对代码的重用，重用的一种实现方法就是通过继承机制。继承指的是根据一个现有的类型，定义一个修改版本的新类的能力。继承最好是想象成在类之间实现类型与子类型关系的工具。123456789101112131415161718192021222324252627282930class SchoolMember: &apos;&apos;&apos;代表任何学校里的成员。&apos;&apos;&apos;def __init__(self, name, age): self.name = name self.age = age print(&apos;(Initialized SchoolMember: &#123;&#125;)&apos;.format(self.name))def tell(self):&apos;&apos;&apos;告诉我有关我的细节。&apos;&apos;&apos;print(&apos;Name:&quot;&#123;&#125;&quot; Age:&quot;&#123;&#125;&quot;&apos;.format(self.name, self.age), end=&quot; &quot;)class Teacher(SchoolMember): &apos;&apos;&apos;代表一位老师。&apos;&apos;&apos;def __init__(self, name, age, salary): SchoolMember.__init__(self, name, age) self.salary = salary print(&apos;(Initialized Teacher: &#123;&#125;)&apos;.format(self.name)) def tell(self): SchoolMember.tell(self) print(&apos;Salary: &quot;&#123;:d&#125;&quot;&apos;.format(self.salary))class Student(SchoolMember): &apos;&apos;&apos;代表一位学生。&apos;&apos;&apos;def __init__(self, name, age, marks): SchoolMember.__init__(self, name, age) self.marks = marks print(&apos;(Initialized Student: &#123;&#125;)&apos;.format(self.name)) def tell(self): SchoolMember.tell(self) print(&apos;Marks: &quot;&#123;:d&#125;&quot;&apos;.format(self.marks))t = Teacher(&apos;Mrs. Shrividya&apos;, 40, 30000)s = Student(&apos;Swaroop&apos;, 25, 75)# 打印一行空白行 print()members = [t, s]for member in members:# 对全体师生工作 member.tell() 有一些特征是他们都具有的，例如姓名、年龄和地址。另外一些特征是他们独有的，一如教师的薪水、课程与假期，学生的成绩和学费。你可以为每一种类型创建两个独立的类，并对它们进行处理。但增添一条共有特征就意味着将其添加进两个独立的类。这很快就会使程序变得笨重。一个更好的方法是创建一个公共类叫作 SchoolMember ，然后让教师和学生从这个类中继承 ，也就是说他们将成为这一类型(类)的子类型，而我们就可以向这些子类型中添加某些该类独有的特征。这种方法有诸多优点。如果我们增加或修改了 SchoolMember 的任何功能，它将自动反映在子类型中。举个例子，你可以通过简单地向 SchoolMember 类进行操作，来为所有老师与学生添加一条新的 ID 卡字段。不过，对某一子类型作出的改动并不会影响到其它子类型。另一大优点是你可以将某一老师或学生对象看作 SchoolMember 的对象并加以引用，这在某些情况下会大为有用，例如清点学校中的成员数量。这被称作多态性(Polymorphism)，在任何情 况下，如果父类型希望，子类型都可以被替换，也就是说，该对象可以被看作父类的实例。同时还需要注意的是我们重用父类的代码，但我们不需要再其它类中重复它们，当我们使用独立类型时才会必要地重复这些代码。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础(2)]]></title>
    <url>%2F2016%2F03%2F30%2FPythonBasics(2)%2F</url>
    <content type="text"><![CDATA[🤔 函数函数是指可重复使用的程序片段。它们允许你为某个代码块赋􏰀名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用函数。 函数可以通过关键字 def 来定义：123def say(): print(&apos;Hello, World&apos;) say() 函数参数函数可以获取参数，这个参数的值由你所提供，借此，函数便可以利用这些值来做一些事情。这些参数与变量类似，这些变量的值在我们调用函数时已被定义，且在函数运行时均已赋值完成。在定义函数 时给定的名称称作“形参”，在调用函数时你所提供给函数的值称作“实参”。123456def reaArea(a, b): s = a * b return s x = 10 y = 5 print(reaArea(x, y)) 以上为计算机型面积的函数，调用reaArea函数时，我们以变量作为实参来调用函数，使得x的值赋给行参a、y的值赋给行参b，并返回两者的乘积。 函数参数可以设置默认参数值，如：def reaArea(a , b = 5): 有时可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通 过使用星号来实现 1234567def func(a = 7, *b, **c): print(&apos;a&apos;, a) for i in b: print(&apos;b&apos;, i) for key, value in c.items(): print(key, value) func(10, 9, 8, 7, 6, 5, x = 1, y = 2, z = 3) 输出：a 10 b 9 b 8 b 7 b 6 b 5 x 1 y 2 z 3 当声明一个如*a 星号参数时，从此处开始直到结束的所有位置参数都将被收集并汇集成一个元组。类似地，当声明一个诸如 **b 的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个字典。 局部变量在一个函数的定义中声明变量时，它们不会以任何方式与处于函数之外但具有相同名称的变量产生关系，也就是说，这些变量名只存在于函数这一局部。这被称为变量的作用域。所有变量的作用域是它们被定义的块，从定义它们的名字的定义点开始。1234567n = 7 def func(n): print(&quot;1:&quot;, n) n = 10 print(&quot;2:&quot;, n) func(n) print(&quot;3:&quot;, n) 输出：1: 7 2: 10 3: 7 第一次打印出存在于函数块第一行名为 n 的值时，使用的是在函数声明之上的主代码块中声明的这一参数的值。接着，将10赋值给n。n是我们这一函数的局部变量。因此，当改变函数中n的值的时候，主代码块中的n则不会受到影响。最后一句 print 语句，打印出主代码块中定义的n的值，由此确认它不受先前调用的函数中的局部变量的影响。 global语句如果想给一个在程序顶层的变量赋值(也就是说它不存在于任何作用域中，无论是函数还是类)，那么你必须告诉程序这一变量并非局部的，而是全局的。我们需要通过global语句来完成这件事。因为在不使用global语句的情况下，不可能为一个定义于函数之外的变量赋值。 12345678n = 7 def func(): global n print(&quot;1:&quot;, n) n = 10 print(&quot;2:&quot;, n) func() print(&quot;3:&quot;, n) 输出： 1: 7 2: 10 3: 10 global语句用以声明n是一个全局变量，因此，当我们在函数中为n进行赋值时，这一改动将影响到我们在主代码块中使用的n的值 return 语句 return 语句用于从函数中返回，也就是中断函数。我们也可以选择在中断函数时从函数中返回一个值。123456def reaArea(a, b): s = a * b return s x = 10 y = 5 print(reaArea(x, y)) 如果 return 语句没有搭配任何一个值则代表着返回 None 。 None 在 Python 中一个特殊的类型，代表空。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础(1)]]></title>
    <url>%2F2016%2F03%2F27%2FPython%20Basics(1)%2F</url>
    <content type="text"><![CDATA[🤔 赋值赋值语句可以创建新的变量，并为其赋值：12say = &apos;Hello, World&apos;num = 7 第一个语句将字符串赋给“say”变量；第二个语句将17赋给num。 表达式表达式是变量、值、操作符的组合，单独的值与变量也被看作一个表达式 语句语句是一段可以产生效果的代码单元，如创建一个变量或显示一个值： 12say = &apos;Hello, World&apos;print(say) print语句显示say的值 注释Python中注释以“#”开头：123# 这里是注释 say = &apos;Hello, World&apos; print(say) # 输出say的值 如上所示，注释可以单独占一行，也可以加入到代码结尾。 控制流if语句if语句用以检查条件:如果 条件为真(True)，我们将运行一块语句(if 块)，否则 我们将运行另一块语句(else 块)。else 从句是可选 的。1234567num = 7 if num &gt; 0: print(&apos;num为正数&apos;) elif num == 0: print(&apos;num等于0&apos;) else: print(&apos;num为负数&apos;) 此处输出：num为正数 for语句for…in 语句是循环语句的一种，其特点是会在一系列对象上进行迭代，意即它会遍历序列中的每一个项目。1234for i in range(1, 10): print(i) else: print(&apos;循环结束&apos;) 此处输出：1 2 3 4 5 6 7 8 9 循环结束 for 循环就会在(1-9)这一范围内展开递归—— for i in range(1,10) 等价于 for i in [1，2，3， 4，5，6，7，8，9] ，这个操作将依次将队列里的每个数字(或是对象)分配给 i ，一次一个，然后以 每个 i 的值执行语句块else 部分是可选的。当循环中包含他时，它总会在 for 循环结束后开始执 行，除非程序遇到了 break 语句。 while语句while 语句能够让你在条件为真的前提下重复执行某块语句。 while 语句也是 一种循环语句。 while 语句同样可以拥有 else 子句作为可选选项。123456789num = 7 isRun = True while isRun: if num == 0: isRun = False else: num = num - 1 else: print(num) 此处输出：0 While会在循环开始前检查变量是否为true，之后再执行相应的 while 块，直到变量为false，循环结束。 break语句break 语句用以中断循环语句，也就是中止循环语句的执行，即使循环条件没有变更为 False ，或队列中的项目尚未完全迭代依旧如此。123456for i in range(1, 10): print(i) if i == 3: break else: print(&apos;循环结束&apos;) 此处输出：1 2 3 continue语句continue 语句用以告诉 Python 跳过当前循环块中的剩余语句，并继续该循环的下一次迭代。12345678while True: s = input(&apos;请输入名字&apos;) if s == &apos;yu&apos;: break if len(s) &lt; 2: print(&apos;请输入至少两个字符&apos;) continue print(&apos;名字为&apos;, s) 此处接收用户输入的内容，只有字符串长度大于等于2程序才会对其进行处理。如果其长度小 于 2，便通过使用 continue 语句跳过代码块中的其余语句。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反汇编基础(不同语言的反汇编入口)]]></title>
    <url>%2F2015%2F10%2F01%2FDisassembly%20Basics%2F</url>
    <content type="text"><![CDATA[🤔 在我们反汇编时，第一步（这里不考虑脱壳的情况，脱壳会在之后介绍）就是要找代码的入口函数。 一般使用OD打开工程时，并不会直接跳转到程序入口，而是先执行一系列的初始化工作，这些初始化工作通常是我们不需要关心的，所以我们需要先跳出这些函数，直接找到程序入口。 如何找到入口时反汇编最基础的操作，因为太简单，过程不做赘述，下边是我总结的几种语言的入口特征： c++123456789101112131415161700401B70 &gt;/$ 55 PUSH EBP 00401B71 |. 8BEC MOV EBP,ESP00401B73 |. 6A FF PUSH -100401B75 |. 68 08254000 PUSH crackme.0040250800401B7A |. 68 F61C4000 PUSH &lt;JMP.&amp;MSVCRT._except_handler3&gt; 00401B7F |. 64:A1 0000000 MOV EAX,DWORD PTR FS:[0]00401B85 |. 50 PUSH EAX00401B86 |. 64:8925 00000 MOV DWORD PTR FS:[0],ESP00401B8D |. 83EC 68 SUB ESP,6800401B90 |. 53 PUSH EBX00401B91 |. 56 PUSH ESI00401B92 |. 57 PUSH EDI00401B93 |. 8965 E8 MOV [LOCAL.6],ESP00401B96 |. 33DB XOR EBX,EBX00401B98 |. 895D FC MOV [LOCAL.1],EBX00401B9B |. 6A 02 PUSH 200401B9D |. FF15 98214000 CALL DWORD PTR DS:[&lt;&amp;MSVCRT.__set_app_ty&gt; 汇编123456789101100401025 &gt;/$ 6A F6 PUSH -0A 00401027 |. E8 A0000000 CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt; 0040102C |. A3 00304000 MOV DWORD PTR DS:[403000],EAX00401031 |. 6A F5 PUSH -0B 00401033 |. E8 94000000 CALL &lt;JMP.&amp;kernel32.GetStdHandle&gt; 00401038 |. A3 04304000 MOV DWORD PTR DS:[403004],EAX0040103D |. 6A 01 PUSH 1 0040103F |. 68 00104000 PUSH EchoLine.00401000 00401044 |. E8 8F000000 CALL &lt;JMP.&amp;kernel32.SetConsoleCtrlHandle&gt;00401049 |. 6A 07 PUSH 7 0040104B |. FF35 00304000 PUSH DWORD PTR DS:[403000] Delphi1234567891011121314151617180045D408 &gt; $ 55 push ebp0045D409 . 8BEC mov ebp,esp0045D40B . 83C4 F0 add esp,-0x100045D40E . B8 28D24500 mov eax,DELPHI.0045D2280045D413 . E8 6088FAFF call DELPHI.00405C780045D418 . A1 4CF14500 mov eax,dword ptr ds:[0x45F14C]0045D41D . 8B00 mov eax,dword ptr ds:[eax]0045D41F . E8 08DFFFFF call DELPHI.0045B32C0045D424 . 8B0D 40F24500 mov ecx,dword ptr ds:[0x45F240] 0045D42A . A1 4CF14500 mov eax,dword ptr ds:[0x45F14C]0045D42F . 8B00 mov eax,dword ptr ds:[eax]0045D431 . 8B15 CCC84500 mov edx,dword ptr ds:[0x45C8CC] 0045D437 . E8 08DFFFFF call DELPHI.0045B3440045D43C . A1 4CF14500 mov eax,dword ptr ds:[0x45F14C]0045D441 . 8B00 mov eax,dword ptr ds:[eax]0045D443 . E8 7CDFFFFF call DELPHI.0045B3C40045D448 . E8 2769FAFF call DELPHI.00403D740045D44D . 8D40 00 lea eax,dword ptr ds:[eax] 易语言123456789101112131415004464D1 &gt;/$ 55 push ebp004464D2 |. 8BEC mov ebp,esp004464D4 |. 6A FF push -0x1004464D6 |. 68 B0C14600 push 易语言.0046C1B0004464DB |. 68 DCAC4400 push 易语言.0044ACDC 004464E0 |. 64:A1 0000000&gt;mov eax,dword ptr fs:[0]004464E6 |. 50 push eax004464E7 |. 64:8925 00000&gt;mov dword ptr fs:[0],esp004464EE |. 83EC 58 sub esp,0x58004464F1 |. 53 push ebx004464F2 |. 56 push esi004464F3 |. 57 push edi ; ntdll.7C930228004464F4 |. 8965 E8 mov [local.6],esp004464F7 |. FF15 98514600 call dword ptr ds:[&lt;&amp;KERNEL32.GetVersion&gt;; kernel32.GetVersion004464FD |. 33D2 xor edx,edx vb1234567004013EC &gt; $ 68 A4244000 PUSH Crack.004024A4004013F1 . E8 F0FFFFFF CALL &lt;JMP.&amp;MSVBVM60.ThunRTMain&gt;004013F6 . 0000 ADD BYTE PTR DS:[EAX],AL004013F8 . 0000 ADD BYTE PTR DS:[EAX],AL004013FA . 0000 ADD BYTE PTR DS:[EAX],AL004013FC . 3000 XOR BYTE PTR DS:[EAX],AL004013FE . 0000 ADD BYTE PTR DS:[EAX],AL]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,world]]></title>
    <url>%2F2015%2F07%2F23%2FHello%2CWorld%2F</url>
    <content type="text"><![CDATA[Zero]]></content>
      <categories>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>Yu</tag>
      </tags>
  </entry>
</search>
