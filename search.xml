<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Lua进阶]]></title>
    <url>%2F2016%2F07%2F09%2FLua%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[🤔 Lua协程 协程类似于线程，是一条执行序列，拥有自己独立的栈、局部变量和指令指针，同时与其他协程共享全局变量等。 线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。就是说，一个具有多个协程的程序在任意时刻只能运行一个协程，并且正在运行的协程只有在其显式的要求挂起时，他的执行才会暂停。 Lua将所有协程相关的函数放在一个名为“coroutine”的table中，其中主要方法有： 方法 描述 create() 用于创建新的协程，返回一个协程类型的值，参数是一个函数 resume() 用于启动或重启一个协程 yield() 挂起一个协程 wrap() 创建一个新协程，返回一个函数，调用函数时开启协程 status() 查看协程状态 通过status可以查看到一个协程可以处于4种不同的状态，分别是挂起（suspended）、运行（running）、死亡（dead）、正常（normal），当创建一个协程时，它处于挂起状态:1234567co = coroutine.create( function () print(&apos;Hello, World&apos;) end)print(coroutine.status(co)) 输出：suspended --协程处于挂起状态 通过resume启动这个协程：12coroutine.resume(co)print(coroutine.status(co)) 输出：12Hello, Worlddead -- 处于死亡状态 协程真正强大之处在于yield函数，该函数可以使一个运行中的协程处于挂起，而后再恢复他的运行：123456789co = coroutine.create( function () for i = 1, 10 do print(i) coroutine.yield() end end)coroutine.resume(co) 输出：121suspended --处于挂起状态 在这里，当唤醒协程时它开始执行，直到遇到yield，协程会被挂起，此时的活动都发生在yield调用中，当恢复协程执行，对于yield的调用才会最终返回，然后写成继续执行，直到下一个yield或执行结束：123for i = 1, 10 do coroutine.resume(co)end 输出：2 3 4 5 6 7 8 9 10再最后一次调用时，协程的内容已经执行完毕，并已经返回。因此这是的协程处于死亡状态，没有输出，如果试图再次执行它，resume将返回false及一条错误信息：print(coroutine.resume(co))输出：false cannot resume dead coroutine 下面是一个综合的实例：123456789101112131415161718192021222324function foo (a) print(&quot;foo 函数输出&quot;, a) return coroutine.yield(2 * a) -- 返回 2*a 的值end co = coroutine.create(function (a , b) print(&quot;第一次协同程序执行输出&quot;, a, b) -- co-body 1 10 local r = foo(a + 1) print(&quot;第二次协同程序执行输出&quot;, r) local r, s = coroutine.yield(a + b, a - b) -- a，b的值为第一次调用协同程序时传入 print(&quot;第三次协同程序执行输出&quot;, r, s) return b, &quot;结束协同程序&quot; -- b的值为第二次调用协同程序时传入end) print(&quot;main&quot;, coroutine.resume(co, 1, 10)) -- true, 4print(&quot;--分割线----&quot;)print(&quot;main&quot;, coroutine.resume(co, &quot;r&quot;)) -- true 11 -9print(&quot;---分割线---&quot;)print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- true 10 endprint(&quot;---分割线---&quot;)print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- cannot resume dead coroutineprint(&quot;---分割线---&quot;) 输出:123456789101112第一次协同程序执行输出 1 10foo 函数输出 2main true 4--分割线----第二次协同程序执行输出 rmain true 11 -9---分割线---第三次协同程序执行输出 x ymain true 10 结束协同程序---分割线---main false cannot resume dead coroutine---分割线--- Lua元表和元方法 通常Lua中的每个值都有一套预定义的操作集合。例如数字四则运算，字符串链接，增加table的键值对等。但无法将两个table相加,无法对函数做比较，也无法调用字符串。 我们可以通过元表来修改一个值的行为，使其在面对一个非预定义的操作时执行一个指定的操作。如上所诉，可以通过元表让两个table相加。当Lua试图将两个table相加时，会先检测两者之一是否有元表，然后检测该元表中是否有__add字段，若找到该字段，就调用该字段对应的值。这个值也就是所谓的元方法（通常是一个函数或者table），这个函数会用于计算两个table的和。 Lua中的每一个值都有一个元表，table和userdata可以有各自独立的元表，其他类型则共享其类型所属的单一元表。Lua在创建新的table时不会创建元表。 Lua中有两个重要的函数处理元表： setmetatable(table, metatable): 对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。 getmetatable(table): 返回对象的元表(metatable)。 123t = &#123;&#125;t1 = &#123;&#125;setmetatable(t, t1) 上面的代码可以简化为一行：t = setmetatable({}, {}) 任何table都可以作为任何值的元表，而一组相关的table也可以共享一个通用的元表，此元表描述了他们的共同行为。一个table甚至可以作为其自己的元表，用于描述其特有的行为。 在Lua代码中只能设置table的元表，若要设置其他类型值的元表，则必须通过c代码来完成。 __index元方法 当访问一个table不存在的字段时，会返回nil。这些访问会促使解释器去查找一个叫做__index的元方法，如果没有这个方法，那么访问结果就会为nil，否则就由这个元方法来提供结果。 假设要创建一个窗口的table，table中需要有位置、大小、背景等参数，所有参数都有默认值，因此希望在创建窗口对象时可以仅指定除了默认值的其他参数，这里我们可以这样实现：123456789101112131415window = &#123;&#125; --命名空间window.prototype = &#123;x = 0, y = 0, width = 70, height = 70&#125; --原型窗口window.mt = &#123;&#125; --创建元表function window.new(o) --声明构造函数 setmetatable(o, window.mt) return oendwindow.mt.__index = function(table, key) --定义元方法 return window.prototype[key]endw = window.new&#123;x = 10, y = 20&#125; -- 创建一个新窗口print(w.width)--查询它没有的字段--这里输出 70 __newindex元方法 newindex元方法和index类似，不同之处在于前者用于table更新，而后者用于在table中查询，当对一个table中不存在的索引赋值时，解释器就会查找这个元方法，如果有，解释器就调用它，而不是执行赋值。如果这个元方法是一个table，解释器就在这个table中赋值，而不是对原来的table。例：12345678910t1 = &#123;&#125;t = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123; __newindex = t1 &#125;)print(t.key1)t.newkey = &quot;新值2&quot;print(t.newkey,t1.newkey)t.key1 = &quot;新值1&quot;print(t.key1,t1.key1) 输出：123value1nil 新值2新值1 nil 算数类元方法 Lua中每种算数操作符都有对应的字段名，如下所示： | add | 对应运算符”+” || sub | 对应运算符”-” || mul | 对应运算符”*” || div | 对应运算符”/” || unm | 对应运算符”-” || concat | 对应运算符”..” || eq | 对应运算符”==” || mod | 对应运算符”%” || pow | 对应运算符”^” || lt | 对应运算符”&lt;” | __tostring元方法 函数print总是调用tostring来格式化输出。当格式化任意值时，tosrting会检查该值是否有__tostring元方法，如果有，tostring就会用该值作为参数来调用这个元方法。12345678910t = setmetatable(&#123; 10, 20, 30 &#125;, &#123; __tostring = function(t) sum = 0 for k, v in pairs(t) do sum = sum + v end return &quot;表所有元素的和为 &quot; .. sum end&#125;)print(t) 输出：表所有元素的和为 60]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua基础]]></title>
    <url>%2F2016%2F07%2F04%2FLua%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[🤔 Lua IDEMac端Lua IDE推荐使用Intellij+EmmyLua。这也是我使用过最好的Lua IDE下载地址：IntelliJ IDEAEmmyLua安装方法：Preferences ——&gt;Plugins ——&gt;搜索EmmyLua 在使用EmmyLua时出现bug，或对此插件有什么建议，可以加群：29860775进行反馈 Lua 数据类型Lua是一种动态类型的语言。在语言中没有类型定义的语法，每个值都携带了它自身的类型信息。在Lua中有8种基础类型，分别是nil、boolean、number、string、userdata、function、thread和table 名称 数据类型 描述 示例 nil 空类型 表示一个无效值 a boolean 布尔 包含两个值：false和true a = true number 数字 双精度类型的实浮点数 a = 7 string 字符串 由一对双引号或单引号来表示 a = ‘yu’ userdata 自定义类型 任意存储在变量中的C数据结构 标准i/o库 function 函数 由 C 或 Lua 编写的函数 见下文 thread 协程 表示执行的独立线路，用于执行协同程序 table 表 Lua 中的表其实是一个”关联数组” a = {} 字符串 Lua中的字符串通常表示“一个字符序列”。 Lua完全采用8位编码，Lua字符串中的字符可以具有任何数值编码，包括数值0。 也就是说，可以将任意二进制数据存储到一个字符串中。 Lua的字符串是不可变的值。 Lua的字符串和其他Lua对象一样，都是自动内存管理机制所管理的对象 Lua字符串可以用以下方式来表示：s = &#39;Hello, World&#39;s = &quot;Hello, World&quot; Lua 提供了很多的方法来支持字符串的操作，可以查阅Lua 字符串来了解更多 变量 Lua 变量有两种类型：全局变量、局部变量。 Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声 明为局部变量。 局部变量的作用域为从声明位置开始到所在语句块结束。 变量的默认值均为 nil。local i = 1 --局部变量 Lua 流程控制 lua提供了一组传统的流程控制，if-else if语句先测试条件，然后根据结果执行then部分或else部分，其中else部分是可选的：123456789a = 0if a &gt; 0 then print(&apos;a &gt; 0&apos;)elseif a &lt; 0 then print(&apos;a&lt; 0&apos;)else print(&apos;a = 0&apos;)end Lua 循环 Lua 语言提供了以下几种循环: while for repeat…until 同时Lua 支持 break语句 while 与其他语言一样，Lua中的while循环先测试条件，如果条件为真，就执行循环体，否则结束循环：12345a = 0while a &lt; 10 do print(a) a = a + 1end repeat Lua中repeat-until语句会重复执行循环体至条件为真时结束：12345a = 0repeat print(a) a = a + 1until a &gt; 10 for Lua的for循环有两种形式： 数字型for 泛型for 数字型：123for i = 1, 10, 2 do print(i)end 含义为，i从1变化到10，每次变化以2作为步长递增并执行循环体。 其中步长是可选的，若不指定，则步长默认为1 泛型：1234days = &#123;&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;&#125;for i,v in ipairs(days) do print(i, v) end 泛型for循环通过一个迭代器函数来遍历所有的值，在Lua中，提供了ipairs这个用于便利数组的迭代器函数。每次循环，i会被赋予一个索引值，v会被赋予一个对应该索引值的数组元素值。泛型for循环的功能非常强大，可以通过不同的迭代器来遍历所有东西。如：迭代文件中的每行（io.lines）、迭代table元素（pairs）、迭代数组元素（ipairs）、迭代字符串中的字符（string.gmatch）等。当然，还可以自己编写迭代器。 break break语句用于结束一个循环，它只会跳出包含它的内部循环，而不会改变外部循环。例：123456789a = 0while a &lt; 10 do a = a + 1 if a &gt; 5 then break end print(a)end function 在Lua中，函数作为“一等对象”。这表示函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。这种特性使语言具有极大的灵活性。 Lua对函数式编程也提供了良好的支持。 Lua既可以调用自身的Lua编写的函数，也可以调用c编写的函数。 函数的定义如下：12345function SumTowNum(num1 , num2) return num1 + num2endprint(SumTowNum(10, 11)) 输出：21 Lua函数可以返回多个结果值，比如：12345678910111213function maximum (a) local mi = 1 -- 最大值索引 local m = a[mi] -- 最大值 for i,val in ipairs(a) do if val &gt; m then mi = i m = val end end return m, miendprint(maximum(&#123;8,10,23,12,5&#125;)) 输出:23 3 Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 …表示函数有可变的参数。 table表 Lua table 实现了关联数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。 Lua table 是不固定大小的，你可以根据自己需要进行扩容。 table是Lua中主要的（事实上也是仅有的）数据结构机制，具有强大的功能，基于table，可以以一种简单、统一和高效的方式来表示普通数组、符号表、集合、记录、队列及其他数据结构。同时Lua也是通过table来表示模块、包和对象的 可以将table想象成一种动态分配的对象，程序仅持有一个对它的引用（或指针）。 table的创建是通过构造表达式完成的： 1234--创建tablea = &#123;&#125;b = &apos;x&apos;a.b = 10 -- key = &apos;x&apos;. value = 10 tabel永远是匿名的，一个持有table的变量和table自身之间没有固定的关联性。]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua简介]]></title>
    <url>%2F2016%2F07%2F03%2FLua%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[🤔 Lua是可扩展的轻量级编程语言，它是用C语言编写的，并于1993年开始作为一个内部项目开始诞生。Lua代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。一个完整的Lua解释器不过200k，在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。它从一开始就设计为可以与用C语言编写等常规语言的代码集成软件。这种整合带来了很多好处。它不会尝试做C已经可以做东西，但旨在提供那些C是不好的：从测试和调试的硬件，动态结构，没有冗余，松藕合。对于这一点，lua有一个安全的环境，自动内存管理，以及处理字符串和其他类型的动态尺寸数据良好的设计。 特点Lua提供了一组独特的功能，使得它与其他语言不同。这些包括： 扩展 简单 高效 便携 免费和开源 示例代码:print(&quot;Hello World!&quot;) Lua如何实现Lua中包括的部件为Lua解释部分和运行软件系统。该软件系统功能是一个实际的计算机应用程序，它可以解释写在Lua的编程语言程序。 Lua解释是用ANSI C编写，因此它是非常便携，可以从高端网络服务器，以及小型设备设备上运行。Lua语言解释器非常成熟，体积小，速度快。它已经从其他编程语言和上层软件的标准演变而来的。作为小型程序可以在低内存小的设备上运行。 Lua相关用途 游戏编程 脚本中的独立应用程序 网页脚本 扩展和插件像MySQL代理和MySQL数据库的工作台 安全系统，如入侵检测系统]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python装饰器]]></title>
    <url>%2F2016%2F06%2F25%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[🤔 装饰器介绍 Python装饰器是程序开发中经常使用到的功能，熟练掌握装饰器会让你的编程思路更加广阔 要理解装饰器，首先要先理解： 在 Python 中“函数是一等对象” 。即函数是一种特殊类型的变量，可以和其余变量一样，可以作为参数传递给函数，也可以作为返回值返回。Python 中的整数、字符串和字典等都是一等对象。 函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。 装饰器实现装饰器本质上是python函数，它可以使其他函数在不需要做代码变动的情况下增加新的功能，装饰器返回值也是一个函数对象。 以下是一个简单的例子：假设现在有一个函数sayHi，用来输出一句话 1234def sayHi(): print(&apos;Hello, World&apos;)s = sayHis() 输出：Hello, World 我想希望在不修改sayHi函数的情况下在其之前再输出一句话,这种在代码运行期间动态增加功能的方式，称之为“装饰器”。本质上，装饰器就是一个返回函数的高阶函数 我们可以这么写： 12345678910def sayName(func): def inner(): print(&quot;I&apos;m Yu&quot;) return func return inner()def sayHi(): print(&apos;Hello, World&apos;)s = sayName(sayHi)s() 输出：12I&apos;m YuHello, World 但代码美中不足的是，我们每次给sayHi增加功能都需要用到类似s = sayName(sayHi)这句话。python为了简化这种情况，提供了一个语法糖“@”。 简化上边的代码: 1234567891011def sayName(func): def inner(): print(&quot;I&apos;m Yu&quot;) return func() return inner@sayNamedef sayHi(): print(&apos;Hello, World&apos;)sayHi() 输出：12I&apos;m YuHello, World 装饰器原理以上代码中，首先，在装饰器函数sayName中，sayName需要接受一个参数func，在其内部又定义了一个inner函数，在inner函数中增加一句输出，并返回func对象，然后sayName函数返回内部函数inner，其实就是一个闭包函数。接下来在sayHi上边增加一个@sayName，其意义就是在python解释器之行到此处时，会调用装饰器函数（sayName），并把被装饰得函数（sayHi）作为参数传入。此时的sayHi已经不是未加装饰时的函数了，而是指向sayName.inner函数地址。在接下来调用sayHi()时，其实就是调用sayName.inner。 有参函数装饰之前的例子是对无参函数的装饰，如果装饰带参数的函数该如何处理？1234567891011def sayName(func): def inner(name): print(&quot;I&apos;m Yu&quot;) return func(name) return inner@sayNamedef sayHi(name): print(&apos;Hi,&apos; + name)sayHi(&apos;siri&apos;) 输出：12I&apos;m YuHi,siri 两个装饰器装饰函数这里测试两个装饰器装饰一个函数的结果：1234567891011121314151617181920def sayName(func): print(&apos;name&apos;) def inner(): print(&quot;I&apos;m Yu&quot;) return func() return innerdef sayAge(func): print(&apos;age&apos;) def inner(): print(&quot;i&apos;m 30&quot;) return func() return inner@sayName@sayAgedef sayHi(): print(&apos;Hello, World&apos;)sayHi() 输出:12345agenameI&apos;m Yui&apos;m 30Hello, World 接下来分析输出这个结果的原因：首先，python解释器执行到第一个装饰器@sayName，在接下来发现装饰器下边不是一个函数而是另一个装饰器，解释器会执行第二个的装饰器@sayAge，然后把sayHi函数传入装饰器，所以首先输出了“age”，当@sayAge装饰完成，此时的sayHi函数地址指向了sayAge.inner的地址，解释器会返回去执行@sayName装饰器来装饰新的sayHi，从而输出了“name”，接着函数当前指向sayName.inner会先输出“I’m Yu”，在这里返回的func()其实就是返回的sayAge.inner，所以在下面输出i’m 30，最后输出原本sayHi的“Hello, World” 有参装饰器下边是装饰器带参数：1234567891011121314def now(time): def sayName(func): def inner(name): print(&apos;现在是: %s&apos; % time) print(&quot;I&apos;m Yu&quot;) return func(name) return inner return sayName@now(&apos;2016/10/30&apos;)def sayHi(name): print(&apos;Hello,&apos; + name)sayHi(&apos;siri&apos;) 输出：123现在是: 2016/10/30I&apos;m YuHello,siri 以上就是python装饰器的相关介绍]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数式编程]]></title>
    <url>%2F2016%2F06%2F17%2Fpython%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[🤔 函数式编程函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。 函数式编程Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。函数式编程就是一种抽象程度很高的编程范式。在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言 函数式编程的优点 逻辑可证 这是一个学术上的优点：没有”边界效应”使得更容易从逻辑上证明程序是正确的。 边界效应是指在进行程序设计时，我们的编程思想、算法以及分析测试的数据有可能会接近我们所没有注意的边界。所有的操作设计都会有一个边界，例如整形数据的内存，很多情况下在进行程序设计时，往往会被我们所忽略 模块化 函数式编程推崇简单原则，一个函数只做一件事情，将大的功能拆分成尽可能小的模块。小的函数更易于阅读和检查错误。 组件化 小的函数更容易加以组合形成新的功能。 易于调试 细化的、定义清晰的函数使得调试更加简单。当程序不正常运行时，每一个函数都是检查数据是否正确的接口，能更快速地排除没有问题的代码，定位到出现问题的地方。 易于测试 不依赖于系统状态的函数无须在测试前构造测试桩，使得编写单元测试更加容易。 更高的生产率 函数式编程产生的代码比其他技术更少（往往是其他技术的一半左右），并且更容易阅读和维护。 函数式编程的特征在支持函数式编程的语言中，大量使用如下特征的代码即可被认为是函数式： 函数是一等公民 函数能作为参数传递，或者是作为返回值返回。 匿名函数(lambda) lambda提供了快速编写简单函数的能力 闭包 闭包引用了外层函数的变量，然后返回内层函数 内置的不可变数据结构 如python中的元组 内置模板函数::见下文中的高阶函数:: 递归 匿名函数(lambda)当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。例：12p = lambda x: x+xprint(p(10) 其等价于：1234def test(x): return x+xp = test(10)print(p) 这里我建议尽量避免使用lambda。lambda功能十分有限，只能有一个表达式，返回值就是该表达式的结果。最主要是语句过于复杂，lambda表达式会很难阅读 高阶函数 能接收函数做参数的函数: 变量可以指向函数 函数的参数可以接收变量 一个函数可以接收另一个函数作为参数如：python内置函数，map()函数、reduce()函数、filter()函数等 Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数 例： 1234def test(x, y, z): return z(x, y)print(test(2, 3, pow)) 这里x，y是两个数值，z是一个函数 偏函数Python的functools模块提供了很多有用的功能，偏函数是其中之一，偏函数把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。如int()函数，其提供了base参数，默认值为10。如果传入base参数，就可以做进制的转换int(&#39;101010&#39;, base=2)如果经常需要做二进制转换我们就可以自己定义一个int2()函数12def int2(x, base=2): return int(x, base) 这里如果我们使用functools.partial，就可以非常方便的直接创建一个int2()12from functools import partialint2 = partial(int, base=2)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Functional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#]]></title>
    <url>%2F2016%2F05%2F01%2FC%23%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[🤔 C# 是一种面向对象的语言。不仅如此，C# 还进一步支持面向组件的编程。 当代软件设计越来越依赖采用自描述的独立功能包形式的软件组件。 此类组件的关键特征包括：为编程模型提供属性、方法和事件；包含提供组件声明性信息的特性；包含自己的文档。 C# 提供了语言构造来直接支持这些概念，让 C# 成为一种非常自然的语言，可用于创建和使用软件组件。 多项 C# 功能有助于构造可靠耐用的应用程序：垃圾回收可自动回收无法访问的未使用对象占用的内存；异常处理提供了一种结构化的可扩展方法来执行错误检测和恢复；C# 语言的类型安全设计禁止读取未初始化的变量、为范围之外的数组编制索引或执行未检查的类型转换。 C# 采用统一的类型系统。 所有 C# 类型（包括 int 和 double 等基元类型）均继承自一个根 object 类型。 因此，所有类型共用一组通用运算，任何类型的值都可以一致地进行存储、传输和处理。 此外，C# 还支持用户定义的引用类型和值类型，从而支持对象动态分配以及轻量级结构的内嵌式存储。为了确保 C# 程序和库能够随着时间的推移以兼容的方式发展，C# 设计更强调版本控制。 许多编程语言很少关注这个问题，因此，当引入新版依赖库时，用这些语言编写的程序会出现更多不必要的中断现象。 由于更强调版本控制，直接受影响的 C# 设计方面包括单独的 virtual 和 override 修饰符、关于方法重载决策的规则，以及对显式接口成员声明的支持。 C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。下面列出了 C# 成为一种广泛应用的专业语言的原因：现代的、通用的编程语言。面向对象。面向组件。容易学习。结构化语言。它产生高效率的程序。它可以在多种计算机平台上编译。.Net 框架的一部分。C# 强大的编程功能虽然 C# 的构想十分接近于传统高级语言 C 和 C++，是一门面向对象的编程语言，但是它与 Java 非常相似，有许多强大的编程功能，因此得到广大程序员的青睐。下面列出 C# 一些重要的功能：布尔条件（Boolean Conditions）自动垃圾回收（Automatic Garbage Collection）标准库（Standard Library）组件版本（Assembly Versioning）属性（Properties）和事件（Events）委托（Delegates）和事件管理（Events Management）易于使用的泛型（Generics）索引器（Indexers）条件编译（Conditional Compilation）简单的多线程（Multithreading）LINQ 和 Lambda 表达式集成 Windows详细指南可参考msdn，.net官方指南]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据结构]]></title>
    <url>%2F2016%2F04%2F01%2FPython%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[🤔 字符串字符串是字符的序列，可以使用单引号、双引号及三引号来指定字符串123456name = &apos;etnly&apos; name = &quot;etnly&quot; # 两者工作机制完全相同 &apos;&apos;&apos;这是一个多行字符串 这是第二行 这位是第三行&apos;&apos;&apos; 在程序中使用的所有字符串都是str类下的对象，并且它也具有自己的方法，具体的方法清单可以查阅 help(str) 。 12345678910 # 返回字符串长度name = &apos;etnly&apos;len(name) # 遍历字符串name = &apos;etnly&apos;for i in name: print(i) # 字符串切片print(name[1:3]) # 输出 tn 列表列表是一种用于保存一系列有序项目的集合，也就是说，你可以利用列表保存一串项目的序列。和字符串类似，在字符串中这些项目是字符，而列表中它可以是任何类型，列表中的值称为元素。 创建列表最简单的方式是使用 [] 方括号： 123num = [1, 2, 3] name = [&apos;张三&apos;, &apos;李四&apos;] other = [[1, 2, 3], &apos;a&apos;, &apos;b&apos; 3.0] 字符串的值是不可变的，而列表的值是可变的。如： 12num[1] = 3 print(num) 输出：[1, 3, 3] 列表对象也有自己的方法，具体可以查阅 help(list) 。 123456789101112 # 列表遍历num = [1, 2, 3]for i in num: print(i) # 列表拼接num2 = [2, 3, 4]num3 = num + num2 # 列表切片print(num3[1:3]) # 这里输出 [2, 3] # 添加元素num.append(4) 字典字典类似于列表，但更加通用，在列表中下表必须是整数，而字典中，下标基本可以是任意类型。 字典包含键（下标）和值。每一个键都关联一个值，这种方式称为键值对，字典体现了键到值的映射，所以可以说每一个键映射到一个值。 新建一个字典可以： d = {&#39;a&#39; : 1, &#39;b&#39; : 2, &#39;c&#39; : 3} d = dict() # 新建一个空字典 字典是通过散列表的方式实现的，意味着键必须是可散列的。散列是一个函数，接收值并返回一个整数，字典使用这些被称为散列值的整数来保存和查找键值对。 元组元组用于将多个对象保存到一起，其值可以是任何类型，并按照下标索引，元组和列表非常相似，其二者主要区别在于，元组是不可变的。元组通常用于保证某一语句或某一用户定义的函数可以安全地采用一组数值。 元组语法上用逗号分隔一列值，可以用括号括起来： t = &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2 t = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2) 用括号括起来单独的值如 t = (‘a’) 并不是元组，如要新建元组可以使用内置函数tuple t = tuple() 严格的来说函数只能返回一个值，但如果返回的是元组，就可以达到类似返回多个值的效果。 元组、列表和字典列表和元组zip函数，接收两个或多个序列，并返回一个元组列表，每个元组包含来自每个序列的一个元素。 123a = &apos;abc&apos; b = [0, 1, 2] print(zip(a, b)) 结果返回 &lt;zip object at 0x10d5e1b08&gt; 这是一个zip对象，它知道如何遍历每个元素对，zip对象是一种迭代器，即用来迭代访问一个序列的对象 使用zip最常见的方法是在for循环中：12for i in zip(a, b): print(i) 输出：(&#39;a&#39;, 0) (&#39;b&#39;, 1) (&#39;c&#39;, 2) 如果需要使用列表的操作，可以利用zip对象制作一个列表： list(zip(a, b)) 字典和元组字典方法items可以返回一个元组序列，其中每个元组是一个键值对：123d = &#123;0 : &apos;a&apos;, 1 : &apos;b&apos;, 2 : &apos;c&apos;&#125; t = d.items() print(t) 输出： dict_items([(0, &#39;a&#39;), (1, &#39;b&#39;), (2, ‘c’)]) 反过来可以使用元组列表来初始化一个字典：12t = [(0, &apos;a&apos;), (1, &apos;b&apos;), (2, ‘c’)] d = dict(t) 我们可以通过dict和items得到一个简洁的创建新字典的方法： d = dict(zip(&#39;abc&#39;, range(3))) 序列列表、元组和字符串可以看作序列(Sequence)的某种表现形式，序列的主要功能是资格测试(也就是 in 与 not in 表达式)和索引操作，它们能够允许我们直接获取序列中的特定项目。 引用当你创建了一个对象并将其分配给某个变量时，变量只会查阅某个对象，并且它也 不会代表对象本身。也就是说，变量名只是指向你计算机内存中存储了相应对象的那一部分。这叫作将名称绑定给那一个对象。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象]]></title>
    <url>%2F2016%2F04%2F01%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[🤔 面向对象的编程类与对象是面向对象编程的两个主要方面。一个类能够创建一种新的类型 ，其中对象就是类的实例。可以这样来类比:你可以拥有类型 int 的变量，也就是说存储整数的变量是 int 类的实例。 即使是整数也会被视为对象。这不同于 C++ 与c#，在它们那儿整数是原始内置类型 在Python中，一切皆为对象。 对象可以使用属于它的普通变量来存储数据。这种从属于对象或类的变量叫作字段 。对象还可以使用属于类的函数来实现某些功能，这种函数叫作类的方法 。这两个术语很重要，它有助于我们区分函数与变量，哪些是独立的，哪些又是属于类或对象的。总之，字段与方法通称类的属性。字段有两种类型——它们属于某一类的各个实例或对象，或是从属于某一类本身。它们被分别称作实例变量与类变量。 self类方法与普通函数只有一种特定的区别——前者必须有一个额外的名字，这个名字必须添加到参数列表的开头，但是你不用在你调用这个功能时为这个参数赋值，Python 会为它提供。 这种特定的变量引用的是对象本身，按照惯例，它被赋􏰀 self 这一名称。 Python 中的 self 相当于 C++ 中的指针以及 Java 与 C# 中的 this 指针。 类这是一个最简单的类：123class Person: pass # 空的代码块 p = Person() # 创建Person的对象p 方法一个简单的方法： 12345class Person: def sayHi(self): print(‘Hello, World’) p = Person() p.sayHi() 输出: Hello, World 唯一与函数不同的地方在于这里多了一个self 继承面向对象编程的一大优点是对代码的重用，重用的一种实现方法就是通过继承机制。继承指的是根据一个现有的类型，定义一个修改版本的新类的能力。继承最好是想象成在类之间实现类型与子类型关系的工具。123456789101112131415161718192021222324252627282930class SchoolMember: &apos;&apos;&apos;代表任何学校里的成员。&apos;&apos;&apos;def __init__(self, name, age): self.name = name self.age = age print(&apos;(Initialized SchoolMember: &#123;&#125;)&apos;.format(self.name))def tell(self):&apos;&apos;&apos;告诉我有关我的细节。&apos;&apos;&apos;print(&apos;Name:&quot;&#123;&#125;&quot; Age:&quot;&#123;&#125;&quot;&apos;.format(self.name, self.age), end=&quot; &quot;)class Teacher(SchoolMember): &apos;&apos;&apos;代表一位老师。&apos;&apos;&apos;def __init__(self, name, age, salary): SchoolMember.__init__(self, name, age) self.salary = salary print(&apos;(Initialized Teacher: &#123;&#125;)&apos;.format(self.name)) def tell(self): SchoolMember.tell(self) print(&apos;Salary: &quot;&#123;:d&#125;&quot;&apos;.format(self.salary))class Student(SchoolMember): &apos;&apos;&apos;代表一位学生。&apos;&apos;&apos;def __init__(self, name, age, marks): SchoolMember.__init__(self, name, age) self.marks = marks print(&apos;(Initialized Student: &#123;&#125;)&apos;.format(self.name)) def tell(self): SchoolMember.tell(self) print(&apos;Marks: &quot;&#123;:d&#125;&quot;&apos;.format(self.marks))t = Teacher(&apos;Mrs. Shrividya&apos;, 40, 30000)s = Student(&apos;Swaroop&apos;, 25, 75)# 打印一行空白行 print()members = [t, s]for member in members:# 对全体师生工作 member.tell() 有一些特征是他们都具有的，例如姓名、年龄和地址。另外一些特征是他们独有的，一如教师的薪水、课程与假期，学生的成绩和学费。你可以为每一种类型创建两个独立的类，并对它们进行处理。但增添一条共有特征就意味着将其添加进两个独立的类。这很快就会使程序变得笨重。一个更好的方法是创建一个公共类叫作 SchoolMember ，然后让教师和学生从这个类中继承 ，也就是说他们将成为这一类型(类)的子类型，而我们就可以向这些子类型中添加某些该类独有的特征。这种方法有诸多优点。如果我们增加或修改了 SchoolMember 的任何功能，它将自动反映在子类型中。举个例子，你可以通过简单地向 SchoolMember 类进行操作，来为所有老师与学生添加一条新的 ID 卡字段。不过，对某一子类型作出的改动并不会影响到其它子类型。另一大优点是你可以将某一老师或学生对象看作 SchoolMember 的对象并加以引用，这在某些情况下会大为有用，例如清点学校中的成员数量。这被称作多态性(Polymorphism)，在任何情 况下，如果父类型希望，子类型都可以被替换，也就是说，该对象可以被看作父类的实例。同时还需要注意的是我们重用父类的代码，但我们不需要再其它类中重复它们，当我们使用独立类型时才会必要地重复这些代码。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础(2)]]></title>
    <url>%2F2016%2F03%2F30%2FPython%E5%9F%BA%E7%A1%80(2)%2F</url>
    <content type="text"><![CDATA[🤔 函数函数是指可重复使用的程序片段。它们允许你为某个代码块赋􏰀名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用函数。 函数可以通过关键字 def 来定义：123def say(): print(&apos;Hello, World&apos;) say() 函数参数函数可以获取参数，这个参数的值由你所提供，借此，函数便可以利用这些值来做一些事情。这些参数与变量类似，这些变量的值在我们调用函数时已被定义，且在函数运行时均已赋值完成。在定义函数 时给定的名称称作“形参”，在调用函数时你所提供给函数的值称作“实参”。123456def reaArea(a, b): s = a * b return s x = 10 y = 5 print(reaArea(x, y)) 以上为计算机型面积的函数，调用reaArea函数时，我们以变量作为实参来调用函数，使得x的值赋给行参a、y的值赋给行参b，并返回两者的乘积。 函数参数可以设置默认参数值，如：def reaArea(a , b = 5): 有时可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通 过使用星号来实现 1234567def func(a = 7, *b, **c): print(&apos;a&apos;, a) for i in b: print(&apos;b&apos;, i) for key, value in c.items(): print(key, value) func(10, 9, 8, 7, 6, 5, x = 1, y = 2, z = 3) 输出：a 10 b 9 b 8 b 7 b 6 b 5 x 1 y 2 z 3 当声明一个如*a 星号参数时，从此处开始直到结束的所有位置参数都将被收集并汇集成一个元组。类似地，当声明一个诸如 **b 的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个字典。 局部变量在一个函数的定义中声明变量时，它们不会以任何方式与处于函数之外但具有相同名称的变量产生关系，也就是说，这些变量名只存在于函数这一局部。这被称为变量的作用域。所有变量的作用域是它们被定义的块，从定义它们的名字的定义点开始。1234567n = 7 def func(n): print(&quot;1:&quot;, n) n = 10 print(&quot;2:&quot;, n) func(n) print(&quot;3:&quot;, n) 输出：1: 7 2: 10 3: 7 第一次打印出存在于函数块第一行名为 n 的值时，使用的是在函数声明之上的主代码块中声明的这一参数的值。接着，将10赋值给n。n是我们这一函数的局部变量。因此，当改变函数中n的值的时候，主代码块中的n则不会受到影响。最后一句 print 语句，打印出主代码块中定义的n的值，由此确认它不受先前调用的函数中的局部变量的影响。 global语句如果想给一个在程序顶层的变量赋值(也就是说它不存在于任何作用域中，无论是函数还是类)，那么你必须告诉程序这一变量并非局部的，而是全局的。我们需要通过global语句来完成这件事。因为在不使用global语句的情况下，不可能为一个定义于函数之外的变量赋值。 12345678n = 7 def func(): global n print(&quot;1:&quot;, n) n = 10 print(&quot;2:&quot;, n) func() print(&quot;3:&quot;, n) 输出： 1: 7 2: 10 3: 10 global语句用以声明n是一个全局变量，因此，当我们在函数中为n进行赋值时，这一改动将影响到我们在主代码块中使用的n的值 return 语句 return 语句用于从函数中返回，也就是中断函数。我们也可以选择在中断函数时从函数中返回一个值。123456def reaArea(a, b): s = a * b return s x = 10 y = 5 print(reaArea(x, y)) 如果 return 语句没有搭配任何一个值则代表着返回 None 。 None 在 Python 中一个特殊的类型，代表空。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础(1)]]></title>
    <url>%2F2016%2F03%2F27%2FPython%E5%9F%BA%E7%A1%80(1)%2F</url>
    <content type="text"><![CDATA[🤔 赋值赋值语句可以创建新的变量，并为其赋值：12say = &apos;Hello, World&apos;num = 7 第一个语句将字符串赋给“say”变量；第二个语句将17赋给num。 表达式表达式是变量、值、操作符的组合，单独的值与变量也被看作一个表达式 语句语句是一段可以产生效果的代码单元，如创建一个变量或显示一个值： 12say = &apos;Hello, World&apos;print(say) print语句显示say的值 注释Python中注释以“#”开头：123# 这里是注释 say = &apos;Hello, World&apos; print(say) # 输出say的值 如上所示，注释可以单独占一行，也可以加入到代码结尾。 控制流if语句if语句用以检查条件:如果 条件为真(True)，我们将运行一块语句(if 块)，否则 我们将运行另一块语句(else 块)。else 从句是可选 的。1234567num = 7 if num &gt; 0: print(&apos;num为正数&apos;) elif num == 0: print(&apos;num等于0&apos;) else: print(&apos;num为负数&apos;) 此处输出：num为正数 for语句for…in 语句是循环语句的一种，其特点是会在一系列对象上进行迭代，意即它会遍历序列中的每一个项目。1234for i in range(1, 10): print(i) else: print(&apos;循环结束&apos;) 此处输出：1 2 3 4 5 6 7 8 9 循环结束 for 循环就会在(1-9)这一范围内展开递归—— for i in range(1,10) 等价于 for i in [1，2，3， 4，5，6，7，8，9] ，这个操作将依次将队列里的每个数字(或是对象)分配给 i ，一次一个，然后以 每个 i 的值执行语句块else 部分是可选的。当循环中包含他时，它总会在 for 循环结束后开始执 行，除非程序遇到了 break 语句。 while语句while 语句能够让你在条件为真的前提下重复执行某块语句。 while 语句也是 一种循环语句。 while 语句同样可以拥有 else 子句作为可选选项。123456789num = 7 isRun = True while isRun: if num == 0: isRun = False else: num = num - 1 else: print(num) 此处输出：0 While会在循环开始前检查变量是否为true，之后再执行相应的 while 块，直到变量为false，循环结束。 break语句break 语句用以中断循环语句，也就是中止循环语句的执行，即使循环条件没有变更为 False ，或队列中的项目尚未完全迭代依旧如此。123456for i in range(1, 10): print(i) if i == 3: break else: print(&apos;循环结束&apos;) 此处输出：1 2 3 continue语句continue 语句用以告诉 Python 跳过当前循环块中的剩余语句，并继续该循环的下一次迭代。12345678while True: s = input(&apos;请输入名字&apos;) if s == &apos;yu&apos;: break if len(s) &lt; 2: print(&apos;请输入至少两个字符&apos;) continue print(&apos;名字为&apos;, s) 此处接收用户输入的内容，只有字符串长度大于等于2程序才会对其进行处理。如果其长度小 于 2，便通过使用 continue 语句跳过代码块中的其余语句。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,world]]></title>
    <url>%2F2015%2F07%2F23%2FHello%2CWorld%2F</url>
    <content type="text"><![CDATA[One]]></content>
      <categories>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
</search>
